<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head> <title>Grobner Bases</title> 
<meta  charset="UTF-8"" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="Grobner_Bases.css" /> 
<meta name="src" content="Grobner_Bases.tex" /> 
 <script type="text/x-mathjax-config"> MathJax.Hub.Config({ 'fast-preview': {disabled: true}, TeX: { extensions: ["color.js","AMSmath.js"], equationNumbers: { autoNumber: "AMS" } }, extensions: ["tex2jax.js"], tex2jax: {  inlineMath: [ ["\\\(","\\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true, processEnvironments: true } }); </script> 
 <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>  
</head><body 
>
  <p style="display: none;">\( \newcommand{\cO}{\mathcal{O}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\GG}{\mathbb{G}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\LL}{\mathbb{L}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\SP}{\mathbb{S}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\FF}{\mathbb{F}}
\renewcommand{\AA}{\mathbb{A}}
\newcommand{\sF}{\mathscr{F}}
\newcommand{\sC}{\mathscr{C}}
\newcommand{\ts}{\textsuperscript}
\newcommand{\mf}{\mathfrak}
\newcommand{\scr}{\mathscr}
\newcommand{\cc}{\mf{c}}
\newcommand{\mg}{\mf{g}}
\newcommand{\ma}{\mf{a}}
\newcommand{\mh}{\mf{h}}
\newcommand{\mn}{\mf{n}}
\newcommand{\mc}{\mf{c}}
\newcommand{\ul}{\underline}
\newcommand{\mz}{\mf{z}}
\newcommand{\me}{\mf{e}}
\newcommand{\mff}{\mf{f}}
\newcommand{\mm}{\mf{m}}
\newcommand{\mt}{\mf{t}}
\newcommand{\pp}{\mf{p}}
\newcommand{\qq}{\mf{q}}
\newcommand{\gl}{\mf{gl}}
\newcommand{\msl}{\mf{sl}}
\newcommand{\so}{\mf{so}}
\newcommand{\mfu}{\mf{u}}
\newcommand{\su}{\mf{su}}
\newcommand{\msp}{\mf{sp}}
\renewcommand{\aa}{\mf{a}}
\newcommand{\bb}{\mf{b}}
\newcommand{\sR}{\mathscr{R}}
\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\ff}{\mf{f}}
\newcommand{\ee}{\epsilon}

\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}

\newcommand{\pushout}{\arrow[dr, phantom, "\ulcorner", very near start]}
\newcommand{\pullback}{\arrow[ul, phantom, "\llcorner", very near start]}

\newcommand{\simp}[1]{#1^{\Delta^{op}}}

\newcommand{\arrowtcupp}[2]{\arrow[bend left=50, ""{name=U, below,inner sep=1}]{#1}\arrow[Rightarrow,from=U,to=MU,"#2"]}
\newcommand{\arrowtclow}[2]{\arrow[bend right=50, ""{name=L,inner sep=1}]{#1}\arrow[Rightarrow,from=LM,to=L]{}[]{#2}} % if you want to change some parameter of the label.
\newcommand{\arrowtcmid}[2]{\arrow[""{name=MU,inner sep=1},""{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}
\newcommand{\dummy}{\textcolor{white}{\bullet}}


%for adjunction
\newcommand{\adjunction}[4]{
	#1\hspace{2pt}\colon #2	\leftrightharpoons #3 \hspace{2pt}\colon #4
}


%Math operators
\newcommand{\Set}{\mathop{\rm Set}\nolimits}
\newcommand{\Ind}{\mathop{\rm Ind}\nolimits}
\newcommand{\Sind}{\mathop{\rm Sind}\nolimits}
\newcommand{\Ext}{\mathop{\rm Ext}\nolimits}
\newcommand{\sd}{\mathop{\rm sd}\nolimits}
\newcommand{\Ex}{\mathop{\rm Ex}\nolimits}
\newcommand{\Out}{\mathop{\rm Out}\nolimits}
\newcommand{\Cyl}{\mathop{\rm Cyl}\nolimits}
\newcommand{\Path}{\mathop{\rm Path}\nolimits}
\newcommand{\Ch}{\mathop{\rm Ch}\nolimits}
\newcommand{\SSet}{\mathop{\rm \Set^{\Delta^{op}}}\nolimits}
\newcommand{\Sq}{\mathop{\rm Sq}\nolimits}
\newcommand{\Free}{\mathop{\rm Free}\nolimits}
\newcommand{\Maps}{\mathop{\rm Maps}\nolimits}
\newcommand{\LMaps}{\mathop{\rm LMaps}\nolimits}
\newcommand{\RMaps}{\mathop{\rm RMaps}\nolimits}
\newcommand{\MU}{\mathop{\rm MU}\nolimits}
\newcommand{\MSU}{\mathop{\rm MSU}\nolimits}
\newcommand{\MSp}{\mathop{\rm MSp}\nolimits}
\newcommand{\MSO}{\mathop{\rm MSO}\nolimits}
\newcommand{\MO}{\mathop{\rm MO}\nolimits}
\newcommand{\BU}{\mathop{\rm BU}\nolimits}
\newcommand{\BSU}{\mathop{\rm BSU}\nolimits}
\newcommand{\BSp}{\mathop{\rm BSp}\nolimits}
\newcommand{\BSO}{\mathop{\rm BSO}\nolimits}
\newcommand{\BO}{\mathop{\rm BO}\nolimits}
\newcommand{\Tor}{\mathop{\rm Tor}\nolimits}
\newcommand{\Cotor}{\mathop{\rm Cotor}\nolimits}
\newcommand{\imag}{\mathop{\rm Im}\nolimits}
\newcommand{\real}{\mathop{\rm Re}\nolimits}
\newcommand{\Cat}{\mathop{\rm Cat}\nolimits}
\newcommand{\Fld}{\mathop{\rm Fld}\nolimits}
\newcommand{\Frac}{\mathop{\rm Frac}\nolimits}
\newcommand{\Dom}{\mathop{\rm Dom}\nolimits}
\newcommand{\Hotc}{\mathop{\rm Hotc}\nolimits}
\newcommand{\Top}{\mathop{\rm Top}\nolimits}
\newcommand{\Ring}{\mathop{\rm Ring}\nolimits}
\newcommand{\CRing}{\mathop{\rm CRing}\nolimits}
\newcommand{\CGHaus}{\mathop{\rm CGHaus}\nolimits}
\newcommand{\Alg}{\mathop{\rm Alg}\nolimits}
\newcommand{\Bool}{\mathop{\rm Bool}\nolimits}
\newcommand{\hTop}{\mathop{\rm hTop}\nolimits}
\newcommand{\Nat}{\mathop{\rm Nat}\nolimits}
\newcommand{\Rel}{\mathop{\rm Rel}\nolimits}
\newcommand{\Mod}{\mathop{\rm Mod}\nolimits}
\newcommand{\Space}{\mathop{\rm Space}\nolimits}
\newcommand{\Vect}{\mathop{\rm Vect}\nolimits}
\newcommand{\FinVect}{\mathop{\rm FinVect}\nolimits}
\newcommand{\Matr}{\mathop{\rm Matr}\nolimits}
\newcommand{\Ab}{\mathop{\rm Ab}\nolimits}
\newcommand{\Gr}{\mathop{\rm Gr}\nolimits}
\newcommand{\Grp}{\mathop{\rm Grp}\nolimits}
\newcommand{\Hol}{\mathop{\rm Hol}\nolimits}
\newcommand{\Grpd}{\mathop{\rm Grpd}\nolimits}
\newcommand{\Mon}{\mathop{\rm Mon}\nolimits}
\newcommand{\FinSet}{\mathop{\rm FinSet}\nolimits}
\newcommand{\Sch}{\mathop{\rm Sch}\nolimits}
\newcommand{\AffSch}{\mathop{\rm AffSch}\nolimits}
\newcommand{\Idem}{\mathop{\rm Idem}\nolimits}
\newcommand{\SIdem}{\mathop{\rm SIdem}\nolimits}
\newcommand{\Aut}{\mathop{\rm Aut}\nolimits}
\newcommand{\Ord}{\mathop{\rm Ord}\nolimits}
\newcommand{\coker}{\mathop{\rm coker}\nolimits}
\newcommand{\ch}{\mathop{\rm char}\nolimits}%characteristic
\newcommand{\Sym}{\mathop{\rm Sym}\nolimits}
\newcommand{\adj}{\mathop{\rm adj}\nolimits}
\newcommand{\dil}{\mathop{\rm dil}\nolimits}
\newcommand{\Cl}{\mathop{\rm Cl}\nolimits}
\newcommand{\Diff}{\mathop{\rm Diff}\nolimits}
\newcommand{\End}{\mathop{\rm End}\nolimits}
\newcommand{\Hom}{\mathop{\rm Hom}\nolimits}% preferred
\newcommand{\Gal}{\mathop{\rm Gal}\nolimits}
\newcommand{\Pos}{\mathop{\rm Pos}\nolimits}
\newcommand{\Ad}{\mathop{\rm Ad}\nolimits}
\newcommand{\GL}{\mathop{\rm GL}\nolimits}
\newcommand{\SL}{\mathop{\rm SL}\nolimits}
\newcommand{\vol}{\mathop{\rm vol}\nolimits}
\newcommand{\reg}{\mathop{\rm reg}\nolimits}
\newcommand{\Or}{\mathop{\rm O}\nolimits}
\newcommand{\U}{\mathop{\rm U}\nolimits}
\newcommand{\SOr}{\mathop{\rm SO}\nolimits}
\newcommand{\SU}{\mathop{\rm SU}\nolimits}
\newcommand{\Spin}{\mathop{\rm Spin}\nolimits}
\newcommand{\Sp}{\mathop{\rm Sp}\nolimits}
\newcommand{\Int}{\mathop{\rm Int}\nolimits}
\newcommand{\im}{\mathop{\rm im}\nolimits}
\newcommand{\dom}{\mathop{\rm dom}\nolimits}
\newcommand{\di}{\mathop{\rm div}\nolimits}
\newcommand{\cod}{\mathop{\rm cod}\nolimits}
\newcommand{\colim}{\mathop{\rm colim}\nolimits}
\newcommand{\ad}{\mathop{\rm ad}\nolimits}
\newcommand{\PSL}{\mathop{\rm PSL}\nolimits}
\newcommand{\PGL}{\mathop{\rm PGL}\nolimits}
\newcommand{\sep}{\mathop{\rm sep}\nolimits}
\newcommand{\MCG}{\mathop{\rm MCG}\nolimits}
\newcommand{\oMCG}{\mathop{\rm MCG^+}\nolimits}
\newcommand{\Spec}{\mathop{\rm Spec}\nolimits}
\newcommand{\rank}{\mathop{\rm rank}\nolimits}
\newcommand{\diverg}{\mathop{\rm div}\nolimits}%Divergence
\newcommand{\disc}{\mathop{\rm disc}\nolimits}
\newcommand{\sign}{\mathop{\rm sign}\nolimits}
\newcommand{\Arf}{\mathop{\rm Arf}\nolimits}
\newcommand{\Pic}{\mathop{\rm Pic}\nolimits}
\newcommand{\Tr}{\mathop{\rm Tr}\nolimits}
\newcommand{\res}{\mathop{\rm res}\nolimits}
\newcommand{\Proj}{\mathop{\rm Proj}\nolimits}
\newcommand{\mult}{\mathop{\rm mult}\nolimits}
\newcommand{\N}{\mathop{\rm N}\nolimits}
\newcommand{\lk}{\mathop{\rm lk}\nolimits}
\newcommand{\Pf}{\mathop{\rm Pf}\nolimits}
\newcommand{\sgn}{\mathop{\rm sgn}\nolimits}
\newcommand{\grad}{\mathop{\rm grad}\nolimits}
\newcommand{\lcm}{\mathop{\rm lcm}\nolimits}
\newcommand{\Ric}{\mathop{\rm Ric}\nolimits}
\newcommand{\Hess}{\mathop{\rm Hess}\nolimits}
\newcommand{\sn}{\mathop{\rm sn}\nolimits}
\newcommand{\cut}{\mathop{\rm cut}\nolimits}
\newcommand{\tr}{\mathop{\rm tr}\nolimits}
\newcommand{\codim}{\mathop{\rm codim}\nolimits}
\newcommand{\ind}{\mathop{\rm index}\nolimits}
\newcommand{\rad}{\mathop{\rm rad}\nolimits}
\newcommand{\Rep}{\mathop{\rm Rep}\nolimits}
\newcommand{\Lie}{\mathop{\rm Lie}\nolimits}
\newcommand{\Der}{\mathop{\rm Der}\nolimits}
\newcommand{\hgt}{\mathop{\rm ht}\nolimits}
\newcommand{\Ider}{\mathop{\rm Ider}\nolimits}
\newcommand{\id}{\mathop{\rm id}\nolimits} \)</p>
  <div class="maketitle">
  <h2 class="titleHead">
GR&#x00D6;BNER BASES
  </h2><div class="authors"><span class="author" >
<span 
class="cmr-10">ISHAN LEVY</span>
  </span></div>
<div class="submaketitle">
</div>
  </div>
  <h3 class="sectionHead"><span class="titlemark">1. </span> <a 
 id="x1-10001"></a>Hilbert Basis Theorem &#x0026; Monomial Orderings</h3>
<!--l. 11--><p class="noindent" >Gr&#x00F6;bner bases are a great way to do computations in polynomial rings \(R[x_1,\dots ,x_n]\) which is quite
useful in algebraic geometry, where such rings are viewed as the ring of functions on an
a&#xFB03;ne space. They allow you to answer questions like:
</p>
          <ul class="itemize1">
       <li class="itemize">Given two ideals \(I,J\), how can you compute \(I \cap J\)?
          </li>
       <li class="itemize">Given an ideal \(I\), how can you make computations in the quotient \(K[x_1,\dots ,x_n]/I\)?
          </li>
       <li class="itemize">Given two ideals \(I,J\), how can you tell if they are the same?
          </li>
       <li class="itemize">How can you tell if an element is in the radical of an ideal?
          </li>
       <li class="itemize">How can you compute the saturation of an ideal with respect to a polynomial?
          </li>
       <li class="itemize">How can we &#xFB01;nd solutions to systems of polynomial equations &#x0028;when there
       are &#xFB01;nitely many&#x0029;?
          </li>
       <li class="itemize">How can we compute the ideal quotient \((I:J)=\{r | rJ \subset I\}\)</li></ul>
                                                                                  

                                                                                  
<!--l. 22--><p class="noindent" >These will all be answered here.
</p><!--l. 24--><p class="indent" >  The fundamental idea of the Gr&#x00F6;bner basis is seen in the proof of the Hilbert Basis
Theorem:
</p>
  <div class="newtheorem">
<!--l. 26--><p class="noindent" ><span class="head">
<a 
 id="x1-1001r1"></a>
<span 
class="cmbx-12">Theorem 1.1 </span>&#x0028;Hilbert Basis Theorem&#x0029;<span 
class="cmbx-12">.</span>  </span><span 
class="cmti-12">If</span> \(R\) <span 
class="cmti-12">is Noetherian, then</span> \(R[x]\) <span 
class="cmti-12">is too.</span>
</p>
  <div class="proof">
<!--l. 30--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span>Fix an ideal of \(R[x]\), \(I\). Let \(L_n\) be the ideal in \(R\) of leading coe&#xFB03;cients of terms with \(x^n\) as
the leading term in \(I\). \(L_n\) stabilizes as \(n \to \infty \) as \(R\) is Noetherian. Thus by choosing polynomials
whose leading terms generate \(L_n\) up till the point of stabilization we get a &#xFB01;nite set of
generators for \(I\). <span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
  </div>
<!--l. 35--><p class="indent" >  As a corollary, \(R[x_1,\dots ,x_n]\) is Noetherian &#x0028;induction&#x0029;, but note that this inductive argument
implicitly orders \(x_1\) to \(x_n\). The ideas of ordering and looking at leading terms generating an
ideal give rise to Gr&#x00F6;bner bases.
</p>
  <div class="newtheorem">
<!--l. 37--><p class="noindent" ><span class="head">
<a 
 id="x1-1002r2"></a>
<span 
class="cmbx-12">De&#xFB01;nition 1.2.</span>  </span><span 
class="cmti-12">A </span><span 
class="cmbxti-10x-x-120">monomial ordering </span><span 
class="cmti-12">is a well ordering on monomials satisfying</span>
\(a \leq b \implies ac \leq bc\) <span 
class="cmti-12">&#x0028;a,b,c are monomials in</span> \(R[x_1,...,x_n]\)<span 
class="cmti-12">&#x0029;.</span>
</p>
  </div>
<!--l. 41--><p class="indent" >  Here are three important examples: </p>
                                                                                  

                                                                                  
          <ul class="itemize1">
       <li class="itemize"><span 
class="cmbx-12">&#x0028;lex&#x0029; </span>We can lexicographically order monomials with \(x_1 &gt; \dots &gt; x_n\).
          </li>
       <li class="itemize"><span 
class="cmbx-12">&#x0028;grlex&#x0029; </span>We can &#x201D;grade&#x201D; the lexicographical ordering by ordering monomials
       by total degree, and if they are the same degree, then by lex.
          </li>
       <li class="itemize"><span 
class="cmbx-12">&#x0028;grevlex&#x0029; </span>We can &#xFB01;rst grade monomials by degree, and if they are the same
       degree, we can start from \(x_n\) going to \(x_1\), saying that \(m&gt;n\) if \(m\) has a lower exponent on
       \(x_n\).</li></ul>
<!--l. 47--><p class="noindent" >Note in all of these orderings we have \(x_1 &gt; \dots &gt; x_n\).
</p><!--l. 49--><p class="indent" >  As an example consider these three orderings of the same set of monomials:
</p>
          <ul class="itemize1">
       <li class="itemize">&#x0028;lex&#x0029; \(x^3y,x^3y^2,x^2y^2z,x^2yz^2,x^2z^2,x^2z,x^2,xy^2z\)
          </li>
       <li class="itemize">&#x0028;grlex&#x0029; \(x^3z^2,x^2y^2z,x^2yz^2,x^3y,x^2z^2,xy^2z,x^2z,x^2\)
          </li>
       <li class="itemize">&#x0028;grevlex&#x0029; \(x^2y^2z,x^3z^2,x^2yz^2,x^3y,xy^2z,x^2z^2,x^2z,x^2\)</li></ul>
  <h3 class="sectionHead"><span class="titlemark">2. </span> <a 
 id="x1-20002"></a>Division Algorithms and Gr&#x00F6;bner Bases</h3>
<!--l. 59--><p class="noindent" >Whenever we have a monomial ordering, we have a notion of leading coe&#xFB03;cient,
namely the highest nonzero term according to the ordering. Given an ideal \((f_1,\dots f_n)\),
we would like to run the following division algorithm: Take a polynomial \(g\), and
compare leading coe&#xFB03;cients with each \(f_i\). If the leading coe&#xFB03;cient of \(f_i\) divides one of \(g\)&#x2019;s
terms, subtract the corresponding multiple of \(f_i\) from \(g\). If you are not capable of
doing this with any of the \(f_i\), then set the leading term aside as a remainder, and
continue with the rest of the polynomial. As the monomial ordering is well-ordered,
this will stop eventually, ie. none of the leading terms of the \(f_i\) will divide any
of what is left of \(g\). We would like this process to yield a unique remainder for
any two members of the same coset of the ideal so we can do computations in
the quotient. Given arbitrary generators of an ideal, this may not always work
unfortunately.
</p><!--l. 61--><p class="indent" >  For example, consider \((x+y,x^2+xy+y^2)\) with the lexicographical order \(x&gt;y\). We can try to reduce the
polynomial \(x^2 + xy\) in two ways. First we can subtract \(x(x+y)\) from it to get \(0\), after which we
are done. Or we can subtract \(1(x^2+xy+y^2)\) from it to get \(-y^2\), after which we are done. Note
                                                                                  

                                                                                  
that we got di&#xFB00;erent remainders, which is not what we&#x2019;d like. To &#xFB01;x this, we
should choose a di&#xFB00;erent set of generators for the ideal that also generate the
ideal of leading coe&#xFB03;cients, for example \((y^2,x+y)\). If we were to run the algorithm on
this set of generators, we would get \(0\) both times. This is because \((y^2,x+y)\) is a Gr&#x00F6;bner
basis.
</p>
  <div class="newtheorem">
<!--l. 63--><p class="noindent" ><span class="head">
<a 
 id="x1-2001r1"></a>
<span 
class="cmbx-12">De&#xFB01;nition 2.1.</span>  </span><span 
class="cmti-12">If</span> \(f\) <span 
class="cmti-12">is a polynomial,</span> \(LT(f)\) <span 
class="cmti-12">denotes its leading term &#x0028;with the coe&#xFB03;cient&#x0029;.</span>
<span 
class="cmti-12">If</span> \(I\) <span 
class="cmti-12">is an ideal</span> \(LT(I)\) <span 
class="cmti-12">is the ideal of leading terms. A </span><span 
class="cmbxti-10x-x-120">Gr</span><span 
class="cmbxti-10x-x-120">&#x00F6;</span><span 
class="cmbxti-10x-x-120">bner basis</span> \(G\) <span 
class="cmti-12">of</span> \(I\) <span 
class="cmti-12">is a nonempty</span>
<span 
class="cmti-12">subset of</span> \(I\) <span 
class="cmti-12">whose leading terms generate</span> \(LT(I)\)<span 
class="cmti-12">.</span>
</p>
  </div>
  <div class="newtheorem">
<!--l. 67--><p class="noindent" ><span class="head">
<a 
 id="x1-2002r2"></a>
<span 
class="cmbx-12">Proposition 2.2.</span>  </span> <span 
class="cmti-12">If</span> \(G\) <span 
class="cmti-12">is a Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner basis of</span> \(I\)<span 
class="cmti-12">, then the division algorithm yields a</span>
<span 
class="cmti-12">unique representative for each coset of</span> \(R[x_1,\dots ,x_n]/I\)<span 
class="cmti-12">. In particular, it is</span> \(0\) <span 
class="cmti-12">i&#xFB00; the element is in the</span>
<span 
class="cmti-12">ideal, so</span> \(G\) <span 
class="cmti-12">generates</span> \(I\)<span 
class="cmti-12">.</span>
</p>
  <div class="proof">
<!--l. 71--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span>Suppose we have two remainders of elements from the same coset, \(r_1, r_2\) and we
subtract them. We&#x2019;ll get something in \(I\) but if it is nonzero, we can apply the algorithm
to it as \(G\) is a Gr&#x00F6;bner basis. But any term we remove must have come from either \(r_1\)
or \(r_2\), which is a contradiction, as it means the division algorithm was not yet complete
on \(r_1\) or \(r_2\). If \(r_1\) is in the ideal, it must be \(0\) or else the algorithm again is not complete. <span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
  </div>
                                                                                  

                                                                                  
<!--l. 75--><p class="indent" >  By Proposition <a 
href="#x1-2002r2">2.2<!--tex4ht:ref: coset --></a> and the proof of the Hilbert Basis Theorem &#x0028;except now we are
working with arbitrary monomial orderings&#x0029; we get that every ideal has a Gr&#x00F6;bner basis.
How can we actually compute it? The Buchberger Criterion gives a way to do this. From
now on, we will work over a &#xFB01;eld \(K\).
</p><!--l. 77--><p class="indent" >  To motivate this, consider the example before with \((x+y,x^2+xy+y^2)\). We can look at the leading terms, \(x\)
and \(x^2\), and take the LCM, \(x^2\). We can then add in the extra term \(x(x+y)-1(x^2+xy+y^2) = -y^2\). Adding this in to our list
of generators, we do get a Gr&#x00F6;bner basis. The Buchberger Criterion says this strategy will
always work.
</p><!--l. 79--><p class="indent" >  First we will set up some notation. Fix a set of generators of \(I\), \(G\). We say \(f \mapsto r\) to
mean that applying the algorithm to \(f\) with \(G\) yields \(r\) as the remainder. If \(f,g\) are
polynomials, then we let \(LCM = LCM(LT(f),LT(g))\) denote the monic that is the \(LCM\) of the leading terms of \(f\) and
\(g\). We de&#xFB01;ne \(S(f,g)\) = \(\frac{LCM}{LT(f)}f-\frac{LCM}{LT(g)}g\). We would like to say that any missing generators to make a
Gr&#x00F6;bner basis will be produced by repeatedly adding the \(S(f,g)\) until they are no longer
needed.
</p><!--l. 81--><p class="indent" >  Before we prove the Buchberger Criterion, a simple lemma:
</p>
  <div class="newtheorem">
<!--l. 83--><p class="noindent" ><span class="head">
<a 
 id="x1-2003r3"></a>
<span 
class="cmbx-12">Lemma 2.3.</span>  </span> <span 
class="cmti-12">Suppose that</span> \(f_1 \dots f_n\) <span 
class="cmti-12">are polynomials of the same leading monomial. Then if</span>
\(h = \sum _1^n s_if_i, s_i \in K\) <span 
class="cmti-12">has leading term smaller than the</span> \(f_i\)<span 
class="cmti-12">, then</span> \(h = \sum _1^{n-1}r_iS(f_i,f_{i+1}), r_i \in K\)<span 
class="cmti-12">.</span>
</p>
  <div class="proof">
<!--l. 86--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span>WLOG assume the \(f_i\) are monic. Note \(S(f_i,f_{i+1})\) is just \(f_i-f_{i+1}\). Then write \(\sum _1^n s_if_i\) as \(\sum _1^{n-1} \big (\sum _1^is_i\big )(f_i-f_{i+1}) + \big (\sum _1^ns_i\big )f_n\). Each of the
terms in the &#xFB01;rst sum has leading term smaller than the \(f_i\), so \(\big (\sum _1^ns_i\big )f_n = 0\), and we get that \(h = \sum _1^ns_if_i = \sum _1^{n-1}\big (\sum _1^is_i\big )S(f_i,f_{i+1})\). <span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
  </div>
  <div class="newtheorem">
<!--l. 90--><p class="noindent" ><span class="head">
<a 
 id="x1-2004r4"></a>
                                                                                  

                                                                                  
<span 
class="cmbx-12">Theorem 2.4 </span>&#x0028;Buchberger Criterion&#x0029;<span 
class="cmbx-12">.</span>  </span>\(G = \{f_1 \dots f_n\} \subset I\)  <span 
class="cmti-12">is  a  Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner  basis  i&#xFB00;  each</span>  \(S(f_i,f_j) \mapsto 0\)  <span 
class="cmti-12">and  if</span>  \(G\)
<span 
class="cmti-12">generates</span> \(I\)<span 
class="cmti-12">.</span>
</p>
  <div class="proof">
<!--l. 94--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span>The only if follows from Proposition <a 
href="#x1-2002r2">2.2<!--tex4ht:ref: coset --></a>. Now suppose each \(S(f_i,f_j) \mapsto 0\) and \(G\) generates
\(I\).  Take  any  \(f \in I\),  and  apply  the  division  algorithm  to  get  a  remainder  \(f'\).  Choose  a
representation \(f' = \sum _1^ng_if_i\) such that the maximal leading term of each summand is minimal,
say \(\alpha \). Suppose \(f' \neq 0\), so that \(\alpha &gt; LT(f)\). We will try to &#xFB01;nd a smaller representation using the fact
that \(S(f_i,f_j) \mapsto 0\).
</p><!--l. 96--><p class="indent" >  We have: \begin{align*} f' &amp;= \sum _1^ng_if_i\\ &amp;= \sum _{LT(g_if_i)=\alpha }LT(g_i)f_i + \sum _{LT(g_if_i)=\alpha }(g_i-LT(g_i))f_i + \sum _{LT(g_if_i)&lt;\alpha }g_if_i\\ &amp;= \sum s_iS(LT(g_i)f_i,LT(g_j)f_j) + \sum _{LT(g_if_i)=\alpha }(g_i-LT(g_i))f_i + \sum _{LT(g_if_i)&lt;\alpha }g_if_i \end{align*}
</p><!--l. 103--><p class="indent" >  The second two sums have all their terms smaller than \(\alpha \) so Lemma <a 
href="#x1-2003r3">2.3<!--tex4ht:ref: small --></a> applies to the
&#xFB01;rst sum, which is what has been done in the last step.
</p><!--l. 105--><p class="indent" >  However now we have a contradiction as \(S(LT(g_i)f_i,LT(g_j)f_j)\) is a monomial multiplied with \(S(f_i,f_j)\) so we have \(S(LT(g_i)f_i,LT(g_j)f_j) \mapsto 0\) so
it can be written as a linear combination of the \(f_i\) with degrees of each term at most
that of \(S(LT(g_i)f_i,LT(g_j)f_j)\), which in particular is smaller than \(\alpha \). This contradicts minimality of \(\alpha \).
<span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
  </div>
<!--l. 109--><p class="indent" >  Buchberger&#x2019;s Criterion allows us to produce Gr&#x00F6;bner bases. In particular, given a set of
generators \(\{f_1 \dots f_n\}\) we can compute the \(S(f_i,f_j)\), and reduce them. If they are all zero, we have a
Gr&#x00F6;bner basis, otherwise we add the remainder to the list and repeat until the criterion is
satis&#xFB01;ed. Now that we can &#xFB01;nd Gr&#x00F6;bner bases, we can compute in quotient rings, and
make nontrivial statements about the ideals that we are working with. In particular, this
gives an e&#xFB00;ective Nullstellensatz, as an ideal is trivial i&#xFB00; \(1\) is in a Gr&#x00F6;bner basis of
it.
</p>
  <h3 class="sectionHead"><span class="titlemark">3. </span> <a 
 id="x1-30003"></a>Reduced Gr&#x00F6;bner bases and Applications</h3>
<!--l. 113--><p class="noindent" >Let&#x2019;s work this out for \((x+y,x^2+xy+y^2)\), \(x&gt;y\) as before. We saw \(S(x+y,x^2+xy+y^2) = -y^2\) so we can add \(y^2\) to our list of generators. \(S(x+y,y^2) = y^2(x+y)-xy^2 = y^3 \mapsto 0\) and \(S(x^2+xy+y^2,y^2)=y^2(x^2+xy+y^2)-x^2y^2=xy^3+y^4 \mapsto 0\),
                                                                                  

                                                                                  
so we see \((x+y,x^2+xy+y^2,y^2)\) is a Gr&#x00F6;bner basis. Note however that the leading term of \(x^2+xy+y^2\) has the
leading term of \(x+y\) as a divisor. This means it can be removed by Proposition <a 
href="#x1-2002r2">2.2<!--tex4ht:ref: coset --></a>.
We are left with \((x+y,y^2)\). This is a minimal Gr&#x00F6;bner basis as no more terms can be
removed.
</p>
  <div class="newtheorem">
<!--l. 115--><p class="noindent" ><span class="head">
<a 
 id="x1-3001r1"></a>
<span 
class="cmbx-12">De&#xFB01;nition 3.1.</span>  </span><span 
class="cmti-12">A </span><span 
class="cmbxti-10x-x-120">minimal Gr</span><span 
class="cmbxti-10x-x-120">&#x00F6;</span><span 
class="cmbxti-10x-x-120">bner basis </span><span 
class="cmti-12">is one with a minimal number of</span>
<span 
class="cmti-12">elements.</span>
</p>
  </div>
  <div class="newtheorem">
<!--l. 119--><p class="noindent" ><span class="head">
<a 
 id="x1-3002r2"></a>
<span 
class="cmbx-12">Proposition 3.2.</span>  </span><span 
class="cmti-12">We can always get a minimal Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner basis from a Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner</span>
<span 
class="cmti-12">basis as above, by removing redundant terms. The leading coe&#xFB03;cients and number of</span>
<span 
class="cmti-12">terms of a minimal Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner basis for a &#xFB01;xed ideal</span> \(I\) <span 
class="cmti-12">is unique.</span>
</p>
  <div class="proof">
<!--l. 123--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span>This follows from the observation that for an ideal generated by monomials,
there is a unique minimal monic generating set of monomials. <span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
  </div>
<!--l. 127--><p class="indent" >  Note that minimal Gr&#x00F6;bner bases are not unique even though their size and leading
coe&#xFB03;cients are. For example, \((x+y,y^2)\) and \((x+y+y^2,y^2)\) are both Gr&#x00F6;bner bases of the same ideal. To get true
uniqueness we need a slightly stronger condition.
</p>
  <div class="newtheorem">
                                                                                  

                                                                                  
<!--l. 129--><p class="noindent" ><span class="head">
<a 
 id="x1-3003r3"></a>
<span 
class="cmbx-12">De&#xFB01;nition 3.3.</span>  </span><span 
class="cmti-12">A </span><span 
class="cmbxti-10x-x-120">reduced Gr</span><span 
class="cmbxti-10x-x-120">&#x00F6;</span><span 
class="cmbxti-10x-x-120">bner basis </span><span 
class="cmti-12">is one in which none of the leading</span>
<span 
class="cmti-12">terms of any element divide any of the terms of the others and the leading terms are</span>
<span 
class="cmti-12">monic.</span>
</p>
  </div>
<!--l. 133--><p class="indent" >  A reduced Gr&#x00F6;bner basis is in particular a minimal Gr&#x00F6;bner basis. For example, \((x+y,y^2)\) is an
example, and \((x+y+y^2,y^2)\) is a non-example. We can always make a Gr&#x00F6;bner basis reduced by
performing the division algorithm on a term with the rest of the terms until it is reduced.
For example, performing it on \((x+y+y^2,y^2)\), we get \(x+y+y^2-1(y^2)=x+y\) as the result for \(x+y\), and \(y^2\) stays as it is. In
particular we get back \((x+y,y^2)\). Here is the reason we introduced reduced Gr&#x00F6;bner
bases:
</p>
  <div class="newtheorem">
<!--l. 135--><p class="noindent" ><span class="head">
<a 
 id="x1-3004r4"></a>
<span 
class="cmbx-12">Proposition 3.4.</span>  </span><span 
class="cmti-12">Every ideal has a unique reduced Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner basis.</span>
</p>
  <div class="proof">
<!--l. 138--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span> By Proposition <a 
href="#x1-30003">3<!--tex4ht:ref: minunique --></a> we know the leading coe&#xFB03;cients and number of elements
are unique. So given two reduced Gr&#x00F6;bner bases \(\{f_1,\dots ,f_n\},\{g_1,\dots ,g_n\}\) we can subtract terms with the
same leading coe&#xFB03;cient and apply the division algorithm to see that we must get \(0\) or
else one of the Gr&#x00F6;bner bases isn&#x2019;t reduced. <span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
  </div>
<!--l. 143--><p class="indent" >  This yields a way to check if two ideals are equal, namely computing their reduced
Gr&#x00F6;bner bases. For example, the ideals \((xy^2+y^3+x+y,y^2)\) and \((x+y,x^2+xy+y^2)\) have the same reduced Gr&#x00F6;bner basis, \((x+y,y^2)\) so
are the same.
                                                                                  

                                                                                  
</p><!--l. 145--><p class="indent" >  We can also use Gr&#x00F6;bner bases to try to solve systems of polynomial equations,
similarly to the Gauss-Jordan elimination that is used to solve systems of linear equations.
This is the beginning of elimination theory, something developed by Emmy Noether and
her students. To do this, we must choose a lexicographical ordering, which will specify in
which order we eliminate variables. Then we have:
</p>
  <div class="newtheorem">
<!--l. 147--><p class="noindent" ><span class="head">
<a 
 id="x1-3005r5"></a>
<span 
class="cmbx-12">Proposition 3.5 </span>&#x0028;Elimination&#x0029;<span 
class="cmbx-12">.</span>  </span><span 
class="cmti-12">Suppose  our  ordering  is  &#x0028;lex&#x0029;</span>  \(x_1&gt;\dots &gt;x_n\)<span 
class="cmti-12">.  Then  if</span>  \(G\)  <span 
class="cmti-12">is  a</span>
<span 
class="cmti-12">Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner basis for</span> \(I\)<span 
class="cmti-12">, then</span> \(G \cap K[x_2,...,x_n]\) <span 
class="cmti-12">is a Gr</span><span 
class="cmti-12">&#x00F6;</span><span 
class="cmti-12">bner basis of</span> \(I \cap K[x_2,\dots ,x_n]\)<span 
class="cmti-12">.</span>
</p>
  </div>
  <div class="proof">
<!--l. 151--><p class="indent" >  <span class="head">
<span 
class="cmti-12">Proof.</span> </span>Consider using the division algorithm of \(G\) on \(f \in I \cap K[x_2,\dots ,x_n]\). As \(x_1 &gt; x_2\) we will never use any
elements of \(G\) with \(x_1\), but will still get to \(0\) as \(G\) is a Gr&#x00F6;bner basis. Then in the division
algorithm we must be using only elements of \(G \cap K[x_2,\dots ,x_n]\) so by Proposition <a 
href="#x1-2002r2">2.2<!--tex4ht:ref: coset --></a> we are done. <span class="qed"><span 
class="msam-10x-x-120">&#x25A1;</span></span>
</p>
  </div>
<!--l. 154--><p class="indent" >  This allows us to solve systems of equations when there are &#xFB01;nitely many
solutions. For example, consider the ellipse \(2x^2 + 2xy + y^2 - 2x - 2y\) and the circle \(x^2 + y^2- 1\). We can &#xFB01;nd their
points of intersection via elimination. In particular, we would like to &#xFB01;nd zeros
of the ideal \(2x^2 + 2xy + y^2 - 2x - 2y,x^2 + y^2- 1\). To do this, we compute its Gr&#x00F6;bner basis under the ordering \(x&gt;y\),
giving \((2x+y^2+5y^3 -2,5y^4 -4y^3)\). Then we eliminate \(x\) and solve \(5y^4-4y^3 = 0\), which gives \(y = 0,\frac{4}{5}\). We then substitute this in
for \(y\) to &#xFB01;nd the corresponding solutions in x, giving us \((1,0),(-\frac{3}{5},\frac{4}{5})\) as our two points of
intersection.
</p><!--l. 156--><p class="indent" >  Elimination can also be used to compute intersections of ideals &#x0028;sums and products
are easy&#x0029;. In order to do so, we introduce an auxiliary variable \(t\) and eliminate
it. In particular, \(I\cap J = K[x_1,\dots ,x_n]\cap (tI+(1-t)J)\), and we can compute the right hand side using elimination.
To see the equality above, note that something of the form \(tf+(1-t)g\) doesn&#x2019;t involve \(t\) i&#xFB00;
\(f=g\).
                                                                                  

                                                                                  
</p><!--l. 158--><p class="indent" >  Here is an example of computing \(I\cap J\) using elimination. Suppose we want to &#xFB01;nd \((y^2,xy,x^2) \cap (x)\). We
consider \((ty^2,txy,+tx^2,-tx+x)\) and &#xFB01;nd a Gr&#x00F6;bner basis with the ordering \(t&gt;x&gt;y\). We get \((tx-x,ty^2,x^2,xy)\) as our reduced Gr&#x00F6;bner
basis, so \((xy,y^2)\) is the intersection.
</p><!--l. 160--><p class="indent" >  Elimination has other computational applications as well. For example, one may want to
saturate an ideal \(I\) with respect to a polynomial \(f\). This can be done by considering the ideal
\(I + (1-tf)\) and eliminating \(t\). The reason this works is because by adding in \(1-tf\) we are sending \(I\) to the
ideal it corresponds to in the localization, and by eliminating \(t\) we are intersecting it with
our original ring, and by the correspondence of ideals for localization, this yields the
saturation.
</p><!--l. 162--><p class="indent" >  We can use this idea of localization to also tell if \(f \in \sqrt{I}\). In particular, \(f \in \sqrt{I}\) i&#xFB00; \(I+(1-tf) = (1)\) and this condition
can be computed by looking at the Gr&#x00F6;bner basis of \(I+(1-tf)\).
</p><!--l. 164--><p class="indent" >  Finally we can compute ideal quotients \((I:J)\) using elimination. First note that it su&#xFB03;ces to
consider \(J\) principle as \((I:(f_1,\dots ,f_n)) = \cap _1^n(I:(f_i))\). Then note that if \(G \subset I \cap (f_i)\) is a generating set of \(I\cap (f_i)\), then \(\frac{G}{f_i} :=\{\frac{g}{f_i}|g \in G\}\) generates \((I:(f_i))\). Thus we
can compute this using Gr&#x00F6;bner bases.
</p><!--l. 166--><p class="indent" >  Some &#xFB01;nal remarks: This is just the beginning of what Gr&#x00F6;bner bases are good for. For
example, they can compute radicals of general ideals, although this is more complicated
&#x0028;&#xFB01;rst reduce to 0-dimensional case, then treat perfect and non-perfect &#xFB01;elds separately&#x0029;.
They can also compute the primary decomposition of an ideal. The theory of
Gr&#x00F6;bner bases also extends to rings other than &#xFB01;nitely generated K-algebras, for
example there is an analogous theory for polynomial rings over principle ideal
rings.
</p>
   
</body> 
</html>
                                                                                  

                                                                                  
                                                                                  


