
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Analysis Theorems</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Analysis_h-autopage-122"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Analysis Theorems</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Set-Theory.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Set Theory</a>
</p>


<p>
<a href="node-Inequalities.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Inequalities</a>
</p>


<p>
<a href="node-Topology-R.html#autosec-35" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Topology of \(\mathbb {R}\)</a>
</p>


<p>
<a href="node-Derivatives.html#autosec-73" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Derivatives</a>
</p>


<p>
<a href="node-Series.html#autosec-101" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Series</a>
</p>


<p>
<a href="node-Endomorphisms.html#autosec-123" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Endomorphisms</a>
</p>


<p>
<a href="node-Bilinear-Maps.html#autosec-159" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bilinear Maps</a>
</p>


<p>
<a href="node-Inner-Product-Spaces.html#autosec-173" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Inner Product Spaces</a>
</p>


<p>
<a href="node-Geometry-Mappings.html#autosec-190" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Geometry of Mappings</a>
</p>


<p>
<a href="node-Integration.html#autosec-208" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Integration</a>
</p>


<p>
<a href="node-Line-Integrals.html#autosec-240" class="tocsection" >
<span class="sectionnumber">11</span>&#x2003;Line Integrals</a>
</p>


<p>
<a href="node-Exterior-Algebras-Differential-Forms.html#autosec-255" class="tocsection" >
<span class="sectionnumber">12</span>&#x2003;Exterior Algebras and Differential Forms</a>
</p>


<p>
<a href="node-Integrals-Differential-Forms.html#autosec-273" class="tocsection" >
<span class="sectionnumber">13</span>&#x2003;Integrals of Differential Forms</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Analysis Theorems</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-123"><span class="sectionnumber">6&#x2003;</span>Endomorphisms</h4>
<a id="Analysis_h-autopage-123"></a>
<a id="Analysis_h-autofile-6"></a>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-124"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.1</span></span><span class="amsthmnoteplain"> (Adjugates)</span>. <a id="adjugates"></a> Let
\(M\) be a free \(R\)-module. Given \(f \in \End _R(M)\), there is an element \(\adj (f)\) such that \(f\adj (f) = \adj (f)f=1_M\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-125"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It suffices to prove this in the universal ring \(R=\ZZ [x_{ij}]\), \(1\leq i,j\leq n\), with an endomorphism \(f\) given by the matrix \((x_{ij})\). We have a natural
isomorphism \(j:M \cong \Hom (\wedge ^{n-1}M,\wedge ^{n}M)\) so that \(j(x_1)(x_2\wedge \dots \wedge x_n) = x_1\wedge \dots \wedge x_n\). To get \(\adj f\), take the endomorphism corresponding to \(\Hom
(\wedge ^{n-1}f,1_{\wedge ^{n}M})\). Now we have \(j(\adj (f)f)\) takes \(x_2\wedge \dots \wedge x_n \mapsto f(x_2)\wedge \dots \wedge f(x_n) \mapsto f(x_1)\wedge \dots \wedge f(x_n)\) which is
\(j(det(f)1_M)\). Note that since \(\det (f)\) is nonzero, \(\adj (f)\) has nonzero determinant, so is injective as \(R\) is an integral domain. Now we have \(\adj (f)f\adj (f)=\adj (f)\det (f)\) so by injectivity
\(f\adj (f) = \det (f)1_M\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-126"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.2</span></span>. <a id="polysub"></a> If \(Av = \lambda v\) then for any polynomial \(p\), \(p(A)v =
p(\lambda )v\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-127"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(p(A)v=p(\lambda )v\) is a linear combination of \(A^nv=\lambda ^nv\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-128"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6.3</span></span><span class="amsthmnoteplain"> (Cayley-Hamilton)</span>. <a
id="cayleyhamilton"></a> Let \(M\) be a finitely generated free \(R\)-module, and \(f \in \End (M)\). Then \(\chi _f(f)\equiv 0\)
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-129"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(f\) turns \(M\) into a \(R[T]\)-module, and we can extend scalars via \(R&apos; = R[x]\otimes _R R[T]\) and \(M&apos; = R[x]\otimes _R M\). Then \(\chi _f(x)\) is
the determinant of \(y = x\otimes 1_M - 1\otimes T \in R&apos;\). \(\adj (y)\) commutes with \(y\) by Lemma <a href="node-Endomorphisms.html#adjugates">6.1</a>, and since \(x\otimes 1_M\) is central it
commutes with \(1\otimes T\) as well, but then it commutes with all of \(R&apos;\). Now we look at \(R&apos;/(y),M&apos;/(y)M&apos;\) which substitutes \(x\) as \(T\), and note that \(\adj (y)\) has a well-defined
action on the quotient as it commutes with \(R&apos;\). \(M&apos;/(y)M&apos;\cong 1\otimes M\) since \(g(x)\otimes m = (g(x)\otimes 1)(1\otimes m) = (1 \otimes g(T))(1\otimes m) = 1 \otimes g(T)m\). Then
since \(y\) annihilates \(M&apos;/(y)M&apos;\), \(y\adj (y)\) does as well, but this is multiplication by \(\chi _f(x)\otimes 1=1\otimes \chi _f(T)\), which is the action of \(\chi _f(f)\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-130"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.4</span></span><span class="amsthmnoteplain"> (Determinant Trick)</span>. <a
id="dettrick"></a> If \(f\) is an endomorphism of \(M\), an \(R\)-module generated by \(n\) elements, and \(fM\subset IM\), \(f\) satisfies \(f^n+a_{1}f^{n-1}+\dots +a_n \equiv 0\) where \(a_i \in I^i\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-131"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By projectivity of free modules, it suffices to consider a free module, but then this follows from Theorem <a href="node-Endomorphisms.html#cayleyhamilton">6.3</a> by
noting that the coefficients of \(\chi _f(x)\) are of the form described. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-132"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.5</span></span><span class="amsthmnoteplain"> (Nakayama’s Lemma)</span>. <a id="nak1"></a> If
\(M\) is a finitely generated \(R\)-module and \(IM=M\), then there is an \(a\equiv 1\pmod {I}\) such that \(aM = 0\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-133"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Apply Corollary <a href="node-Endomorphisms.html#dettrick">6.4</a> to the identity map \(1_M\) and use the fact that \(1_MM\subset IM\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-134"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.6</span></span><span class="amsthmnoteplain"> (Nakayama’s Lemma)</span>. <a id="nak2"></a> If
\(M\) is a finitely generated module over a local ring \(R\) with maximal ideal \(m\) and \(mM=M\), then \(M=0\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-135"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By Corollary <a href="node-Endomorphisms.html#nak1">6.5</a> \(aM=0\) for \(a\equiv 1\pmod {m}\) but then \(aM=M\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-136"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.7</span></span><span class="amsthmnoteplain"> (Nakayama’s Lemma)</span>. <a id="nak3"></a> If
\(M\) is a finitely generated module over a local ring \(R\) with maximal ideal \(m\) and \(R\) and \(M = N+mM\) then \(M=N\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-137"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Apply Corollary <a href="node-Endomorphisms.html#nak2">6.6</a> to \(M/N\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-138"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.8</span></span><span class="amsthmnoteplain"> (Nakayama’s Lemma)</span>. <a id="nak4"></a> If
\(M\) is a finitely generated module over a local ring \(R\) with maximal ideal \(m\) and the image of \(m_1,\dots ,m_n\) generate \(M/mM\), then \(m_1,\dots ,m_n\) generate \(M\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-139"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Apply Corollary <a href="node-Endomorphisms.html#nak3">6.7</a> with \(N = \sum _1^nm_iM\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Note if the ring is not local, we can replace \(m\) by the Jacobson radical and Nakayama’s Lemma still holds.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-140"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">6.9</span></span>. Every endomorphism \(f:V\to V\) on a finite dimensional vector space \(V\) over
\(F\) has a minimal polynomial \(\mu _f\), satisfying \(\mu _f(f)=0\), \(g(f)=0 \implies \mu _f|g\), and its roots are the eigenvalues.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-141"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Viewing \(V\) as a \(F[T]\) module, since \(F[T]\) is a PID, everything is immediate except the last part, which follows since \(f(v)=\lambda v\) so by Lemma <a
href="node-Endomorphisms.html#polysub">6.2</a> \(\mu _f(f)(v)=\mu _f(\lambda )v\) but the LHS is \(0\) and \(v\) is not so we are done. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-142"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">6.10</span></span>. <a id="fgfreePID"></a> Submodules \(M\) of \(R^n\), a finite generated free module
over a PID are after a change of basis of the form \(\bigoplus _1^n x_ir_iR\) with \(x_i|x_{i+1} \in R\) and \(\bigoplus _1^n r_iR = R^n\) (the \(r_i\) are the change of basis). This representation is unique up to units
and the \(x_i\) are called the <b>invariant factors</b>.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-143"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Choose a map \(f_1:R^n\to R\) where the image of \(M\) is maximized (this uses PID). Let \(y_1\) be an element sent to a generator of the image, \(x_1\), which WLOG is
nonzero. Now if \(\pi _i\) is the \(i^{th}\) projection, then \(x_1|\pi _i(y_1)\) for all \(x \in R^n\) by maximality of \(f_1\), so we can let \(r_1 = \frac {y_1}{x_1}\). Now \(r_1\) gets sent to \(1\) by \(f\), so we
can project orthogonal to \(r_1\) via a section \(s_1:R \to R^n\) taking \(1 \mapsto r_1\). Our projection \(o_1(x) = x-s_1\circ f_1(x)\). This section gives \(R^n = r_1R\oplus o_1(R)\). The projection to \(o_1(R)\)
is surjective, and by removing an appropriate generator and localizing at \((0)\), we see that our new module must be free of rank \(n-1\). Now we apply induction to get \(y_2,\dots ,y_n\) and \(r_2,\dots ,r_n\), and by
looking at \(f_1\) we get \(x_1|x_2\). Uniqueness also follows from induction. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-144"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.11</span></span><span class="amsthmnoteplain"> (Smith Canonical Form)</span>. <a
id="smithcanform"></a> A map \(f:M \to N\) between finitely generated free modules over a PID of ranks \(n\) and \(m\) has a Smith Canonical Form, ie. is represented by a matrix of the form
</p>

<p>
\[\begin {pmatrix} x_1 &amp; &amp;\\ &amp; \ddots &amp; \\ &amp; &amp; x_{\min {(n,m)}} \end {pmatrix}\]
</p>

<p>
with \(x_i|x_{i+1}\). This representation is unique up to units.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-145"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The image is a submodule of \(R^m\) so this is a reformulation of Proposition <a href="node-Endomorphisms.html#fgfreePID">6.10</a>. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-146"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.12</span></span><span class="amsthmnoteplain"> (Finitely Generated Modules over PIDs)</span>. <a
id="fgmodPID"></a> A finitely generated module over a PID is of the form \(R^m \oplus \bigoplus _1^nR/(d_i)\) where \(d_i|d_{i+1}\). Moreover \(m\) is unique, and the \(d_i\) are unique up to units.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-147"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> A finitely generated module over a PID is a quotient of a finite rank free module, which has the correct form according to Proposition <a
href="node-Endomorphisms.html#fgfreePID">6.10</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-148"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.13</span></span><span class="amsthmnoteplain"> (Rational Canonical Form)</span>. <a
id="ratcanform"></a> Every endomorphism \(f:V\to V\) of a finite dimensional vector space over \(F\) has a unique Rational Canonical Form, ie. is represented by a matrix of the form
</p>

<p>
\[\bigoplus _{i=1}^n\begin {pmatrix} 0&amp;0&amp;0&amp;\dots &amp;-a_0\\ 1&amp;0&amp;0&amp;\dots &amp;-a_1\\ 0&amp;1&amp;0&amp;\dots &amp;-a_2\\ \vdots &amp;\vdots &amp;\vdots &amp;\ddots
&amp;\vdots \\ 0&amp;0&amp;0&amp;\dots &amp;-a_{k_i-1} \end {pmatrix} \]
</p>

<p>
where the monic polynomials (invariant factors) \(f_i(x)=\sum _1^{k_i}a_ix^i\) satisfy \(f_i|f_{i+1}\). \(f_n\) is \(\mu _f(x)\) and \(\prod _if_i\) is \(\chi _f(x)\)
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-149"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> View \(V\) as a module over \(F[T]\), and we get \(V \cong \sum _1^nF[T]/(f_i)\) from Corollary <a href="node-Endomorphisms.html#fgmodPID">6.12</a>. Then we are
done by picking \(1,T,\dots ,T^{k_i-1}\) as a basis. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-150"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.14</span></span>. If \(A\) a matrix over \(F\), the invariant factors can be computed by finding the Smith
Canonical Form of \(xI-A\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-151"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> If \(V\) is dimension \(n\) we can consider the \(F[T]\) module homomorphism \(F[T]^n \to V\) mapping the generators \(r_i\) surjectively onto an \(F\)-basis \(v_i\) of
\(V\). Now the elements \(y_i=Tr_j-\sum _1^i(a_{ij}r_i)\) are in the kernel but note that \(\sum _iy_iF[T] + \sum _ir_iF = \sum _ir_iF[T] = F[T]^n\), so \(y_i\) actually generate the kernel. The \(y_i\) have the
relations matrix \(xI-A^{t}\), so by Corollary <a href="node-Endomorphisms.html#smithcanform">6.11</a> after a change of basis it is in Smith Normal Form with invariant factors \(f_1,\dots ,f_n\), so the kernel is of this
form for an appropriate set of generators, and \(V \cong \bigoplus _1^nF[T]/(f_n)\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Note that Corollary <a href="node-Endomorphisms.html#fgmodPID">6.12</a> also can be represented as \(R^m \oplus \bigoplus R/(p^i)\) where \(p\) varies over primes, and similarly Corollary <a
href="node-Endomorphisms.html#ratcanform">6.13</a> has a representation in this way.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-152"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.15</span></span><span class="amsthmnoteplain"> (Jordan Canonical Form)</span>. <a
id="jordcanform"></a> Every endomorphism \(f:V\to V\) of a finite dimensional vector space over \(F\) has a unique Jordan Canonical Form after extending scalars to an algebraic closure, ie. is represented by a matrix of the
form
</p>

<p>
\[\bigoplus _{i=1}^n \begin {pmatrix} \lambda _i&amp;1&amp;0&amp;\dots &amp;0\\ 0&amp;\lambda _i&amp;1&amp;\dots &amp;0\\ 0&amp;0&amp;\lambda _i&amp;\dots &amp;0\\ \vdots &amp;\vdots
&amp;\vdots &amp;\ddots &amp;\vdots \\ 0&amp;0&amp;0&amp;\dots &amp;\lambda _i \end {pmatrix} \]
</p>

<p>
Each summand is called a <b>Jordan block</b>.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-153"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> As an \(F[T]\)-module, decompose \(V \cong \bigoplus _{i=1}^n F[T]/(T-\lambda _i)^j_i\), and choose as a basis for each summand \(1,T-\lambda _i,\dots
,(T-\lambda _i)^{j_i-1}\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-154"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.16</span></span><span class="amsthmnoteplain"> (Diagonalization Theorem)</span>. A matrix is
diagonalizable iff its Jordan Canonical Form is diagonal iff its minimal polynomial is separable.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-155"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By uniqueness of the Jordan Canonical Form the first statement is true, and since the minimal polynomial is the LCM of the minimal polynomials of the Jordan blocks, so it must
have distinct roots. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-156"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">6.17</span></span>. Commuting diagonalizable endomorphisms \(A,B\) are simultaneously diagonalizable.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-157"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> If \(v\) has eigenvalue \(\lambda \) for \(A\), then \(BAv = ABv = \lambda Av\), so \(B\)’s \(\lambda \)-eigenspace is \(A\)-invariant, so we can simultaneously diagonalize.
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
