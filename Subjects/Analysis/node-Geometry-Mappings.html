
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Analysis Theorems</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Analysis_h-autopage-189"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Analysis Theorems</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Set-Theory.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Set Theory</a>
</p>


<p>
<a href="node-Inequalities.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Inequalities</a>
</p>


<p>
<a href="node-Topology-R.html#autosec-35" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Topology of \(\mathbb {R}\)</a>
</p>


<p>
<a href="node-Derivatives.html#autosec-73" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Derivatives</a>
</p>


<p>
<a href="node-Series.html#autosec-101" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Series</a>
</p>


<p>
<a href="node-Endomorphisms.html#autosec-123" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Endomorphisms</a>
</p>


<p>
<a href="node-Bilinear-Maps.html#autosec-159" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bilinear Maps</a>
</p>


<p>
<a href="node-Inner-Product-Spaces.html#autosec-173" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Inner Product Spaces</a>
</p>


<p>
<a href="node-Geometry-Mappings.html#autosec-190" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Geometry of Mappings</a>
</p>


<p>
<a href="node-Integration.html#autosec-208" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Integration</a>
</p>


<p>
<a href="node-Line-Integrals.html#autosec-240" class="tocsection" >
<span class="sectionnumber">11</span>&#x2003;Line Integrals</a>
</p>


<p>
<a href="node-Exterior-Algebras-Differential-Forms.html#autosec-255" class="tocsection" >
<span class="sectionnumber">12</span>&#x2003;Exterior Algebras and Differential Forms</a>
</p>


<p>
<a href="node-Integrals-Differential-Forms.html#autosec-273" class="tocsection" >
<span class="sectionnumber">13</span>&#x2003;Integrals of Differential Forms</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Analysis Theorems</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-190"><span class="sectionnumber">9&#x2003;</span>Geometry of Mappings</h4>
<a id="Analysis_h-autopage-190"></a>
<a id="Analysis_h-autofile-9"></a>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-191"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9.1</span></span><span class="amsthmnoteplain"> (Inverse Mapping Theorem)</span>. <a
id="invmapping"></a> If \(f:\FF ^n\to \FF ^n\) is \(\cC ^1\) near a point \(a\) and \(f&apos;(a)\) is invertible near the origin, then \(f\) is a \(\cC ^1\) diffeomorphism near \(a\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-192"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG, \(a=f(a) = 0, f&apos;(a) = I\) via an affine transformation. Now as \(r(x) = f(x)-x\) is \(\cC ^1\) near the origin and \(r&apos;(0) = 0\), we have \(\Vert
r&apos;(x) \Vert _o\leq 1/2\) near the origin. Then by Corollary <a href="node-Derivatives.html#mvineq">4.7</a> we have \(\Vert r(b)-r(a)\Vert _2\leq \frac {1}{2}\Vert b-a\Vert _2\) near the origin which
gives
</p>

<p>
\[\Vert f(b)-f(a)\Vert = \Vert f(b)-f(a)\Vert +\frac {1}{2}\Vert b-a\Vert -\frac {1} 2 \Vert b-a\Vert \]
</p>

<p>
\[ \geq \Vert f(b)-f(a)\Vert + \Vert r(b)-r(a)\Vert -\frac {1}{2} \Vert b-a\Vert \geq \frac {1}{2}\Vert b-a\Vert \]
</p>

<p>
Hence the map is injective, and by Theorem <a href="node-Topology-R.html#invardomain">3.13</a>, this is a local homeomorphism near the origin. Now let \(g\) be the local inverse of \(f\) near \(0\), we would like to show
\(g\) is differentiable at \(0\). If \(f(x)=y\) and \(f(x+h) = y+k\), then as \(f\) is differentiable,
</p>

<p>
\[ f(x+h) - f(x) = f&apos;(x)h + \ee _f(h) \implies k = f&apos;(x)(g(y+k)-g(y)) + \ee _f(h) \]
</p>

<p>
\[\implies g(y+k)-g(y) = f&apos;(x)^{-1}k-f&apos;(x)^{-1}\ee _f(h)\]
</p>

<p>
and as \(\Vert f&apos;(x)^{-1}\Vert _o\) is bounded near \(0\), it suffices to show \(\frac {\Vert \ee _f(h)\Vert }{\Vert k\Vert } \to 0\) as \(k \to 0\).
</p>

<p>
Indeed, we have
</p>

<p>
\[\frac {\Vert \ee _f(h)\Vert }{\Vert k\Vert }=\frac {\Vert \ee _f(h)\Vert }{\Vert h\Vert }\frac {\Vert h\Vert }{\Vert k \Vert } = \frac {\Vert \ee _f(h)\Vert }{\Vert h\Vert }\frac {\Vert
h\Vert }{\Vert f(x+h)-f(x) \Vert }\leq 2\frac {\Vert \ee _f(h)\Vert }{\Vert h\Vert }\frac {\Vert h\Vert }{\Vert h \Vert } \]
</p>

<p>
which goes to \(0\) as \(k \to 0\). Thus \(g\) is differentiable and since its derivative is the inverse of \(f&apos;\), \(g\) is \(\cC ^1\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-193"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9.2</span></span><span class="amsthmnoteplain"> (Decomposition Theorem)</span>. <a
id="c1decomp"></a> If a map \(f:\RR ^n \to \RR ^n\) is \(\cC ^1\) near a point \(a\) and \(\det (f&apos;(a)) \neq 0\), then near \(a\), \(f\) is the composite of \(\cC ^1\) diffeomorphisms \(\phi _i\) that only
change one variable.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-194"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG, \(a = f(a) = 0\). We say that \(f\) is of type \(r\) if \(f\) doesn’t change at least \(r-1\) coordinates. By induction it suffices to show that if \(f\) is type \(r\), then
there is a \(\cC ^1\) diffeomorphism \(\phi \) so that \(f \circ \phi \) is type \(r+1\), so we assume \(f\) fixes the first \(r-1\) coordinates, denoting these \(x_I\), and denoting the last \(n-r\) coordinates \(x_{II}\).
Then after some relabeling \(f&apos;\) looks like
</p>

<p>
\[\begin {pmatrix} I_{r-1}&amp;0&amp;0\\ \partial _If_r&amp;\partial _rf_r&amp;\partial _{II}f_r\\ \partial _If_{II}&amp;\partial _rf_{II}&amp;\partial _{II}f_{II} \end {pmatrix}\]
</p>

<p>
Since \(f&apos;(x)\) is invertible near 0, we can assume \(\partial _rf_r \neq 0\) near by relabeling the \(f_i\). Then we can define \(\psi \) near \(0\) as the function that is \(f_r\) on the \(x_r\) coordinate and the
identity on all other coordinates. Its derivative looks like
</p>

<p>
\[\begin {pmatrix} I_{r-1}&amp;0&amp;0\\ \partial _If_r&amp;\partial _rf_r&amp;\partial _{II}f_r\\ 0&amp;0&amp;I_{n-r} \end {pmatrix}\]
</p>

<p>
so is invertible and by Theorem <a href="node-Geometry-Mappings.html#invmapping">9.1</a> has a local inverse \(\phi \), which is what we want. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Note that the \(m =n\) case of the next theorem is the Inverse Mapping Theorem.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-195"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9.3</span></span>. <a id="rankthmn"></a> If \(f:\RR ^m\to \RR ^n, m\geq n\) is \(\cC ^1\) near a
point \(a\) with \(f&apos;(a)\) rank \(n\), then there is a \(\cC ^1\) diffeomorphism \(\phi :\RR ^m \to \RR ^m\) near \(a\) so that \(f\circ \phi -f(a)\) is a linear map near \(a\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-196"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG, \(a = 0, f(a) = 0\). We label the first \(n\) coordinates of \(\RR ^m\) \(x_I\) and the last \(n-m\) \(x_{II}\). Then \(f&apos;\) looks like
</p>

<p>
\[\begin {pmatrix} \partial _If_I&amp;\partial _{II}f_I \end {pmatrix}\]
</p>

<p>
and we define \(\psi :\RR ^m\to \RR ^m\) near \(0\) as \(f_I\) on the first \(n\) coordinates and \(x_{II}\) on the rest. Its derivative looks like
</p>

<p>
\[\begin {pmatrix} \partial _If_I&amp;\partial _{II}f_I\\ 0&amp;I_{m-n} \end {pmatrix}\]
</p>

<p>
so by possibly reordering coordinates we can assume it is invertible and we can use Theorem <a href="node-Geometry-Mappings.html#invmapping">9.1</a> to locally make an inverse \(\phi :\RR ^m\to \RR ^m\) that fixes the
coordinates \(x_{II}\). Now we have
</p>

<p>
\[\begin {pmatrix}x_I \\ x_{II}\end {pmatrix} = (\psi \circ \phi )\begin {pmatrix}x_I\\x_{II}\end {pmatrix} = \begin {pmatrix} (f\circ \phi )(x)\\ x_{II}\end {pmatrix}\]
</p>

<p>
so indeed \(f\circ \phi \) is locally linear. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-197"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9.4</span></span><span class="amsthmnoteplain"> (Implicit Function Theorem)</span>. <a
id="impfnthm"></a> If \(f:\RR ^m\to \RR ^n,m&gt;n\) is \(\cC ^1\) near \(0\) and \(\det (\partial _{I}f(0))\neq 0\), then for a small cell \(I^m = I_I\times I_{II}\) near \(0\), there is a \(\cC ^1\) function
\(h:I_{II}\to I_{I}\) so that \(f(x_I,x_{II}) = f(0)\) iff \(x_I = h(x_{II})\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-198"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By Theorem <a href="node-Geometry-Mappings.html#rankthmn">9.3</a> we locally have a \(\cC ^1\) map \(\phi :\RR ^m\to \RR ^n\) that is a function \(g\) on the first
\(n\) coordinates and the identity on the last \(m-n\) coordinates such that \(f\circ \phi \) is the linear map \((x_I,x_{II})\mapsto (x_I)\). Then we define \(h(x_{II}) = g(0,x_{II})\). Now locally \(f(x) = 0\) iff \(x
= \phi (y)\) and \((f\circ \phi )(y)=0\) iff \(x = \phi (0,y_{II})\) iff \(x_I = h(y_{II})=h(x_{II})\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-199"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">9.5</span></span>. <a id="submanchar"></a> Locally a \(\cC ^1\) \(k\)-submanifold of \(\RR ^n\) is
given by implicit \(\cC ^1\) functions in \(k\) variables.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-200"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> If \(V\) is such a submanifold, after a local change of coordinates at a point \(a\), it is a linear subspace of \(\RR ^n\). We can collapse this subspace, which is \(\cC ^1\) and by
Theorem <a href="node-Geometry-Mappings.html#impfnthm">9.4</a> the kernel composite of this with the local change of coordinates is given by implicit functions in \(k\) variables. Conversely if \(V\) is given locally by
implicit functions in \(k\) variables, those implicit functions are a \(\cC ^1\) diffeomorphism to a linear embedding of \(\RR ^k\) in \(\RR ^n\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Note that the \(n=m=r\) case of the Rank Theorem below is the Inverse Mapping Theorem.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-201"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9.6</span></span><span class="amsthmnoteplain"> (Rank Theorem)</span>. <a id="rankthm"></a> If
\(f:\RR ^m \to \RR ^n\) is \(\cC ^1\) near \(a\) and \(f&apos;(x)\) is rank \(r\) near \(a\), then there are \(\cC ^1\) maps \(\phi :\RR ^m\to \RR ^m\) defined near \(a\) and \(\theta :\RR ^n\to \RR ^n\) defined
near \(f(a)\) such that \(\theta \circ f\circ \phi \) is a linear map of rank \(r\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-202"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG, \(a =0,f(a) =0\). By relabeling coordinates in the domain and range, we may assume that the principle \(r\times r\) submatrix of \(f&apos;(0)\) is invertible. Let
us label the first \(r\) coordinates of \(\RR ^m\) \(x_I\) and the last \(m-r\) \(x_{II}\). Then we can consider the map \(\psi :\RR ^m \to \RR ^m\) that is \(f\) on \(x_I\), and the identity on \(x_{II}\). By hypothesis,
\(\psi &apos;(0)\) is invertible, so by the Inverse Mapping Theorem we can let \(\phi \) be its local inverse, which is \(g\) on \(x_I\) and the identity on \(x_{II}\). Now we can call the first \(r\) coordinates of \(\RR ^n\)
\(y_I\) and the last \(n-r\) \(y_{II}\). Now \(h = f \circ \phi \) is the map that is \(x_I\) on the first \(r\) coordinates, and \(h_{II}\) on the last \(n-r\). \(h&apos;\) looks like
</p>

<p>
\[\begin {pmatrix} I_r&amp;0\\\partial _Ih_{II}&amp;\partial _{II}h_{II} \end {pmatrix}\]
</p>

<p>
but since it is rank \(r\) near \(a\) by the chain rule, we must have \(\partial _{II}h_{II} = 0\), so \(h\) only depends on \(x_I\). Now we can define \(\theta :\RR ^n\to \RR ^n\) near \(0\) as the identity on the first
\(r\) coordinates, and \(y_{II} - h_{II}(y_I)\) on the last \(n-r\). Then \(\theta &apos;(0)\) is rank \(n\), and \(\theta \circ h\) is \(x_I\) on the first \(r\) coordinates and \(0\) on the last \(n-r\), which is linear.
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-203"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">9.7</span></span>. <a id="ranksubmanifold"></a> If \(f:\RR ^m\to \RR ^n\) is \(\cC ^1\) near a point
\(a\), and \(f&apos;(x)\) is rank \(r\) near \(a\), then the image of a small neighborhood around \(a\) is a \(\cC ^1\) \(r\)-submanifold of \(\RR ^n\), and the preimage of \(f(a)\) is a \(\cC ^1\) \(m-r\)-submanifold if
\(f\) is restricted close enough to \(a\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-204"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Use Theorem <a href="node-Geometry-Mappings.html#rankthm">9.6</a> to obtain \(\phi \) and \(\theta \). Now after applying these \(\cC ^1\) diffeomorphisms, the
preimage of \(f(a)\) is the kernel of a linear map, so is an open subset of \(\RR ^{m-r}\). Similarly, the image of a neighborhood of \(a\) is an open subset of \(\RR ^r\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-205"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">9.8</span></span><span class="amsthmnoteplain"> (Lagrange Multipliers)</span>. If \(g:\RR ^n\to \RR
\) is \(\cC ^1\) in an open set \(U\), where \(\cC ^1\) \(r\)-submanifold \(V\) that is the locus of \(f_i,1 \leq n-r\) in \(U\), any extremum \(c\) of \(g\) in \(V\) must satisfy \(\nabla g(c) = \sum _1^{n-r}\lambda
_i\nabla f_i(c)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-206"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Note that for any parameterized curve \(\phi \) on \(V\) that sends \(0\) to \(c\), we have \(f_i(\phi (c))=0\), so by the chain rule, \(\nabla f_i(c)\cdot \phi &apos;(0)
= 0\), so the tangent space is exactly the space perpendicular to the \(\nabla f_i\). Now in order to have an extremum of \(g\) at \(c\) on \(V\), we need \(g&apos;(c) = 0\), but then for any parameterized curve \(\phi \)
on \(V\) sending \(0\) to \(x\), again we have \(g(\phi (c)) = 0\), so by the chain rule, \(\nabla g(c)\) lies in the tangent space, so is a linear combination of the \(\nabla f_i(c)\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
