
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Analysis Theorems</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Analysis_h-autopage-272"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Analysis Theorems</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Set-Theory.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Set Theory</a>
</p>


<p>
<a href="node-Inequalities.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Inequalities</a>
</p>


<p>
<a href="node-Topology-R.html#autosec-35" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Topology of \(\mathbb {R}\)</a>
</p>


<p>
<a href="node-Derivatives.html#autosec-73" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Derivatives</a>
</p>


<p>
<a href="node-Series.html#autosec-101" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Series</a>
</p>


<p>
<a href="node-Endomorphisms.html#autosec-123" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Endomorphisms</a>
</p>


<p>
<a href="node-Bilinear-Maps.html#autosec-159" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bilinear Maps</a>
</p>


<p>
<a href="node-Inner-Product-Spaces.html#autosec-173" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Inner Product Spaces</a>
</p>


<p>
<a href="node-Geometry-Mappings.html#autosec-190" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Geometry of Mappings</a>
</p>


<p>
<a href="node-Integration.html#autosec-208" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Integration</a>
</p>


<p>
<a href="node-Line-Integrals.html#autosec-240" class="tocsection" >
<span class="sectionnumber">11</span>&#x2003;Line Integrals</a>
</p>


<p>
<a href="node-Exterior-Algebras-Differential-Forms.html#autosec-255" class="tocsection" >
<span class="sectionnumber">12</span>&#x2003;Exterior Algebras and Differential Forms</a>
</p>


<p>
<a href="node-Integrals-Differential-Forms.html#autosec-273" class="tocsection" >
<span class="sectionnumber">13</span>&#x2003;Integrals of Differential Forms</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Analysis Theorems</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-273"><span class="sectionnumber">13&#x2003;</span>Integrals of Differential Forms</h4>
<a id="Analysis_h-autopage-273"></a>
<a id="Analysis_h-autofile-13"></a>

<p>
If we have an orientation \(y_1\dots y_n\) on \(\RR ^n\), we define \(\int _Efdy_1\wedge \dots \wedge dy_n = \int _Ef\) for \(E\subset \RR ^n\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-274"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">13.1</span></span>. <a id="pullbackintegral"></a> If \(\phi :D\to E\) is a \(\cC ^1\) diffeomorphism
between two subsets of \(\RR ^n\), and \(\omega \) is a continuous differential \(n\)-form, then \(\int _E\omega = \ee \int _D\phi ^*(\omega )\) where \(\ee \) is the sign of the determinant of \(\phi &apos;\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-275"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> If \(x_1\dots x_n\) is the orientation for \(D\), \(y_1\dots y_n\) is the orientation for \(E\), and \(\omega = fdy_I\) we have \(\int _D\phi ^*(\omega ) = \int _D(f\circ
\phi )\det (\phi &apos;)dx_I = \int _D(f\circ \phi )\det (\phi &apos;) = \ee \int _Ef = \ee \int _E\omega \) by the change of variables formula. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
A singular \(n\) cell in \(\RR ^m\) is a map from an oriented cell \(\Delta _n\) to \(\RR ^m\). We will mostly consider \(\cC ^\infty \) singular \(n\) cells. Two \(\cC ^\infty \) singular \(n\) cells are equivalent if there is
an orientation preserving \(\cC ^\infty \) diffeomorphism between their domains that commutes with them. If we have a differential form \(\omega \) in an open set containing a singular cell \(\phi :\Delta _n\to \RR ^m\),
we define \(\int _\phi \omega = \int _{\Delta _n}\phi ^*(\omega )\). By Theorem <a href="node-Integrals-Differential-Forms.html#pullbackintegral">13.1</a> this only depends on the equivalence class. Indeed
given a notion of integration, the pullback may be defined as the unique form satisfying \(\int _D\phi ^*(\omega ) = \int _{\phi (D)}\omega \) (it is dual to the pushforward of a chain).
</p>

<p>
Indeed if \(\phi \) is a singular \(1\) cell with \(\phi &apos;\neq 0\), and \(\omega = \sum _1^nf_idx_i\), is a \(1\)-form, then if \(f\) is the vector field with components \(f_i\), then \(\int _\phi \omega = \int
_{[0,1]}(f\circ \phi )\cdot \phi &apos; = \int _\phi f\cdot \tau ds\).
</p>

<p>
Now since we have an inner product structure on \(\RR ^n\), we can identify covector with vectors, as a covector corresponds to a unique vector such that dotting with that vector is that covector. Thus covector fields (\(1\)-forms)
may be identified with vector fields. Similarly if \(\phi \) is a singular \(2\) cell with orientation \(t_1,t_2\), and codomain \(\RR ^3\) with orientation \(x_1,x_2,x_3\), we can integrate a \(2\)-form associated with a vector
field \(f\) \(\omega = f_1dx_1+f_2dx_2+f_3dx_3\) over this cell, yielding \(\int _\phi \omega = \int _\Delta f(\phi (t))\cdot (\partial _1\phi \times \partial _2\phi )dt_1\wedge dt_2\) where \(\times \)
denotes cross product. If \(\nu \) denotes the unit vector in the direction of \(\partial _1\phi \times \partial _2\phi \), then \(\nu \) is the <b>normal unit vector</b>, and we can write \(\partial _1\phi \times
\partial _2\phi = \nu \Vert \partial _1\phi \times \partial _2\phi \Vert _2\). Now we can interpret \(\int _\Delta \Vert \partial _1\phi \times \partial _2\phi \Vert _2 = \int _\phi 1dS\) as the
surface area, and write \(\int _\phi \omega = \int _\phi f\cdot \nu dS\).
</p>

<p>
We would like to integrate over chains rather than cells, so we define a <b>singular \(n\)-chain</b> as a finite formal sum of singular \(n\) cells. We can let \(\Delta (x_1,\dots ,x_n)\) be the unit cell in \(\RR ^n\) with
that orientation, and then let its boundary be defined as the singular \(n-1\)-chain
</p>

<p>
\[\partial \Delta (x_1,\dots ,x_n) = \sum _{i=1}^n\sum _{\ee = 0}^1(-1)^{i+\ee }\Delta (x_1,\dots ,\ee ,\dots ,x_n) \]
</p>

<p>
where \(\ee \) denotes the part of the boundary restricting \(x_i\) to \(\ee \). For a singular \(n\)-chain \(\phi \), we define \(\partial \phi = \phi (\partial \Delta (x_1,\dots ,x_n))\). We then have our notions of
boundary and cycle for chains.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-276"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">13.2</span></span>. A boundary is a cycle.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-277"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It suffices to show this on the unit cell \(\Delta \). We have
</p>

<p>
\[ \partial \partial \Delta (x_1,\dots ,x_n) = \sum _{i=1}^n\sum _{\ee = 0}^1(-1)^{i+\ee }\partial \Delta (x_1,\dots ,\ee ,\dots ,x_n) \]
</p>

<p>
\[= \sum _{i=1}^n\sum _{\ee = 0}^1\sum _{i=1}^{n-1}\sum _{\ee &apos;=0}^1(-1)^{i+\ee +j+\ee &apos;}\Delta (x_1,\dots ,\ee &apos;,\dots ,\ee ,\dots ,x_n) \]
</p>

<p>
Now for a fixed \(\ee &apos;,\ee \) and unordered pair \((a,b)\), the term \(\Delta (x_1,\dots ,\ee &apos;,\dots ,\ee ,\dots ,x_n)\) where \(\ee &apos;\) and \(\ee \) take up the \(a\) and \(b\) slots respectively
appear twice in this sum. WLOG, \(a&lt;b\), and so we can have both \(i=a,j=b-1\) or \(i=b,j=a\). Then as \(i+j\) is a different parity for these, the terms cancel out, so this sum is \(0\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-278"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">13.3</span></span><span class="amsthmnoteplain"> (Stoke’s Theorem)</span>. <a id="stokesthm"></a>
If \(\cC \) is a \(\cC ^\infty \) singular \(n\)-chain and \(\omega \) is a \(n-1\)-form, then \(\int _\cC d\omega = \int _{\partial \cC } \omega \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-279"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Since pullback commutes with exterior derivative and integration over chains is linear, it suffices to prove this on the unit cell \(\Delta (x_1,\dots ,x_n)\) for a \(n-1\)-form
\(\omega = f dX_r\) where \(dX_r\) indicates \(dx_r\) is missing from \(dX = dx_1\wedge \dots \wedge dx_n\). This way \(d\omega = (-1)^{r-1}\partial _rfdX\). Similarly let \(\Delta \) denote the cell, \(\Delta
_{r,e}\) denote the boundary on the \(r^{th}\) side with \(\ee \), \(\Delta _r\) denote the cell \(\Delta \) with the \(r\) dimension missing. Then from Theorem <a href="node-Integration.html#fubini">10.11</a> and
Theorem <a href="node-Integration.html#2ndfdthmcalc">10.3</a> we get
</p>

<p>
\[ \int _\Delta d\omega = (-1)^{r-1}\int _\Delta \partial _rfdX= (-1)^{r-1}\int _{\Delta _r}\int _{\Delta (x_r)}\partial _rf\]
</p>

<p>
\[= (-1)^{r+1}\int _{\Delta _{r,1}}f(x_1,\dots ,1,\dots ,x_n)+(-1)^{r}\int _{\Delta _{r,0}}f(x_1,\dots ,0,\dots ,x_n) = \int _{\partial \Delta }fdX_r \]
</p>

<p>
Where \(\int _{\partial \Delta }fdX_r\) vanishes on all other parts of the boundary as on \(\Delta _{i,\ee }\) with \(i\neq r\) the \(x_i\) part is constant, so pulling back yields the form \(0\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Indeed nothing deep is going on here, one may define the exterior derivative as the map so that Theorem <a href="node-Integrals-Differential-Forms.html#stokesthm">13.3</a> holds. Note that there is a pairing between
chains and forms (homology and cohomology), and thus Theorem <a href="node-Integrals-Differential-Forms.html#stokesthm">13.3</a> says simply that \(d\) is adjoint to \(\partial \) for this pairing.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-280"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">13.4</span></span>. If \(H_1(U,\ZZ ) = 0\) for an open set \(U \subset \RR ^n\), then any closed \(\cC
^\infty \) differential \(1\)-form is exact.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-281"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By Theorem <a href="node-Line-Integrals.html#conservative">11.7</a> it suffices to show line integrals depend only on the start and end, but this follows from the
hypothesis and Theorem <a href="node-Integrals-Differential-Forms.html#stokesthm">13.3</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-282"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">13.5</span></span>. <a id="imagestokes"></a> If \(D\) is the image of a simple (orientation preserving
diffeomorphism) singular \(\cC ^\infty \) \(n\)-chain \(\cC \) and \(\omega = \sum _if_idX_i\) is an \(n-1\)-form, then
</p>

<p>
\[\int _D\sum _i(-1)^{i-1}\partial _if_i = \int _{\partial \cC }\omega \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-283"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This follows from Theorem <a href="node-Integrals-Differential-Forms.html#stokesthm">13.3</a> and Theorem <a
href="node-Integrals-Differential-Forms.html#pullbackintegral">13.1</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-284"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">13.6</span></span><span class="amsthmnoteplain"> (Green’s Theorem)</span>. If \(D\) is the image of a
simple \(\cC ^\infty \) singular \(2\)-chain \(\cC \), then
</p>

<p>
\[\int _{\partial \cC }f_1dx_1+f_2dx_2 = \int _D\partial _1f_2-\partial _2f_1\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-285"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This is a special case of Theorem <a href="node-Integrals-Differential-Forms.html#imagestokes">13.5</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Green’s theorem can be used to calculate area by integrating on the boundary the form \(x_1dx_2\) or \(-x_2dx_1\) for example. For the case of \(\partial \cC \) being a curve \(\gamma \), we can get \(\int _\gamma f\cdot
\nu ds = \int _D \partial _1f_1+\partial _2f_2\) where \(\nu \) is the outward pointing normal vector defined as the unit vector in the direction of \(\begin {pmatrix} \partial _1\gamma _2\\ -\partial _1\gamma
_1 \end {pmatrix}\). Then the left side is interpreted as work done by a vector field pushing a particle, and the right is interpreted as total flow of a substance moving across the curve with velocity given by the vector field.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-286"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">13.7</span></span><span class="amsthmnoteplain"> (Gauss’s Theorem)</span>. If \(D\) is the image of a
simple \(\cC ^\infty \) singular \(3\)-chain \(\cC \), then
</p>

<p>
\[\int _{\partial \cC }f_1dx_2\wedge dx_3+f_2dx_3\wedge dx_1 + f_3dx_1\wedge dx_2 = \int _D\sum _{i=1}^3\partial _if_i\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-287"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This is a special case of Theorem <a href="node-Integrals-Differential-Forms.html#imagestokes">13.5</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
This can also be used to calculate volume, and can similarly be written as \(\int _\gamma f\cdot \nu dS = \int _D \nabla \cdot f\), which can be interpreted as flow and amount of substance created.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-288"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">13.8</span></span><span class="amsthmnoteplain"> (Kelvin-Stokes Theorem)</span>. If \(\cC \) is a
\(\cC ^1\) singular \(2\)-chain, then
</p>

<p>
\[ \int _{\partial \cC }f\cdot \tau ds = \int _{\cC }(\nabla \times f)\cdot \nu dS \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-289"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This is a special case of Theorem <a href="node-Integrals-Differential-Forms.html#stokesthm">13.3</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
As an interpretation of the curl, let \(f\) be a vector field in \(\RR ^3\), and we can integrate around a tiny circle \(\gamma _\ee \) around a point \(a\) which bounds a disk \(D_\ee \) which has its unit normal vector \(\nu \)
pointing in the direction of \(\nabla \times f(a)\). Then by Kelvin-Stokes, \(\frac {1}{\pi \ee ^2}\int _{\gamma _\ee }f\cdot \tau ds = \frac {\int _{D_\ee }(\nabla \times f)\cdot \nu dS}{\int _{D_\ee
}dS}\). But as the curl is continuous, we get
</p>

<p>
\[ \lim _{\ee \to 0}\frac {1}{\pi \ee ^2}\int _{\gamma _\ee }f\cdot \tau ds = \Vert \nabla \times f(a)\Vert _2 \]
</p>

<a id="Analysis_h-autofile-last"></a>
</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
