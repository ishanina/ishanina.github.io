
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Analysis Theorems</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Analysis_h-autopage-100"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s Writings">Back to Ishan Levy’s Writings</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Analysis Theorems</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Set-Theory.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Set Theory</a>
</p>


<p>
<a href="node-Inequalities.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Inequalities</a>
</p>


<p>
<a href="node-Topology-R.html#autosec-35" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Topology of \(\mathbb {R}\)</a>
</p>


<p>
<a href="node-Derivatives.html#autosec-73" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Derivatives</a>
</p>


<p>
<a href="node-Series.html#autosec-101" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Series</a>
</p>


<p>
<a href="node-Endomorphisms.html#autosec-123" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Endomorphisms</a>
</p>


<p>
<a href="node-Bilinear-Maps.html#autosec-159" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bilinear Maps</a>
</p>


<p>
<a href="node-Inner-Product-Spaces.html#autosec-173" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Inner Product Spaces</a>
</p>


<p>
<a href="node-Geometry-Mappings.html#autosec-190" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Geometry of Mappings</a>
</p>


<p>
<a href="node-Integration.html#autosec-208" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Integration</a>
</p>


<p>
<a href="node-Line-Integrals.html#autosec-240" class="tocsection" >
<span class="sectionnumber">11</span>&#x2003;Line Integrals</a>
</p>


<p>
<a href="node-Exterior-Algebras-Differential-Forms.html#autosec-255" class="tocsection" >
<span class="sectionnumber">12</span>&#x2003;Exterior Algebras and Differential Forms</a>
</p>


<p>
<a href="node-Integrals-Differential-Forms.html#autosec-273" class="tocsection" >
<span class="sectionnumber">13</span>&#x2003;Integrals of Differential Forms</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Analysis Theorems</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-101"><span class="sectionnumber">5&#x2003;</span>Series</h4>
<a id="Analysis_h-autopage-101"></a>
<a id="Analysis_h-autofile-5"></a>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-102"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.1</span></span><span class="amsthmnoteplain"> (Raabe’s Test)</span>. <a id="raabe"></a> For the
series \(\sum _0^\infty c_n\), \(c_i \in \RR \) if \(R_n = n(1-\frac {c_{n+1}}{c_n})\) is larger than \(R&gt;1\) for sufficiently large \(n\), the series is absolutely convergent.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-103"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG \(c_n \geq 0\). Then note that \(R_n-1 = \frac {1}{c_n}(c_n(n-1)-c_{n+1}n)\) so \(0 \leq c_n = \frac {c_n(n-1)-c_{n+1}n}{R_n-1}\). By hypothesis
\(R_n-1\) stays away from \(0\) for large \(n\) so it suffices to show \(c_n(n-1)-c_{n+1}n\), which is positive for large \(n\), converges. But \(\sum _1^mc_n(n-1)-c_{n+1}n = -c_{m+1}m\) is monotonically increasing for large
\(m\) and bounded above by \(0\) so converges to a limit. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-104"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.2</span></span>. <a id="radconv"></a> Every power series \(\sum _0^\infty c_nz^n\), \(c_n \in
\CC \) has a radius of convergence \(R\) given by Hadamard’s formula \(\frac {1}{R} = \limsup |c_n|^{\frac {1}{n}}\)
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-105"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> For any \(r&lt;R\) and large \(n\) we have \(|c_n|^{\frac {1}{n}}&lt; \frac {1}{r}\) so if \(|z|&lt;r&lt;R\) we have \(\sum _n^\infty |c_n|z^n &lt; \sum
_n^\infty \frac {z^n}{r^n}\) so we have absolute convergence. Similarly if \(|z|&gt;r&gt;R\) there are infinitely many terms so that \(|c_n|\geq \frac {1}{r^n}\) so the series diverges. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-106"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.3</span></span>. Every power series \(\sum _0^\infty c_nz^n\) is holomorphic in its radius of
convergence, and its derivative, \(\sum _0^\infty nc_nz^{n-1}\) has the same radius of convergence.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-107"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> First note by Proposition <a href="node-Series.html#radconv">5.2</a> since \(n^{1/n} \to 1\) as \(n \to \infty \) we have that \(\sum _0^\infty nc_nz^{n-1}\) has
the same radius of convergence.
</p>

<p>
Let \(z_0,z_0+h\) lie in radius \(r\), which is less than the radius of convergence.
</p>

<p>
\[\left |\frac {\sum _0^\infty c_j(z_0+h)^j-\sum _0^\infty c_jz_0^j}{h}-\sum _0^\infty c_jjz_0^{j-1}\right |\]
</p>

<p>
\[= |\ee _n(h)| + \left |\frac {\sum _{n+1}^\infty c_j(z_0+h)^j-\sum _{n+1}^\infty c_jz_0^j}{h}\right |+|\sum _{n+1}^\infty c_jjz_0^{j-1}|\]
</p>

<p>
where \(\ee _n(h)\) is the error from the \(n^{th}\) partial sum’s approximation by its derivative. Since \(a^j-b^j = (a-b)(a^{j-1}+a^{j-2}b+\dots +b^{j-1})\) we have \(|\frac {(z_0+h)^j-z_0^j}{h}|\leq
jr^{j-1}\). For any \(\ee &gt;0\), we can choose \(n\) large enough so that \(\sum _{n+1}^\infty jc_jr^{j-1}&lt;\ee \). Afterwards we can choose \(h\) small enough so \(\ee _n(h)&lt;\ee \). Then continuing from
above we get
</p>

<p>
\[\leq \ee + \ee + \ee = 3\ee \]
</p>

<p>
concluding the proof. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-108"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.4</span></span><span class="amsthmnoteplain"> (Abel’s Theorem)</span>. If a power series \(f(x)
= \sum _0^\infty c_ix^i\) converges at an endpoint of its radius of convergence \(R\), it converges uniformly and hence is continuous on \([0,R]\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-109"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG,\(R = 1\). Let \(A_n = \sum _0^{n-1}c_i\). We have then for \(x \in [0,1]\)
</p>

<p>
\[ |\sum _n^mc_ix^i|=|\sum _n^mA_{i+1}x^i-\sum _n^mA_ix^i|=|\sum _n^m(f(1)-A_{i+1})x^i-\sum _n^m(f(1)-A_i)x^i|\]
</p>

<p>
\[ = |\sum _{n+1}^{m+1}(f(1)-A_i)x^{i-1}-\sum _n^m(f(1)-A_i)x^i |\]
</p>

<p>
\[= |\sum _{n+1}^{m}(f(1)-A_i)(x^{i-1}-x^i)-(f(1)-A_i)x^n+(f(1)-A_i)x^{m}| \]
</p>

<p>
now choosing \(N\) large enough so \(|f(1)-A_i|&lt;\ee \) for \(i&gt;n\) and noting \(x \in [0,1]\)
</p>

<p>
\[\leq \sum _{n+1}^{m}|(f(1)-A_i)|(x^{i-1}-x^i)+|(f(1)-A_i)|x^n+(f(1)-A_i)x^{m}|\]
</p>

<p>
\[\leq (x^n-x^m)\ee +x^n\ee +x^m\ee \leq 3\ee \]
</p>

<p>
and we are done as the partial sums are uniformly Cauchy. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-110"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.5</span></span>. If \(f(x) = \sum _0^\infty c_iz^i\) converges within radius \(R\), and \(a\) is
within this radius, \(f(a+x)\) converges and is analytic within radius of \(R-|a|\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-111"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Inside \(|z|&lt;R-|a|\) the power series absolutely converges, and we would like to recenter around 0. WLOG \(a\) is real and non-negative. For \(0&lt;x&lt;R-|a|\) we have
</p>

<p>
\[ \sum _0^\infty c_i(a+x)^i = \sum _0^\infty c_i \sum _{j=0}^i\binom i j a^{i-j}x^j \]
</p>

<p>
We can then split the inner sum up into separate terms, still absolutely convergent as everything is non-negative, and then we can collect like powers of \(x\) to get
</p>

<p>
\[\sum _0^\infty c_i(a+x)^i = \sum _0^\infty \Big (\sum _m^\infty c_i\binom i m a^{i-m}\Big )x^m\]
</p>

<p>
so \(f(a+z)\) has a power series that converges on the interval \((0,R-|a|)\). Hence its radius of convergence is at least \(R-|a|\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-112"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.6</span></span>. <a id="companalytic"></a> The composite of two \(\FF \)-analytic functions \(\FF \to
\FF \) is analytic.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-113"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Real analytic functions are restrictions of complex analytic ones, and by the chain rule for holomorphic functions, the composite is analytic. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-114"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.7</span></span>. <a id="binom"></a> \((1+z)^a\) is holomorphic within radius \(1\) around the origin, its
power series given by \(\sum _0^\infty \binom a j z^j\). It converges absolutely and uniformly on the interval \([-1,1]\) when \(a&gt;0\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-115"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> That this is analytic follows from Lemma <a href="node-Series.html#companalytic">5.6</a>, and that it is holomorphic of radius \(1\) comes from Hadamard’s formula. Now
when \(z \in [-1,1]\), for \(n&gt;a&gt;0\) we have \(n\bigg (1-\Big |\frac {\binom a {n+1}}{\binom a n}z\Big |\bigg ) \geq n\bigg (1-\Big |\frac {\binom a {n+1}}{\binom a n}\Big |\bigg ) = n\big
(1-\frac {n-a}{n+1}\big ) = \frac {n(1+\alpha )}{n+1}\) which is larger than \(1\) for sufficiently large \(n\) so by Lemma <a href="node-Series.html#raabe">5.1</a> and Theorem <a
href="node-Topology-R.html#unifconv">3.17</a> we have the last statement. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-116"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.8</span></span>. <a id="absapprox"></a> The function \(|x|\) can be uniformly approximated by
polynomials in a bounded interval.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-117"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG the interval is \([-1,1]\). By Lemma <a href="node-Series.html#binom">5.7</a> \((1-t)^{1/2}\) is uniformly approximated by its Taylor expansion in this interval,
and we can set \(t = 1-x^2\) we get \((x^2)^{1/2} = |x|\) is as well. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-118"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5.9</span></span><span class="amsthmnoteplain"> (Stone-Weierstrass)</span>. <a id="stoweier"></a>
If \(S\) is compact, any \(\RR \)-subalgebra of \(\cC (S,\RR )\) that separates points is dense.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-119"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(A\) be a \(\RR \)-subalgebra of \(\cC (S,\RR )\) that separates points. If \(f \in \bar {A}\), then \(|f| \in \bar {A}\) as \(f\) has a bounded image so by Lemma
<a href="node-Series.html#absapprox">5.8</a> \(|f|\) can be approximated uniformly by polynomials in \(f\), which are in \(\bar {A}\).
</p>

<p>
As a consequence, \(\max (f,g), \min (f,g) \in \bar {A}\) whenever \(f,g\) are as they are linear combinations of \(f,g,|f|,|g|\).
</p>

<p>
Now for any \(\ee &gt;0,h \in \cC (S,\RR )\) we can approximate \(h\) up to \(\ee \) as follows: for each \(a \in S\) choose \(f_{a,b}\) for each \(b\) so that \(f(a) = h(a),f(b) = h(b)\). Then in a small neighborhood
of \(b\), \(f_{a,b}(x)&gt;h(x)-\ee \), but \(S\) is compact so finitely many such neighborhoods suffice to have \(f_a = \max _{b_i}f_{a,b_i}\) be at least \(h(x)-\ee \) everywhere. Now we can similarly choose small
neighborhoods for each \(a\) so that \(f_a &lt; h(x)+\ee \), and once again finitely many suffice so that \(\min _{a_i}{f_{a_i}}\) is our desired approximation. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
There is an analogous version for \(\cC (S,\CC )\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Analysis_h-autopage-120"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">5.10</span></span>. If \(S\) is compact, any \(C^*\)-subalgebra of \(\cC (S,\CC )\) that separates points is
dense.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Analysis_h-autopage-121"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(A\) again be such a subalgebra. As \(A\) is closed under conjugation, it contains the real and imaginary parts of any element \(f\). Then by Theorem <a
href="node-Series.html#stoweier">5.9</a> the real and imaginary parts of any function \(h\) are in \(\bar A\) so \(h\) is as well. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
