
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Lie Algebras</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Lie_Algebras_h-autopage-117"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s Writings">Back to Ishan Levy’s Writings</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Lie Algebras</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Nilpotent-Solvable-Lie-Algebras.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Nilpotent and Solvable Lie Algebras</a>
</p>


<p>
<a href="node-Semisimple-Lie-Algebras.html#autosec-36" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Semisimple Lie Algebras</a>
</p>


<p>
<a href="node-Poincare-Birkhoff-Witt.html#autosec-71" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Poincare&#x0301;-Birkhoff-Witt</a>
</p>


<p>
<a href="node-sl2k.html#autosec-81" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;\(\mathfrak {sl}_2k\)</a>
</p>


<p>
<a href="node-Root-Systems.html#autosec-90" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Root Systems</a>
</p>


<p>
<a href="node-Classification.html#autosec-118" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Classification</a>
</p>


<p>
<a href="node-Homological-Methods.html#autosec-183" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Homological Methods</a>
</p>


<p>
<a href="node-To-add.html#autosec-219" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;To add</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Lie Algebras</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-118"><span class="sectionnumber">6&#x2003;</span>Classification</h4>
<a id="Lie_Algebras_h-autopage-118"></a>
<a id="Lie_Algebras_h-autofile-6"></a>

<p>
To classify root systems, we will really classify root systems with a generic linear functional, and show it doesn’t depend on the functional. Suppose that we have a root system \((V,\Delta )\) and a linear functional \(f\) not
vanishing on any root. Then we say a root \(\alpha \) is <b>positive</b> if \(f(\alpha )&gt;0\), and negative otherwise. A positive root is <b>simple</b> if it is not the sum of two positive roots. A <b>highest root</b>
\(\theta \) is a root such that \(f(\theta )\) is maximal. \(\Delta _+,\Delta _-\) denote the positive and negative roots, and \(\Pi \) denotes the simple roots. \(\Pi \) is indecomposable if it can’t be nontrivially
partitioned into orthogonal sets.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-119"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6.1</span></span><span class="amsthmnoteplain"> (Dynkin)</span>.
</p>
<ul style="list-style-type:none">


<li>
<p>
1. If \(\alpha ,\beta \in \Pi \) are distinct, then \(\alpha -\beta \notin \Delta \) and \((\alpha ,\beta )\leq 0\).
</p>


</li>
<li>


<p>
2. Every positive root is a nonnegative integral linear combination of simple roots.
</p>


</li>
<li>


<p>
3. If \(\alpha \in \Delta _+-\Pi \), then for some \(\gamma \in \Pi \), \(\alpha -\gamma \in \Pi \), and when this is true, \(\alpha - \gamma \in \Delta _+\).
</p>


</li>
<li>


<p>
4. \(\Pi \) is a basis of the lattice generated by \(\Delta \).
</p>


</li>
<li>


<p>
5. \(\Delta \) is indecomposable iff \(\Pi \) is.
</p>


</li>
<li>


<p>
6. For an indecomposable root system, there is a unique highest root \(\theta \), and \((\theta ,\alpha )&gt;0,\alpha \in \Delta _+\).
</p>
<p>


</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-120"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\): If it were in \(\Delta \), by possibly taking its negative, we could assume it is in \(\Delta _+\). But then \(\alpha -\beta + \beta = \beta \) so \(\beta \) isn’t
simple. The string condition then implies that \((\alpha ,\beta ) \leq 0\).
</p>

<p>
\((2)\): Break up a positive root into smaller positive roots until they are all simple.
</p>

<p>
\((3)\): \(\alpha = \sum _i c_i\gamma _i\) where \(\gamma _i\) are positive simple roots, and \(c_i&gt;0\). we have that \(\sum _i c_i\langle \alpha |\gamma _i\rangle = \langle \alpha |\alpha \rangle = 2\),
so \(\langle \alpha |\gamma _i\rangle \) is positive for some \(\gamma _i\), so \(\gamma _i-\alpha \in \Delta \). If \(\gamma -\alpha \) is ever in \(\Delta _+\), then since \(\alpha \) is too, \(\gamma \) cannot be
simple. Thus \(\alpha -\gamma \in \Delta _+\).
</p>

<p>
\((4)\): Since \(\Delta \) spans the lattice, so does \(\Delta _+\), so by \((2)\), \(\Pi \) does too. Suppose there is a relation \(\sum c_i \gamma _i = \sum c&apos;_j \gamma &apos;_j\) where \(c_i,c&apos;_j\geq
0\), and \(\gamma _i,\gamma _j&apos;\) are a disjoint set of simple roots. Then \((\sum c_i \gamma _i,\sum c&apos;_j \gamma &apos;_j) \leq 0\) by \((1)\) so the coefficients are \(0\).
</p>

<p>
\((5)\): If \(\Gamma \) is decomposable, the string condition and \((2),(3)\) implies that any element in \(\Delta _+\) is decomposable into things in exactly one of the decompositions of \(\Gamma \), showing \(\Delta \) is
decomposable. Conversely if \(\Delta \) is decomposable, as noted earlier the string condition shows the decomposition is orthogonal, implying that that the simple roots decompose orthogonally too.
</p>

<p>
\((6)\): If \(\theta \) is a highest root and \(\alpha \) a positive root, then \(\theta +\alpha \notin \Delta \) because it is larger than \(\theta \). Then the string condition implies \((\theta ,\alpha )\geq 0\). By
\((1),(2)\), the set of \(\gamma \in \Pi \) orthogonal to \(\theta \) and the set of \(\gamma \in \Pi \) in the decomposition of \(\theta \) are a decomposition of \(\Pi \), so by indecomposability we must have \((\theta
,\gamma )&gt;0\) for \(\gamma \in \Pi \) and hence for all elements of \(\Delta _+\).
</p>

<p>
But if \(\theta _1\neq \theta _2\) are highest roots, \(f(\theta _1-\theta _2)\) = 0 so it cannot be a root and \(f(\theta _1+\theta _2)&gt;f(\theta _1)\) so it isn’t a root. the string condition then says \((\theta
_1,\theta _2) = 0\), but this was shown to not be possible. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-121"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.2</span></span>. If \(\gamma _1,\dots ,\gamma _r\) are the simple roots, then the matrix \(A\) with
entries \(\langle \gamma _i|\gamma _i\rangle \) is called the <b>Cartan matrix</b>.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-122"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.3</span></span>. <a id="cartanproperties"></a> The Cartan matrix \(A\) is an integer matrix with \(2\)
on the diagonals, nonpositive numbers on the off-diagonals, and positive principle values. Moreover \(A_{ij}=0 \iff A_{ji}=0\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-123"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The first,second, and last claim are clear, the third follows from the previous theorem, and the fourth follows from Sylvester’s criterion because the Cartan matrix is the inner
product matrix except with the rows rescaled. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-124"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.4</span></span>. If \(\gamma _1,\dots ,\gamma _r,\theta \) are the simple roots, then the matrix
\(\tilde {A}\) with the same entries for \(A\) except including \(\theta \) is called the <b>extended Cartan matrix</b>.
</p>

</li>

</ul>

</div>

<p>
\(\tilde {A}\) clearly satisfies the same properties as \(A\) except the determinant is \(0\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-125"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.5</span></span>. An abstract Cartan matrix is one satisfying the properties of Lemma <a
href="node-Classification.html#cartanproperties">6.3</a>.
</p>

</li>

</ul>

</div>

<p>
A Cartan matrix is <b>indecomposable</b> iff it is not the direct sum of Cartan matrices. Clearly a root system is indecomposable iff its Cartan matrix is.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-126"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.6</span></span>. The only \(2x2\) Cartan matricies (up to rearrangement) are
</p>

<p>
\[ \begin {bmatrix} 2 &amp; 0 \\ 0 &amp; 2 \end {bmatrix} \begin {bmatrix} 2 &amp; -1 \\ -1 &amp; 2 \end {bmatrix} \begin {bmatrix} 2 &amp; -1 \\ -2 &amp; 2 \end {bmatrix} \begin {bmatrix} 2
&amp; -1 \\ -3 &amp; 2 \end {bmatrix} \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
Because of this classification and the fact that every matrix is determined by its graph of \(2x2\) principal submatrices, the Cartan matrix is completely encoded by a <b>Dynkin diagram</b>, where there is a vertex for every
diagonal entry and an edge corresponding to each \(2x2\) principal submatrix.
</p>
<div class="center">
<table>

<tr>
<td class="tdc">\(\begin {bmatrix} 2 &amp; 0 \\0 &amp; 2 \end {bmatrix}\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-1"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-1.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(\begin {bmatrix} 2 &amp; -1 \\-1 &amp; 2 \end {bmatrix}\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-2"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-2.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(\begin {bmatrix} 2 &amp; -1 \\-2 &amp; 2 \end {bmatrix}\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-3"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-3.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(\begin {bmatrix} 2 &amp; -1 \\-3 &amp; 2 \end {bmatrix}\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-4"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-4.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>

</table>

</div>

<p>
An edge indicates two arrows that are not orthogonal. The double and triple edges indicate that one root is longer, and they point to the shorter root.
</p>

<p>
Extended Cartan matrices gives an <b>extended Dynkin diagram</b>, where we mark the highest root as special. In the case of \(A_1\) the extended Cartan matrix consists of all \(2\)s, so it is exceptional, and we denote it by
<span
    id="lateximage-Lie_Algebras_h-5"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-5.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-139"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">6.6.1</span></span><span class="amsthmnotedefinition"> (Extended Dynkin
Diagrams)</span>. Here is a list of the extended Dynkin diagrams of the thus-far constructed root systems. We will soon see that this list is complete.
</p>
<div class="center">
<table>

<tr>
<td class="tdc">\(A_1\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-6"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-6.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(A_n\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-7"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-7.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(B_n\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-8"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-8.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(C_n\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-9"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-9.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(D_n\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-10"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-10.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(E_6\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-11"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-11.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(E_7\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-12"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-12.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(E_8\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-13"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-13.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(F_4\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-14"
    class="lateximagesource"
><!--
--><img
    src="Lie_Algebras_h-images/image-14.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span></td>
</tr>


<tr>
<td class="tdc">\(G_2\)</td>
<td class="tdc"><span
    id="lateximage-Lie_Algebras_h-15"
    class="lateximagesource"
><!--
--><img
      src="Lie_Algebras_h-images/image-15.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span></td>
</tr>

</table>

</div>

<p>
Now let’s see why these are as above. We will always choose \(f\) so the \(e_i\) are positive and \(e_i\) is much larger than \(e_{i+1}\).
</p>
<ul style="list-style-type:none">


<li>
<p>
• \(A_n\):, The roots are \(e_i-e_j\) (we drop the \((-)^*\) in the notation). Then the simple roots are \(e_i-e_{i+1}\), and the largest root is \(e_1-e_n\).
</p>


</li>
<li>


<p>
• \(B_n\): The roots are \(\pm (e_i +e_j),e_i - e_j, \pm e_i\). Then the simple roots are \(e_n, e_{i}-e_{i+1}\), and the largest root is \(e_1+e_2\).
</p>


</li>
<li>


<p>
• \(C_n\): The roots are \(\pm (e_i+e_j),e_i-e_j, 2e_i\). The simple roots are \(2e_n, e_{i}-e_{i+1}\), and the largest root is \(2e_1\).
</p>


</li>
<li>


<p>
• \(D_n\): The roots are \(\pm (e_i+e_j), e_i-e_j\). The simple roots are \(e_i-e_{i+1}, e_n+e_{n-1}\) and the largest root is \(e_1+e_2\)
</p>


</li>
<li>


<p>
• \(E_8\): The roots are \(\pm (e_i+e_j), e_i - e_j\) and things of the form \(\frac {1}{2}(e_1\pm \dots e_8)\) where there are an even number of minus signs. The simple roots are then \(e_i-e_{i+1}\) for \(i&gt;1\),
\(e_8+e_7, \frac 1 2 (e_1+e_8-\sum _2^6 e_i)\), and the largest root is \(e_1+e_2\).
</p>


</li>
<li>


<p>
• \(E_7\): The roots are \(e_i-e_j, i \neq j\) and things of the form \(\frac {1}{2}(e_1\pm \dots e_8)\) where the number of minus signs is divisible by four. The simple roots are then \(e_i-e_j\) for \(i&gt;1\) and
\(\frac 1 2 (\sum _{1,6,7,8} e_i - \sum _{2,3,4,5}e_i)\), and the largest root is \(e_1+e_2\).
</p>


</li>
<li>


<p>
• \(E_6\): The roots are \(e_i-e_j\) such that if either of \(\{i,j\}\cap \{7,8\}\) is \(\{7,8\}\) or \(\phi \), as well as things of the form \(\frac {1}{2}(e_1\pm \dots e_8)\) where the number of minus signs is divisible
by four, \(e_7,e_8\) have opposite signs. The simple roots are \(e_i-e_{i+1}\) for \(i \neq 1,7\) and \(\frac 1 2 (\sum _{1,5,6,8}e_i-\sum _{2,3,4,7}e_j)\) and the largest root is \(e_1-e_2\).
</p>


</li>
<li>


<p>
• \(F_4\): The roots are \(\pm e_i, \pm (e_i + e_j), e_i-e_j, \pm \frac 1 2 (e_1\pm \dots e_4)\). The simple roots are \(\frac {1}{2} (e_1-e_2-e_3-e_4), e_4,e_2-e_3,e_3-e_4\), and the largest root is
\(e_1+e_2\).
</p>


</li>
<li>


<p>
• \(G_2\): The roots are \(\pm (e_i + e_j), e_i - e_j, \pm (2e_i-e_j-e_k)\). The simple roots are \(e_2-e_3, e_1-2e_2+e_3\), and the largest root is \(2e_1-e_2-e_3\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-162"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6.7</span></span>. The examples contain a complete list of indecomposable Cartan matrices.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-163"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Every subdiagram of a Dynkin diagram is a Dynkin diagram. Moreover, any extended Dynkin diagram is not a Dynkin diagram. Finally, for any multiple edge on a vertex of
degree \(1\) on a Dynkin diagram, reversing an isolated set of multiple edges preserves being a Dynkin diagram since it preserves determinants of principle submatrices. Reducing an edge’s multiplicity preserves being a Dynkin
diagram since it increases the determinant of the principal submatrices. These observations essentially prove the theorem. Namely, the extended Dynkin diagrams constructed obstruct any other Dynkin diagrams from existing via
these observations.
</p>

<p>
To actually work this out, \(A_n\) obstructs cycles from existing, so all Dynkin diagrams are trees. \(G_2\) obstructs triple edges from existing anywhere else, \(F_4\) obstructs double edges from appearing not on a leaf. \(C_n\)
obstructs double edges from appearing multiple times elsewhere, \(B_n\) obstructs branching when there is a double edge. \(D_n\) obstructs double branching, and \(E_6,E_7,E_8\) obstruct branches from getting too long. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Observe that the list is a bit redundant. Namely, \(A_1=B_1=C_1\), \(D_2 = A_1 \oplus A_1\), \(B_2 = C_2\), \(D_3 = A_3\), but the rest are not redundant. Sometimes these are called <b>exceptional isomorphisms</b>.
</p>

<p>
We will now show that this classification also classifies simple Lie algebras and indecomposable root systems as well. First we will show nothing depends on \(f\), and that we can recover the root system from the Cartan matrix.
</p>

<p>
There is another way of thinking about root systems. Namely, reflection across the orthogonal plane to \(a\) is given by the equation \(r_a(v) = v-\langle a|v\rangle a\). One then sees from the string condition that \(\Delta
\) is closed under reflection by any element in it (this condition is actually equivalent to it by checking what happens in dimension \(2\)). For the root system of a Lie algebra, one can see the reflection arising from the action of the
element \(\tau \) of the \(\msl _2\)-triple associated to the root. The group generated by \(r_\alpha , \alpha \in \Delta \) is called the <b>Weyl group</b> and denoted \(W(\Delta )\). It is finite since it acts faithfully
on \(\Delta \). The fact that there are so many symmetries already suggests \(f\) doesn’t really do much.
</p>

<p>
If \(\gamma _1,\dots ,\gamma _r\) are the simple roots, let \(s_i = r_{\gamma _i}\); these are called simple reflections. Define the <b>height</b> of a positive root \(\alpha \) to be \(\hgt (\alpha ) = \sum _i c_i\)
where \(\alpha = \sum _i c_i \gamma _i\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-164"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6.8</span></span>.
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(s_i\) preserves \(\Delta _+-\gamma _i\).
</p>


</li>
<li>


<p>
2. If \(\alpha \in \Delta _+-\Pi \), there is an \(i\) so that \(\hgt (s_i(\alpha )) &lt; \hgt (\alpha )\).
</p>


</li>
<li>


<p>
3. There is a sequence of simple reflections taking any positive root to an element of \(\Pi \) such that at every step it is still positive.
</p>


</li>
<li>


<p>
4. \(W\) is generated by simple reflections.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-165"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\): Such an element looks like \(\sum _jc_j \gamma _j\) where \(c_j &gt; 0\) for some \(j \neq i\). \(\gamma _j\) are linearly independent and everything is either a
strictly positive or negative linear combination of them, so the result follows.
</p>

<p>
\((2)\): \((\alpha ,\alpha )&gt;0\), and \(\alpha \) is a positive sum of \(\gamma _i\)s so \((\alpha ,\gamma _i)&gt;0\) for some \(i\). Then \(s_i(\alpha )\) has smaller height.
</p>

<p>
\((3)\): Follows immediately from \((2)\).
</p>

<p>
\((4)\): By \((3)\) we can get between from element of \(\Delta \) and an element \(\gamma _i\) of \(\Pi \) via simple reflections. Now conjugating \(s_i\) by this composite of simple reflections gives the reflection by that
element. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We can consider \(V-\cup _{\alpha \in \Delta }T_\alpha \) where \(T_\alpha \) is the plane perpendicular to \(\alpha \). The components of this are called the <b>Weyl chambers</b>. The Weyl group acts on these
chambers since \(r_\alpha (T_\beta ) = T_{r_\alpha (\beta )}\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-166"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.9</span></span>. \(x\) such that \((x,\gamma )&gt;0\) for any \(\gamma \in \Delta \) form a chamber.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-167"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Since anything is a positive or negative learn combination of \(\Pi \), the set described doesn’t contain anything orthogonal to anything in \(\Delta \). Moreover its boundary
clearly consists of things that do. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
A word in the \(s_i\) is <b>reduced</b> if it isn’t equivalent to a shorter word in \(W\). The length of a reduced work representing \(w \in W\) is called its <b>length</b>, denoted \(l\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-168"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.10</span></span><span class="amsthmnoteplain"> (Exchange Lemma)</span>. Suppose that
\(s_{i_1}\dots s_{i_{t-1}}(\gamma _{i_t}) \in \Delta _-\). Then \(s_{i_1}\dots s_{i_t}\) isn’t reduced. In fact, it is equal to \(s_{i_1}\dots s_{i_{m-1}}s_{i_{m+1}}\dots s_{i_{t-1}}\) for some \(m\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-169"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The sequence \(\beta _k = s_{i_k}\dots s_{i_{t-1}}(\gamma _{i_t})\) at some point switches from negative to positive, which can only happen by the previous theorem if
\(\beta _{m+1}\) is \(\gamma _{i_m}\). But then \(w=s_{i_{m+1}}\dots s_{i_{t-1}}\) satisfies \(ws_{i_t}w^{-1} = s_{i_m}\) which gives the result after multiplying by \(w\) on the right. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-170"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6.11</span></span>. \(W\) acts simply and transitively on chambers, and on possible sets of simple roots.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-171"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> To see it acts transitively on chambers, make a generic path between two chambers and everytime you cross a wall, do a reflection. By realizing the reflections on \(f\) and on
\(\Pi \), we see that the chambers correspond to sets of simple roots for various choices of \(f\). To see that the action is simple, suppose that \(w\in W\) fixes \(\Pi \). If \(w = s_{i_1}\dots s_{i_{t}}\), then the exchange
lemma shows it isn’t reduced. Thus \(w\) must be trivial. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-172"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">6.12</span></span>. The Cartan matrix is not dependent on \(f\) and one can recover the root system from
the Cartan matrix. In fact there is a bijection between indecomposable Cartan matrices and root systems.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-173"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The Cartan matrix essentially encodes the inner product on \(\Pi \) which form a basis for the vector space. Thus we can recover these vectors, but by using the reflections by
these vectors, we can recover everything. To see this always gives a root system, note that finiteness follows from everything lying on a lattice and being bounded. Most of the conditions are easy, and since it is closed under
reflections of the generators and generated by them, it is closed under reflections of all elements. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-174"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">6.12.1</span></span>. \(A_n\) has Weyl group \(S_{n+1}\) coming from the permutations of the
\(e_i\).
</p>

</li>

</ul>

</div>

<p>
Recall \(\mg \) semisimple is \(\mh \oplus \bigoplus _{\alpha \in \Delta }\mg _{\alpha } = \mg \oplus \mn _+ \oplus \mn _- \). where \(\mn _+,\mn _-\) are the nilpotent subalgebra of positive/negative root
spaces. We would like to find a description in terms of the Cartan matrix \(A_{ij}\). Let \(\gamma _1\dots \gamma _r\) be the simple roots, and let \(e_i,f_i,h_i\) be \(\msl _2\)-triples corresponding to \(\gamma _i\).
Note that they generate the algebra, are linearly independent, and satisfy the following relations called the <b>Chevalley relations</b>:
</p>

<ul style="list-style-type:none">

<li>
<p>
1. \([h_i,h_j]=0\)
</p>

</li>
<li>

<p>
2. \([h_i,e_j]=\langle \gamma _i|\gamma _j\rangle e_i\)
</p>

</li>
<li>

<p>
3. \([h_i,f_j]= -\langle \gamma _i|\gamma _j\rangle f_i\)
</p>

</li>
<li>

<p>
4. \([e_i,f_j]= \delta _{ij}h_i\)
</p>
</li>
</ul>

<p>
Note that these relations come from entries in the Cartan matrix: namely \(\langle \gamma _i|\gamma _j\rangle \) is \(A_{ij}\). Let \(\tilde {\mg }\) denote the free Lie algebra presented by these relations. Let \(\tilde
{\mn }_+,\tilde {\mn }_-\) denote the subalgebras generated by \(e_i\) and \(f_i\) respectively. When the Cartan matrix was constructed from a Lie algebra, there is a natural surjective map to \(\tilde {\mg } \to \mg
\). Note that the construction is symmetric in the \(f_i,e_i\): we can swap the two and replace \(h_i\) with its negative and the same relations hold. This means we have to prove half as many things about the construction. We
will still use \(\gamma _i \in \Pi \) to denote the weights of the span of \(\ad (h_i)\) on \(e_i\).
</p>

<p>
Consider the \(T(V)\) the tensor algebra on the vector space \(V\) generated by \(v_1,\dots , v_r\). This should be thought of as the universal enveloping algebra of \(\tilde {\mg }/(\tilde {\mn }_+\oplus \mh )\). Of
course this doesn’t make sense since the quotient isn’t by an ideal, but it is the quotient as an algebra and can probably be thought of as the invariant differential operators on the quotient formal group. We can produce an action of
\(\tilde {\mg }\) on \(T(V)\) as follows: \(h_k\) sends \(v_{i_1}\dots v_{i_s}\) to \(-(\sum _1^sA_{k,i_j}\rangle ) v_{i_1}\dots v_{i_s}\), \(f_k\) sends \(v_{i_1}\dots v_{i_s}\) to \(v_k v_{i_1}\dots
v_{i_s}\), and \(e_k\) sends \(v_{i_1}\dots v_{i_s}\) to \(\sum _1^s (\delta _{k,i_j}v_{i_1}\dots \hat {v_{i_j}}\dots v_{i_s})\). A straightforward calculation shows that this satisfies the Chevalley relations, so is
indeed an action.
</p>

<p>
For the next lemma, it will be convenient to introduce notation. \(e(s),f(s)\) denote an iterated bracket of \(s\) of the \(e_i,f_i\) respectively, and \(\Sigma \) to denote a linear combination. \(f(0)\) or \(e(0)\) will mean
the \(h_i\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-175"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">6.13</span></span>.
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(\tilde {\mg } = \tilde {\mn }_+\oplus \tilde {\mn }_-\oplus {\mh }\)
</p>


</li>
<li>


<p>
2. \(\mn _+,\mn _-\) are free on the \(e_i,f_i\) and \(\tilde {\mn }_+ = \oplus _{\alpha \in \QQ _+} \mg _\alpha , \tilde {\mn }_- = \oplus _{\alpha \in \QQ _+} \mg _{-\alpha }\) where \(\QQ _+\) is
\(\ZZ _{\geq 0} \Pi -0\) and \(\alpha \) is the weights of the \(\mh \) action.
</p>


</li>
<li>


<p>
3. If \(I\) is an ideal in \(\tilde {\mg }\) then \(I = \mh \cap I \oplus \bigoplus _\alpha \mg _\alpha \cap I\).
</p>


</li>
<li>


<p>
4. Maximal ideals in \(\tilde {\mg }\) correspond to components of the Dynkin diagram.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-176"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\): The action on \(T(V)\) gives a Lie algebra homomorphism \(\tilde {\mg } \to T(V)\). First note that the \(h_i\) are linearly independent since the Cartan matrix is
nonsingular. The Jacobi identity (equivalent to the fact that \(\ad \) is a derivation) \([h,e(s)]=[h,[e(1),e(s-1)]] = [[h,e(1)],e(s)]+[e(1),[h,e(s-1)]]\) shows via induction on \(s\) that for an iterated bracket of
\(e_{i_1},\dots , e_{i_s}\) that \(\ad h_k\) has eigenvalue \(\sum _1^sA_{k,i_j}\), and by symmetry the same is true for \(f_i\) with the opposite eigenvalue.
</p>

<p>
Next we can see inductively that \([f(s),e(s&apos;)]\) is a linear combination of \([f(s-s&apos;)]\) when \(s\geq s&apos;\geq 0\) via \([f(s),e(s&apos;)] = [f(s),[e(s&apos;-1),e(1)]] =
[[f(s),e(s&apos;-1)],e(1)]+[e(s&apos;-1),[f(s),e(1)]]\) reducing to \(s&apos;=1\) and \([f(s),e(1)] = [[f(s-1),f(1)],e(1)] = [[f(s-1),e(1)],f(1)]+ [f(s-1),[f(1),e(1)]]\) reducing to \(s=1\), where it
follows from relation \((4)\). The same statement holds when \(e,f\) are switched.
</p>

<p>
Thus \(\tilde {\mn }_+ + \tilde {\mn }_- + \mh \) is a subalgebra, but it isn’t clear that the sum is direct. However, by nondegeneracy we can find \(h \in \mh \) such that its eigenvalue on \(e(s)\) is positive, and hence
on \(f(s)\) is negative. Moreover \([\mh ,\mh ]=0\) so the eigenspace decomposition of \(h\) separates these subalgebras.
</p>

<p>
\((2)\): There is a commutative square
</p>
<div class="center">

<p>
<span
      id="lateximage-Lie_Algebras_h-16"
      class="lateximagesource"
><!--
   F (fi )         ñ−


End(T (fi ))   End(T (V ))
--><img
      src="Lie_Algebras_h-images/image-16.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
where the left vertical map is the canonical action on the universal enveloping algebra. Since the left arrow is injective and the bottom arrow is an isomorphism, the top arrow is injective. But it is also clearly surjective, so it is an
isomorphism. Thus \(\tilde {\mn }_+ \) is free and by symmetry \(\tilde {\mn }_- \) is too. The second statement was already proven in \((1)\).
</p>

<p>
\((3)\): Given an element \(x \in I\), keep acting by the elements of \(\mh \). Since \(\mh \) acts semisimply, some linear combination of the \(\ad (\mh )^i x\) will be the projection onto the various eigenspaces of \(x\).
</p>

<p>
\((4)\): Consider any proper ideal of \(\tilde {\mg }\). By \((3)\) if its intersection with \(\mh \) wasn’t \(0\), it would have to contain all nonzero weight spaces of its intersection in \(\mh \), which would contain atleast one
\(f_i,e_i\). Thus it would contain \([e_i,f_i]=h_i\), for which the eigenvalue doesn’t vanish for all neighbors of \(\gamma _i\). Continuing this way since it is indecomposable, it would have to contain the whole component.
Thus the union of all ideals containing the part of \(\mh \) orthogonal to some component of a Dynkin diagram is a maximal ideal, and moreover all maximal ideals must be contained in one of these. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
If the Cartan matrix is indecomposable, there is a unique maximal ideal, and if we already know that the Cartan matrix comes from a simple Lie algebra, the quotient has to be that simple Lie algebra. The only information this
really gives us is knowing the quotient is finite-dimensional. However we will now prove that we should apriori expect the quotient to be finite dimensional.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-180"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6.14</span></span>. Consider the intersection of all the maximal ideals of \(\tilde {\mg }\). The quotient
by this is a semisimple Lie algebra, whose Cartan subalgebra and root system are exactly the ones used to construct it.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-181"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We can make a reduction to the case of an indecomposable Cartan matrix by observing that a splitting of the Cartan matrix splits everything involved \(\mh ,\tilde {\mg
},\tilde {\mn _+},\tilde {\mn _-}\). In this case when it is simple, if we can find a proper ideal with quotient finite dimensions \(&gt;1\), then the quotient is simple, and \(\mh \) is clearly self normalizing with \(\mg
_{\alpha }\) are its weight spaces, so we would be done. The quotient contains cannot be \(1\)-dimensional since if an ideal contains any of the \(e_i,f_i,h_i\), it must contain everything.
</p>

<p>
To prove finite-dimensionality, we first prove that when \(i\neq j\) and \(k\) is arbitrary, \(\ad e_k (\ad f_i)^{1-A_{ij}}(f_j)=0\). If \(k\neq i\), this is equal to \((\ad f_i)^{1-A_{ij}}\ad e_k(f_j) = (\ad
f_i)^{1-A_{ij}}\delta _{jk} h_j = (\ad f_i)^{-A_{ij}}A_{ij}f_i = 0\). If \(k = i\), \(e_i,f_i\) are part of an \(\msl _2\)-triple, so it follows from representation theory of \(\msl _2\) that \(\ad e_i (\ad
f_i)^{t}(f_j)= t(A_{ik}-t+1)(\ad f_i)^{t-1}(f_j) = 0\) by our choice of \(t\).
</p>

<p>
Now let \(J_+,J_-\) be the ideals of \(\tilde {\mn }_+,\tilde {\mn }_-\) generated by \((\ad f_i)^{1-A_{ij}}(f_j)\) and \((\ad e_i)^{1-A_{ij}}(e_j)\). By what was just shown, these are also ideals of \(\tilde
{\mg }\). Let \(J\) be their sum. I claim \(\tilde {\mg }/J\) is finite dimensional. Note that \(\ad e_i,\ad f_i\) act locally nilpotently on this, since they do on generators and \(\ad \) is a derivation. Now we still have for
each \(i\) the \(\msl _2\)-triple associated to \(e_i,f_i,h_i\). Then \(\tilde {\mg }/J\) is a sum of finite-dimensional modules for these \(\msl _2\)-triples since the \(e_i,f_i\) act locally nilpotently.
</p>

<p>
Thus we can consider the action of \(\tau _i\) from the representation theory of \(\msl _2\) which is an involution swapping positive and negative eigenspaces, implementing the Weyl group reflection of the corresponding simple
root on \(\ZZ \Pi \). We know that \(\tilde {\mg }_{k\gamma _i}\) is \(1\)-dimensional for \(k = \pm 1\) and \(0\)-dimensional for \(|k|&gt;1\) so the same is true for anything connected to these by the Weyl group
action. In particular all the roots of the corresponding root space have \(1\)-dimensional eigenspaces. Now consider \(\alpha \) in \(\QQ _+\coprod -\QQ _+\) that is not a multiple of a root. then the plane orthogonal to
\(\alpha \) isn’t contained in any of the boundaries of the Weyl chambers, and we can find \(\mu \in \ZZ \Pi \) orthogonal to it on the interior of a Weyl chamber. Then acting by an element of the Weyl group \(w\) we can
move \(\mu \) to the Weyl chamber corresponding to \(\Pi \). Then \(w(\mu )\) is a sum of positive multiples of the \(\gamma _i\) and since it is orthogonal to \(w(\alpha )\), \(w(\alpha )\) must contain both positive and
negative terms in its decomposition as \(\sum _i c_i \gamma _i\). But then \(0=\tilde {\mg }_{w(\alpha )} \cong \tilde {\mg }_{\alpha }\). Thus the quotient is finite-dimensional, and in fact we have proven \(J\) is
the maximal ideal. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
