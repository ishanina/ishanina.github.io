
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Lie Algebras</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Lie_Algebras_h-autopage-89"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Lie Algebras</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Nilpotent-Solvable-Lie-Algebras.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Nilpotent and Solvable Lie Algebras</a>
</p>


<p>
<a href="node-Semisimple-Lie-Algebras.html#autosec-36" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Semisimple Lie Algebras</a>
</p>


<p>
<a href="node-Poincare-Birkhoff-Witt.html#autosec-71" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Poincare&#x0301;-Birkhoff-Witt</a>
</p>


<p>
<a href="node-sl2k.html#autosec-81" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;\(\mathfrak {sl}_2k\)</a>
</p>


<p>
<a href="node-Root-Systems.html#autosec-90" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Root Systems</a>
</p>


<p>
<a href="node-Classification.html#autosec-118" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Classification</a>
</p>


<p>
<a href="node-Homological-Methods.html#autosec-183" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Homological Methods</a>
</p>


<p>
<a href="node-To-add.html#autosec-219" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;To add</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Lie Algebras</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-90"><span class="sectionnumber">5&#x2003;</span>Root Systems</h4>
<a id="Lie_Algebras_h-autopage-90"></a>
<a id="Lie_Algebras_h-autofile-5"></a>

<p>
First we will need to show that we get a root system from a semisimple Lie algebra. Let \(\mg \) be a fixed semisimple Lie algebra, \(\mh \) a Cartan subalgebra, \(\Delta \) the set of roots. \(\kappa \) induces a nondegenerate
symmetric bilinear form on \(\mh ^*\), and we will use \(\kappa \) to denote this as well. Let \((-)^*\) be the isomorphism between \(\mg \) and its dual induced by \(\kappa \).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-91"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.1</span></span><span class="amsthmnoteplain"> (\(\msl _2\)-triples)</span>. If \(\alpha \in \Delta
\), \(e \in \mg _{\alpha }\), \(f \in \mg _{-\alpha }\), then \([e,f] = \kappa (e,f)\alpha ^*\). Moreover, if \(\alpha \in \Delta , \kappa (\alpha ,\alpha ) \neq 0\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-92"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(\kappa (h,[e,f]) = \kappa (\ad h(e),f) = \alpha (h) \kappa (e,f) = \kappa (h,\alpha ^*\kappa (e,f))\), giving the first result since \(\kappa \) is
nondegenerate on \(\mh \). For the second, choose \(e,f\) so that \(\kappa (e,f)=1\). If \(\kappa (\alpha ,\alpha ) = \kappa (\alpha ,[e,f]) = \alpha ([e,f])\) is \(0\), then \(\alpha ^*,e,f\) form a subalgebra
presented by the relations \([e,f] = \alpha ^*,[\alpha ^*,e] = [\alpha ^*,f]=0\). This is a nilpotent subalgebra, so by Lie’s theorem, \(\alpha ^* = [e,f]\) must act nilpotently on \(\mg \). but it acts semisimply so
\(\ad \alpha ^*=0\), a contradiction. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Thus given \(\alpha \), we can pick \(e_{\alpha },f_{\alpha }\) so that \(\kappa (e_{\alpha },f_{\alpha }) = \frac 2 {\kappa (\alpha ,\alpha )}\). Then \([e_\alpha ,f_\alpha ] = h_\alpha = \frac
{2\alpha ^*}{\kappa (\alpha ,\alpha )}\). Then \(e_\alpha ,f_\alpha ,h_\alpha \) give an \(\msl _2\)-triple associated with \(\alpha \).
</p>

<p>
\(\msl _2\)-triples associated with \(\alpha \) are unique up to scaling \(f \mapsto \lambda f, e \mapsto \lambda ^{-1}e\). This follows from the next theorem.
</p>

<p>
For convenience, define \(\langle \alpha |\beta \rangle \) as \(2\frac {\kappa (\alpha ,\beta )}{\kappa (\alpha ,\alpha )}\). This notation is nonstandard, but \(|\) is being used to remind us that it is not
symmetric.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-93"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5.2</span></span>.
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(\dim \mg _\alpha = 1, \alpha \in \Delta \).
</p>


</li>
<li>


<p>
2. If \(\alpha , \beta \in \Delta \), then \(\beta +r\alpha , r \in k\) is a connected string where \(r\) are integers going from \(-p\) to \(q\) where \(p-q = \langle \alpha |\beta \rangle \)
</p>


</li>
<li>


<p>
3. If \(\alpha ,\beta ,\alpha +\beta \in \Delta \), then \([\mg _\alpha ,\mg _\beta ] =\mg _{\alpha +\beta } \).
</p>


</li>
<li>


<p>
4. \(\alpha \in \Delta \implies r\alpha \in \Delta \) iff \(r = \pm 1\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-94"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\): If \(e,e&apos;\) are nonzero in \(\mg _\alpha \), rescale them and choose an \(f\) in \(\mg _{-\alpha }\), so that \(e,f,[e,f]\) and \(e&apos;,f,[e&apos;,f]\)
extend to an \(\msl _2\)-triple. But \([e,f] = \frac {2\alpha ^*}{\kappa (\alpha ,\alpha )} = [e&apos;,f]\), so the representation theory of \(\msl _2\) tells us \(e = e&apos;\).
</p>

<p>
\((2\&amp;3)\): Consider \(M = \oplus _{r \in k} \mg _{\beta +r\alpha }\) as a representation of an \(\msl _2\)-triple associated to \(\alpha \). \(h_{\alpha }\mg _{\beta +r\alpha } = (\langle \alpha |\beta
\rangle +2r) \mg _\beta \) by definition of \(h_\alpha \), so \(M\) is irreducible by \((1)\) and Corollary <a href="node-sl2k.html#irreduciblecrit">4.3</a>. The results then follows from the representation theory of
\(\msl _2\).
</p>

<p>
\((4)\): This follows from the former observation that \(M\) is an irreducible \(\msl _2\) module for \(\beta =\alpha \) along with the fact that \([\mg _\alpha ,\mg _\alpha ]=0\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Because the (nonzero) roots are \(1\)-dimensional, and \(\mh \) is abelian, it follows that if \(a,b \in \mh \), then \(\kappa (a,b) = \sum _{\alpha \in \Delta }\alpha (a)\alpha (b)\).
</p>

<p>
\(\kappa \) restricted to the roots is really defined over \(\QQ \) and is positive definite.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-95"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5.3</span></span>.
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(\Delta \) spans \(\mh ^*\).
</p>


</li>
<li>


<p>
2. \(\kappa (\alpha ,\beta ) \in \QQ \) for \(\alpha ,\beta \in \Delta \).
</p>


</li>
<li>


<p>
3. \(\kappa |_{\mh ^*_\QQ }\) is positive definite.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-96"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\): If there is some \(h \in \mh \) such that \(\kappa (\alpha ^*,h) = \alpha (h)=0\) for all \(\alpha \in \Delta \), then \(h\) acts trivially on all \(\mg _\alpha
\), so must be \(0\).
</p>

<p>
\((2\&amp;3)\): Let \(\alpha ,\beta \in \Delta \). Then the formula for \(\kappa \) shows \(\frac {4}{\kappa (\alpha ,\alpha )} = \sum _{\lambda \in \Delta } \langle \alpha | \lambda \rangle \in \ZZ \)
so \(\kappa (\alpha ,\alpha ) \in \QQ \). Since \(\frac {\langle \alpha |\beta \rangle \kappa (\alpha ,\alpha )}{2} = \kappa (\alpha ,\beta )\), \(\kappa (\alpha ,\beta ) \in \QQ \). Finally the
formula for \(\kappa (\alpha ,\alpha )\) shows it is positive, since it is a sum of squares of rational numbers. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We have shown that \(h^*,\Delta \) is a root system, of which a definition will now be given. I think the right way to do this gives something called root datum, where you don’t identify the vector space with its dual via an inner
product.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-97"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5.4</span></span>. A <b>root system</b> is an vector space \(V\) with a conformal structure (i.e. an inner
product up to scaling) and a collection of nonzero elements (roots) \(\Delta \) spanning it, such that:
</p>
<ul style="list-style-type:none">


<li>
<p>
• If \(\alpha \in \Delta \), \(n\alpha \in \Delta \) iff \(n = \pm 1\).
</p>


</li>
<li>


<p>
• If \(\alpha , \beta \in \Delta \), then \(\beta +n\alpha ,n \in \ZZ \) is in \(\Delta \coprod 0\) for \(n\) in a connected string from \(-p\) to \(q\), where \(p-q = \frac {2(\alpha ,\beta )}{(\alpha ,\alpha
)}\).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
The second condition is called the string condition.
</p>

<p>
We denote \(\frac {2(\alpha ,\beta )}{(\alpha ,\alpha )}\) as \(\langle \alpha |\beta \rangle \) like before.
</p>

<p>
We would like to determine when a Lie algebra is simple rather than just semisimple. Let us consider a sum of two semisimple Lie algebras \(\mg ,\mg &apos;\), let \(\mh ,\mh &apos;\) be their Cartan subalgebras and let
\(\Delta ,\Delta &apos;\) be the roots. \(\mh \oplus \mh &apos;\) is a Cartan subalgebra and \(\Delta \coprod \Delta &apos;\) is the corresponding set of roots. Note that the splitting of \(\mg \oplus \mg &apos;\)
can be detected entirely through the root system. Namely \(\mh ,\mh &apos;\) orthogonally decompose the space, and \(\Delta , \Delta &apos;\) respects the decomposition. Conversely such a decomposition clearly indicates
how to decompose the Lie algebra. By the axioms of a root system, this is equivalent to finding a partition \(\Delta \coprod \Delta &apos;\) where \(a+b \notin \Delta \coprod \Delta &apos; \coprod 0\) if \(a \in
\Delta , b \in \Delta &apos;\). When a nontrivial partition exists, the root system is <b>indecomposable</b>.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-98"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.5</span></span>. \(\mg \) is simple iff its root system is indecomposable.
</p>

</li>

</ul>

</div>

<p>
We can easily check indecomposability as follows:
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-99"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.6</span></span>. <a id="indeccondition"></a> A root system \(\Delta \) is indecomposable iff any two
roots can be connected by a sequence such that for any neighboring pair in the sequence, the sum is in \(\Delta \coprod 0\).
</p>

</li>

</ul>

</div>

<p>
The existence of a root system is really equivalent to being semisimple. Now we will produce many examples of semisimple Lie algebras and hence root systems. To exhibit a Lie algebra as semisimple, it really suffices to provide a
root space decomposition.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-100"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5.7</span></span>. <a id="semisimplerecognition"></a> If \(\mg \) has a decomposition as \(\mh
\oplus \bigoplus _{\alpha \in \Delta }\mg _\alpha \), \(\Delta \subset \mh ^*\) such that
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(\Delta \) spans \(\mh ^*\), and \(\mh \) is nilpotent.
</p>


</li>
<li>


<p>
2. \(\mg _\alpha \) are weight spaces for the action of \(\mh \).
</p>


</li>
<li>


<p>
3. \(\alpha (a,\mg _{-\alpha })\neq 0\) for \(a \in \mg _\alpha \).
</p>
</li>
</ul>

<p>
Then \(\mg \) is semisimple, and \(\mh ,\Delta ,\mg _\alpha \) denote the usual things.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-101"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Consider an abelian ideal \(\ma \). It cannot be contained in \(\mh \), as \(\alpha \) of any element in \(\mh \) is nonzero for some \(\alpha \) by \((1)\), so \(\mg _\alpha
\) would also be in it. Consider any element \(a \in \ma -\mh \). By acting on it by elements of \(\mh \) many times, since \(\mh \) is nilpotent and \(\mg _\alpha \) are weight spaces for \(\mh \), we can assume its
component in \(\mh \) is \(0\) and its components in the \(\mg _\alpha \) are restricted to \(\alpha \) supported on a line. By further acting by an element in \(\mh \) for which \(\alpha \) doesn’t vanish, and taking linear
combinations, we can assume \(a\) is supported on \(\mg _\alpha \oplus \mg _{-\alpha }\). Suppose its component in \(\mg _\alpha \) is \(0\). Then by acting on \(a\) by an element of \(\mg _{-\alpha }\), by \((3)\)
we can produce an element \(b \in \ma \) supported in \(\mh \oplus \mg _{-2\alpha }\) that has \(\alpha \neq 0\), but this doesn’t commute with \(a\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Now we can construct the classical simple Lie algebras and their root decompositions. We will not show they are simple since it easily follows from our criteria.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-102"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.8</span></span><span class="amsthmnotedefinition"> (\(\msl _n\))</span>. The diagonal
matricies form an abelian subalgebra, with basis \(e_i = E_{i,i}-E_{i+1,i+1}\) for \(1 \leq i &lt; n\). Anything that commutes with \(e_i\) commutes with all diagonal matricies preserves their eigenspaces so must be
diagonal. \(\ad e_i(E_{jk})\) was computed before, and we see that \(E_{jk},j\neq k\) are the weight spaces with weight \(e_j^*-e_k^*\). The roots are then \(e_j^*-e_k^*\) for \(j\neq k\) both less than \(n\).
</p>

</li>

</ul>

</div>

<p>
Given a bilinear form \(B\) on a vector space \(V\), the set of endomorphisms \(A\) such that \(B(Aa,b)+B(a,Ab)=0\) is a Lie algebra. When \(B\) is a nondegenerate symmetric bilinear form on a vector space of dimension \(n\),
this is called \(\so _n\), and when it is a nondegenerate alternating biliner form on a vector space of dimension \(2n\), this is called \(\msp _{2n}\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-103"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.9</span></span><span class="amsthmnotedefinition"> (\(\so _{n}\))</span>. Here
\(n\geq 3\). Choose a basis so that \(B\) is the matrix that is \(1\)s on the antidiagonal. Then \(\so _n\) consists of all matrices that are anti symmetric with respect to flipping across the antidiagonal. A Cartan subalgebra
consists of all matrices that are diagonal, a basis given by \(e_i = E_{ii}-E_{n+1-i,n+1-i}\) for \(1 \leq i \leq \frac n 2\). The root spaces are given by \(E_{ij}-E_{n+1-i,n+1-j}\), corresponding to the roots
\(e_i^*-e_{j}^*\), where \(e_j^*\) really means \(-e_{n+1-j}^*\) when \(j&gt;\frac n 2\) and \(0\) when \(j=\frac n 2\). When \(n\) is even, these then give \(\pm (e_i^* + e_j^*), e_i^*-e_j^*\) for \(i\neq j\)
at most \(\frac {n}{2}\), and when \(n\) is odd, they give \(\pm (e_i^* + e_j^*),e_i^*-e_j^*, \pm e_i^*\) for \(i \neq j\) at most \(\frac n 2\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-104"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.10</span></span><span class="amsthmnotedefinition"> (\(\msp _{2n}\))</span>. Here
\(n\geq 1\). We can choose a basis so the bilinear form looks like \(1\) on the upper half of the antidiagonal and \(-1\) on the other half. We can split any matrix in \(\msp _{2n}\) into four quadrants like \(\begin {bmatrix}
a&amp;b\\c&amp;d \end {bmatrix}\), and if \(a&apos;\) denotes the reflection across the antidiagonal, the conditions are that \(a&apos;=-d,b&apos;=b,c&apos;=c\). Again the diagonal matrices form a Cartan subalgebra,
with bases \(e_i = E_{ii}-E_{n+1-i,n+1-i}\). Now there are different kinds of rootspaces. One kind is \(E_{ij}-E_{n+1-i,n+1-j}\) where \(i,j\) is in the upper left quadrant, which gives \(e_i^*-e_j^*\). Another is
\(E_{ij}+E_{n+1-i,n+1-j}\) where \(i,j\) is in the upper left half of either the top right or bottom left quadrant, giving \(\pm (e_i^* + e_j^*)\). The last kind is \(E_{ij}\) where \(i,j\) lies on the antidiagonal, giving
\(\pm 2e_i^*\).
</p>

</li>

</ul>

</div>

<p>
There is another naming scheme related to Dynkin diagrams: \(A_n = \msl _{n+1}, B_n = \so _{2n+1}, C_n = \msp _{2n}, D_n = \so _{2n} (n&gt;1)\).
</p>

<p>
The Killing forms are easy to understand up to scalar multiplication:
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-105"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.11</span></span>. Any nontrivial invariant bilinear form on a simple Lie algebra is nondegenerate. Moreover
any invariant nondegenerate bilinear form on a simple Lie algebra is unique up to scalar multiplication. In particular it must be proportional to \(\kappa \).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-106"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> An invariant bilinear form is a map of \(\mg \)-modules \(\mg \otimes \mg \to k\). \(\Hom (\mg \otimes \mg ,k) = \Hom (\mg ,\mg ^*)\) which is one-dimensional since
\(\mg \) is simple. The result follows since \(\kappa \) is an example of a nontrivlal form. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Thus the trace form of the standard representation is proportional to \(\kappa \). Now let’s study root systems in general. There is an analog of the previous lemma for root systems.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-107"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.12</span></span>. An indecomposable root system has a unique up to scalars inner product making it a
root system. Moreover, if \((\alpha ,\alpha ) \in \QQ \) for some \(\alpha \in \Delta \), it is true for all \((\alpha ,\beta )\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-108"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Given \((\alpha ,\alpha )\), the string condition lets us compute \((\alpha ,\beta )\) whenever \(\alpha +\beta \in \Delta \), which then lets us compute \((\beta
,\beta )\). Continuing this way via Lemma <a href="node-Root-Systems.html#indeccondition">5.6</a>, we can recover the rest of the inner product showing it is determined by \((\alpha ,\alpha )\) and moreover in
\(\QQ \) if \((\alpha ,\alpha )\) is. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Thus we can really choose to work over \(\QQ \) or \(\RR \) and it makes no difference. \(\ZZ \Delta \) is a finitely generated subgroup of a rational vector space, so is a lattice called the <b>root lattice</b>.
</p>

<p>
Let \(E_r\) be the lattice consisting of linear combinations \(a_ie_I\) where either \(a_i \in \ZZ \) or \(a_i\in \ZZ +\frac 1 2\) for all \(i\) and \(\sum _i a_i \in 2\ZZ \).
</p>

<p>
A lattice is <b>even</b> if \((a,b) \in \ZZ \) for any \(a,b\) in it. The following is straightforward.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-109"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">5.13</span></span>. \(E_r\) is even iff \(8|r\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-110"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5.14</span></span>. Given an even lattice such that \(\Delta \), the set of elements in the lattice such that
\((a,a) =2\) span the vector space, \(\Delta \) is a root system.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-111"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> One really only needs to check the string property. Since \(0 \leq (\alpha -\beta ,\alpha -\beta ) = (\alpha ,\alpha )+(\beta ,\beta )-2(\alpha ,\beta )\), we see
that \((\alpha ,\beta ) \leq 2\). One can calculate in each case that the string condition holds. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-112"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.15</span></span><span class="amsthmnotedefinition"> (\(E_8\))</span>. The theorem
implies \(E_8\) is a root system, which can be checked is indecomposable. It can be described as the root system consisting of \(\pm (e_i + e_j), \pm e_i \mp e_j\) and things of the form \(\frac {1}{2}(e_1\pm \dots
e_8)\) where there are an even number of minus signs.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-113"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.16</span></span><span class="amsthmnotedefinition"> (\(E_7\))</span>. We can construct
another called \(E_7\) as a sub-root system as follows: consider the vectors in \(E_8\) orthogonal to the constant vector with entry \(\frac 1 2\). It is still even, so a root system. These are of the form \(e_i-e_j, i \neq j\)
and things of the form \(\frac {1}{2}(e_1\pm \dots e_8)\) where the number of minus signs is divisible by four.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-114"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.17</span></span><span class="amsthmnotedefinition"> (\(E_6\))</span>. Finally, \(E_6\)
can be constructed as the root system consisting of vectors in \(E_7\) that are orthogonal to \(e_7+e_8\). It is still even, so a root system. It contains \(e_i-e_j\) such that if either of \(\{i,j\}\cap \{7,8\}\) is \(\{7,8\}\) or
\(\phi \), as well as things of the form \(\frac {1}{2}(e_1\pm \dots e_8)\) where the number of minus signs is divisible by four, and \(e_7,e_8\) have opposite signs.
</p>

</li>

</ul>

</div>

<p>
There are two more exceptional root systems, which have a different origin.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-115"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.18</span></span><span class="amsthmnotedefinition"> (\(F_4\))</span>. Consider the
vector space generated by \(e_1,e_2,e_3,e_4\) and consider the lattice consisting of elements of the form \(\sum _i a_i e_i\) where either \(a_i \in \ZZ \) or all \(a_i \in \ZZ +\frac 1 2\). The elements of the lattice
such that \((x,x) = 1,2\) form an indecomposable root system. More explicitly, the roots are \(\pm e_i, \pm (e_i + e_j), e_i-e_j, \pm \frac 1 2 (e_1\pm \dots e_4)\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-116"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">5.19</span></span><span class="amsthmnotedefinition"> (\(G_2\))</span>. Here the lattice
is the same as that for \(A_2\), namely all elements \(a_1e_1+a_2e_2+a_3e_3\) such that \(\sum _i a_i = 0\), except we take elements with \((x,x) = 2,6\). This is an indecomposable root system whose elements are \(\pm
(e_i + e_j), e_i - e_j, \pm (2e_i-e_j-e_k)\).
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
