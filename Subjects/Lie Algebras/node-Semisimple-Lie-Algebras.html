
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Lie Algebras</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Lie_Algebras_h-autopage-35"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Lie Algebras</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Nilpotent-Solvable-Lie-Algebras.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Nilpotent and Solvable Lie Algebras</a>
</p>


<p>
<a href="node-Semisimple-Lie-Algebras.html#autosec-36" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Semisimple Lie Algebras</a>
</p>


<p>
<a href="node-Poincare-Birkhoff-Witt.html#autosec-71" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Poincare&#x0301;-Birkhoff-Witt</a>
</p>


<p>
<a href="node-sl2k.html#autosec-81" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;\(\mathfrak {sl}_2k\)</a>
</p>


<p>
<a href="node-Root-Systems.html#autosec-90" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Root Systems</a>
</p>


<p>
<a href="node-Classification.html#autosec-118" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Classification</a>
</p>


<p>
<a href="node-Homological-Methods.html#autosec-183" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Homological Methods</a>
</p>


<p>
<a href="node-To-add.html#autosec-219" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;To add</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Lie Algebras</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-36"><span class="sectionnumber">2&#x2003;</span>Semisimple Lie Algebras</h4>
<a id="Lie_Algebras_h-autopage-36"></a>
<a id="Lie_Algebras_h-autofile-2"></a>

<p>
Given a representation \(V\) of a Lie Algebra \(\mg \), the <b>trace form</b> is \((a,b)_V = \tr _V ab\). One easily checks it is symmetric \((a,b) = (b,a)\) and invariant \(([a,b],c) = (a,[b,c])\). The trace form on
the adjoint representation is called the <b>Killing form</b>, denoted \(\kappa \).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-37"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.1</span></span>. If \(\ma \) is an ideal of \(\mg \), then \(\kappa _{\mg }|_{\ma } =\kappa _{\ma }\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-38"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(\ad b\ad a, a\in \ma \) has image in \(\ma \), so its trace is equal to its trace on \(\ma \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Weights are related to roots by rational multiples on certain parts of the Cartan subalgebra.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-39"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.2</span></span><span class="amsthmnoteplain"> (Cartan’s Lemma)</span>. Let \(e \in \mg _a, f \in
\mg _{-a}, [e,f]=h\), and suppose that \(V_{\lambda } \neq 0\). Then \(\lambda (h) = r \alpha (h)\), where \(r \in \QQ \) doesn’t depend on \(h\).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-40"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Consider \(W=\oplus _n V_{\lambda +n\alpha }\), upon which \(e,f,h\) act. \(h\)’s trace is \(0\) on this as it is a commutator. The trace is \(\sum _n (\lambda +n\alpha
)(h)\dim V_{\lambda +n\alpha }=0\), giving the relation. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-41"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.3</span></span><span class="amsthmnoteplain"> (Cartan’s Criterion)</span>. For a subalgebra of \(\gl
_V\), the following are equivalent:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \((\mg ,[\mg ,\mg ])_V= 0\)
</p>


</li>
<li>


<p>
2. \(([\mg ,\mg ],[\mg ,\mg ])_V = 0\)
</p>


</li>
<li>


<p>
3. \(\mg \) is solvable.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-42"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\implies (2)\) is clear. \((3) \implies (1)\) follows from Lie’s theorem, since the product of two elements of that form is strictly uppertriangular.
</p>

<p>
\((2) \implies (3)\): If not, then there is a point in the derived series giving a subalgebra \(\mg &apos;\) such that \([\mg &apos;,\mg &apos;]= \mg &apos;\). If \(\mh \) is its Cartan subalgebra, then \(\mh = \sum _i
[\mg &apos;_{\alpha },\mg &apos;_{-\alpha }]\). Choose an \(h = [e,f]\), and observe \(0 = (h,h)_V = \tr h^2 = \sum _{\lambda } \lambda (h)^2 \dim V_{\lambda }\). By the previous lemma, this is a
nonnegative rational multiple of \(\alpha (h)\), so we must have \(\lambda (h)=0\) and \(V = V_0\). But then everything acts nilpotently, so by Engel’s theorem \(\mg &apos;\) is nilpotent, a contradiction. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-43"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">2.4</span></span>. \(\mg \) is solvable iff \(\kappa (\mg ,[\mg ,\mg ]) =0\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-44"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.5</span></span>. The radical of \(\mg \), \(\rad (\mg )\) is the largest solvable ideal.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-45"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.6</span></span>. \(\mg \) is semisimple if \(\rad (\mg ) = 0\).
</p>

</li>

</ul>

</div>

<p>
Equivalently, there are no nontrivial abelian ideals. Note that a simple Lie algebra is clearly semisimple.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-46"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">2.7</span></span>. If \(\mg \) is semisimple the trace form of any or every faithful representation \(V\) is
nondegenerate.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-47"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By Cartan’s criterion, the nullspace of \((a,b)_V\) is a solvable ideal, so is \(0\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-48"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">2.8</span></span>. \(\mg \) is semisimple iff its Killing form is nondegenerate.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-49"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> If \(\mg \) is not semisimple, it has a nontrivial abelian ideal, which is in the kernel of \(\kappa \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-50"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.9</span></span>. The Killing form of a semisimple Lie algebra \(\mg \) is nondegenerate when restricted
to any ideal \(\ma \). A Lie algebra splits as a sum of simple Lie algebras.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-51"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(\ma \cap \ma ^{\perp }\) is a solvable ideal by Cartan’s criterion, so is \(0\). Thus \(\mg = \ma \oplus \ma ^{\perp }\) as a Lie algebra. Iterating gives the last assertion.
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-52"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">2.10</span></span>. \(\gl _n\) is \(k I \oplus \msl _n\) where \(\msl _n\) is semisimple. To
see this, let \(E_{ij}\) be the matrix \((E_{ij})_{kl} = \delta _{ik}\delta _{jl}\). We can compute \(\ad (E_{ij})E_{kl} = E_{il}\delta _{jk} -E_{kj}\delta _{il}\). Thus \(\ad (E_{mn})\ad (E_{ij})E_{kl}
= E_{ml}\delta _{jk}\delta _{ni} - E_{mj} \delta _{il}\delta _{nk} - E_{in} \delta _{jk}\delta _{lm} + E_{kn}\delta _{il}\delta _{jm}\), so taking trace, we get \(2n\delta _{ni}\delta _{mj} -
2\delta _{mn}\delta _{ij}\). By linearity, the Killing form is \((a,b) = 2n\tr ab-2\tr a\tr b\). From this we can see that it is nondegenerate on \(\msl _n\), and null on \(k I\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-53"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.11</span></span>. Given a faithful irreducible representation of \(\mg \) into \(V\) either \(\mg \) is
semisimple, or it is \(kI\) summed with something semisimple.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-54"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> If it isn’t semisimple, by Lie’s theorem, the radical has an nonzero weight space, which is invariant by Lie’s lemma. By irreducibility, it must be all of \(V\). Since the
representation is faithful, the radical must be \(kI\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-55"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.12</span></span>. A Lie algebra is <b>reductive</b> if its adjoint representation is completely reducible.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-56"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.13</span></span>. A Lie algebra is reductive iff it is a sum of a semisimple Lie algebra and an abelian one.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-57"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The irreducible summands of a reductive Lie algebra are ideals, so the Lie algebra splits into a sum of Lie algebras where the adjoint representation is both completely reducible
and irreducible. If the center of such an algebra is trivial, by the above theorem, it is semisimple (in fact simple). Otherwise, since the center is a summand of the adjoint representation, it is everything, and the algebra is abelian.
The other direction has already been proven. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We will now see that semisimple Lie algebras are the ones having a semisimple representation theory. To see it is a necessary condition, observe that the adjoint representation must be irreducible so it is reductive, and it can’t have
an abelian part since abelian Lie algebras aren’t semisimple.
</p>

<p>
Recall that representations of \(\mg \) are the same as representations of \(U(\mg )\). \(U(\mg )\) is a filtered cocommutative Hopf algebra, where the coproduct is \(x \mapsto 1 \otimes x +x\otimes 1\), and the antipode is
\(x \mapsto -x\) on \(\mg \subset U(\mg )\). It is the algebra of differential operators on the associated formal group. \(U\) of a free Lie algebra is a tensor algebra, \(U(\mg \oplus \mh ) = U(\mg ) \otimes _k U(\mh )\),
and \(U(k) = k[x]\).
</p>

<p>
The argument that representations are semisimple is similar to the argument for compact Lie group. There, via averaging over a bi-invariant metric, one makes any representation unitary, after which one can produce orthogonal
complements to subrepresentations. Here the bi-invariant metric becomes the Killing form, and it hard to average, but we still have an infinitesmal version of averaging, namely the Laplacian operator, which here is called the
Casimir element.
</p>

<p>
Any symmetric invariant form \(B\) on \(\mg \) can be thought of as a map of \(\mg \)-modules \(\mg \otimes \mg \to k\). Nondegeneracy means the adjoint \(\mg \to \mg ^*\) is an isomorphism. Via this identification, the
identity \(\mg \to \mg \) is adjoint to a map \(k \to \mg \otimes \mg \), the image of \(1\) being the <b>Casimir element</b> \(L_B\). Alternatively it is adjoint to the map \(B\). Note that symmetry of the bilinear form
implies that \(L_B\) is invariant under swapping the two terms. We can also view \(L\) in \(U(\mg )\) via the multiplication map \(\mg \otimes \mg \to U(\mg )\). It is central in \(U(\mg )\) since the map \(k \to \mg
\otimes \mg \) is a map of \(\mg \)-modules.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-58"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.14</span></span>. The category of f.d representations of \(\mg \) is semisimple iff \(\Ext ^1(k,V)=0\) for
all irreducible \(V\), where \(k\) is the tensor unit.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-59"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We can identify \(\Hom _{\mg }(V,W)\) with \(\Hom _{\mg }(k,W\otimes V^*)\). \((-)\otimes V^*\) is exact and preserves injectives, so we can derive the isomorphism to
\(\Ext \). Semisimplicity is equivalent to \(\Ext ^1(V,W)=0\). So we only need \(\Ext ^1(k,V) = 0\) for all \(V\), but the long exact sequence on \(\Ext \) shows it suffices to prove it for irreducible \(V\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-60"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.15</span></span><span class="amsthmnoteplain"> (Weyl Complete Reducability)</span>. For a
semisimple \(\mg \), any finite-dimensional representation of \(U(\mg )\) is semisimple.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-61"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We need to show that a short exact sequence \(0 \to V \to W \to k \to 0\) splits when \(V\) is irreducible. WLOG \(V\) is faithful by passing to a quotient of \(\mg \).
\(L_V\) is \(0\) on \(k\), and \(\tr _{L_V}(V) = \dim \mg \neq 0\). So \(L_V\) is nonzero, and thus an isomorphism by Schur’s Lemma. An element in the kernel of \(L_W\) gives a splitting. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
A remark about the proof: we should expect \(k\) to be the only irreducible representation for which \(L\) acts as \(0\) since every irrep embeds in \(L^2\), where \(L\) is literally the Laplacian, and the only harmonic functions
are constant.
</p>

<p>
This has an interpretation in terms of derivations. A <b>derivation</b> \(d:\mg \to M\) is a map such that \(d[a,b] = adb-bda\) It is the same as a \(1\)-cocycle in the Chevalley-Eilenberg complex (i.e the de Rham complex)
of \(M\). A \(1\)-boundary is an <b>inner derivation</b> or a map of the form \(dx = xa, a \in M\). We can write these groups as \(\Der (\mg ,M)\) and \(\Ider (\mg ,M)\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-62"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">2.16</span></span>. Every derivation of a semisimple Lie into a finite-dimensional module is inner.
</p>

</li>

</ul>

</div>

<p>
A special case of this is the Lie algebra of derivations of \(\mg \) into \(\mg \). Here is an alternate proof of the fact in that case:
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-63"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.17</span></span>. If \(\mg \) is semisimple, the map \(\ad :   \mg \to \Der (\mg )\) is an
isomorphism.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-64"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The restriction of the tautological representation \(\Der (\mg )\) to \(\mg \) is the adjoint representation. Since \(\kappa \) is nondegenerate, \(\Der (\mg )\) splits as \(\ad
\mg \oplus \ad \mg ^{\perp }\). If \(D \in \ad \mg ^{\perp }\) then \(0 = [D,\ad a] = \ad Da\), so \(Da \in Z(\mg ) =0\) showing \(D = 0\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-65"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.18</span></span>. An <b>abstract Jordan decomposition</b> of \(a\) is a decomposition
\(a=a_s+a_n\) where \([a_s,a_n]=0\) and \(\ad a_s,\ad a_n\) are semisimple and nilpotent.
</p>

</li>

</ul>

</div>

<p>
They are unique iff \(Z(\mg )=0\), because that is the kernel of map \(\ad \), and we know Jordan decompositions to be unique in \(\gl _V\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-66"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.19</span></span>. Abstract Jordan decompositions exist for reductive Lie algebras.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-67"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It suffices to assume \(\mg \) semisimple. \(A=\ad g\) has a Jordan decomposition as an endomorphism, so it suffices to show that \(A_s\) is a derivation. By linearity it suffices
to do check this for elements in a root space \(x,y\), with eigenvalues \(\lambda ,\mu \) for \(A\). Indeed, \(A_s[x,y] = (\mu +\lambda )[x,y] =[\lambda x,y] + [x,\mu y] = [A_sx,y] + [x,A_sy]\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Now we can better understand the Killing forms of a semisimple Lie algebra.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Lie_Algebras_h-autopage-68"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.20</span></span>. Let \(\kappa \) be the killing form on \(\mg \), a semisimple Lie algebra, and let \(\mh
\) be a Cartan subalgebra.
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(\kappa (\mg _{\alpha },\mg _{\beta })=0\) unless \(\alpha +\beta =0\).
</p>


</li>
<li>


<p>
2. \(\kappa _{\mg _{\alpha }+ \mg _{-\alpha }}\) is nondegenerate.
</p>


</li>
<li>


<p>
3. \(\mh \) is abelian
</p>


</li>
<li>


<p>
4. \(\mh \) consists of semisimple elements
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Lie_Algebras_h-autopage-69"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \((1)\): This is immediate from Theorem <a href="node-Nilpotent-Solvable-Lie-Algebras.html#weightstheorem">1.15</a> by looking at how \(\ad \) acts on the root
spaces.
</p>

<p>
\((2)\): This follows from \((1)\) and the fact that \(\kappa \) is nondegenerate.
</p>

<p>
\((3)\): Cartan’s criterion shows that \(\kappa (\mh ,[\mh ,\mh ])= 0\), but along with \((2)\) on \(\mg _0=\mh \) this means \([\mh ,\mh ]=0\).
</p>

<p>
\((4)\): \(\mh _s \subset \mh \) because of how \(\ad \mh _s\) behaves, but note that by \((3)\), \(\kappa (h,h&apos;) = \kappa (h_s,h&apos;)\) for \(h,h&apos; \in \mh \). Thus by \((2)\) on \(\mg _0=\mh \),
\(h = h_s\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
