
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Simplicial</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Simplicial_h-autopage-662"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s Writings">Back to Ishan Levy’s Writings</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Simplicial</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Introduction.html#autosec-6" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Technical Things</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-36" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Generators of anodyne morphisms</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-54" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Enriched Categories</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-68" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Basics of Simplicial Sets</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-99" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Left fibration characterization of Kan fibrations</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-127" class="tocsubsection" >
<span class="sectionnumber">2.5</span>&#x2003;Cartesian Morphisms</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-156" class="tocsubsection" >
<span class="sectionnumber">2.6</span>&#x2003;Minimal Inner Fibrations</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-173" class="tocsubsection" >
<span class="sectionnumber">2.7</span>&#x2003;Trees</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-207" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Kan Fibrations</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-230" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Minimal fibrations</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-243" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Equivalence of Quillen and Serre model structures</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-262" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Model Categories</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-313" class="tocsubsection" >
<span class="sectionnumber">4.1</span>&#x2003;Homotopy category of a model category</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-411" class="tocsubsection" >
<span class="sectionnumber">4.2</span>&#x2003;Combinatorial Model Categories</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-443" class="tocsubsection" >
<span class="sectionnumber">4.3</span>&#x2003;Derived Functors</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-478" class="tocsubsection" >
<span class="sectionnumber">4.4</span>&#x2003;Enriched and Simplicial model categories</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-510" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Some Important Model Structures</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-511" class="tocsubsection" >
<span class="sectionnumber">5.1</span>&#x2003;Model structure on \(S\)-enriched categories</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-552" class="tocsubsection" >
<span class="sectionnumber">5.2</span>&#x2003;Diagram model structures and homotopy limits</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-595" class="tocsubsection" >
<span class="sectionnumber">5.3</span>&#x2003;Reedy model structures</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-613" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;\(\Pi _1\) and Simplicial abelian groups</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-614" class="tocsubsection" >
<span class="sectionnumber">6.1</span>&#x2003;Fundamental Groupoid</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-627" class="tocsubsection" >
<span class="sectionnumber">6.2</span>&#x2003;Local Systems and Covering Spaces</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-628" class="tocsubsection" >
<span class="sectionnumber">6.3</span>&#x2003;Simpicial objects in Abelian Categories</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-664" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bisimplicial Sets</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-681" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Bisimplicial objects in an abelian category</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-701" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Model structures</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-727" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Bousfield-Friedlander</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-763" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Theorem B and Group Completion</a>
</p>


<p>
<a href="node-Some-Classical-Homotopy-Theory.html#autosec-787" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Some Classical Homotopy Theory</a>
</p>


<p>
<a href="node-Some-Classical-Homotopy-Theory.html#autosec-788" class="tocsubsection" >
<span class="sectionnumber">8.1</span>&#x2003;The Hurewicz Map</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-841" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Models for Homotopy Types</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-842" class="tocsubsection" >
<span class="sectionnumber">9.1</span>&#x2003;Test Categories</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-875" class="tocsubsection" >
<span class="sectionnumber">9.2</span>&#x2003;Basics of Cubical Sets</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-898" class="tocsubsection" >
<span class="sectionnumber">9.3</span>&#x2003;Cisinski model structures</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-971" class="tocsubsection" >
<span class="sectionnumber">9.4</span>&#x2003;Colimits in Cisinski model structures</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-1010" class="tocsubsection" >
<span class="sectionnumber">9.5</span>&#x2003;Weak equivalence classes of functors</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-1043" class="tocsubsection" >
<span class="sectionnumber">9.6</span>&#x2003;Model structure on Cubical Sets</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1072" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Simplicial localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1073" class="tocsubsection" >
<span class="sectionnumber">10.1</span>&#x2003;Free Categories and Localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1087" class="tocsubsection" >
<span class="sectionnumber">10.2</span>&#x2003;Dwyer-Kan Localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1099" class="tocsubsection" >
<span class="sectionnumber">10.3</span>&#x2003;Reduction to Cubical Sets</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Simplicial</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)
</div>

<p>
<!--................................-->
<h4 id="autosec-664"><span class="sectionnumber">7&#x2003;</span>Bisimplicial Sets</h4>
<a id="Simplicial_h-autopage-664"></a>
<a id="Simplicial_h-autofile-7"></a>

<p>
A bisimplicial object is a simplical simplicial object.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-665"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">7.0.1</span></span>. We can consider \(\Delta ^{k,l}\), the bisimplicial set given by the
simplicial sets \(\cup _{n \to k}\Delta ^l\). This is the functor corepresented in \(\Delta \times \Delta \) by \((k,l)\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-666"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">7.0.2</span></span>. Given a monoidal category, the <b>external product</b> of two simplicial
objects \(X\tilde {\otimes } Y\) is the one given by \((X\tilde {\otimes } Y)(n,m)=X_n\otimes Y_m\). For simplicial sets, the product is a monoidal product, and in this case we denote the external product \(X\tilde
{\times }Y\). The <b>diagonal</b> simplicial object of a bisimplicial object \(X\) is \(X(n,n)\).
</p>

</li>

</ul>

</div>

<p>
We define the <b>vertical simplicial object</b> of \(X(n,m)\) to be \(X_n = X(n,*)\). A morphism \(\theta :m\to n\) gives rise to a diagram of simplicial sets
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-82"
    class="lateximagesource"
><!--
           1×θ∗
Xn × ∆m           Xn × ∆n
   θ∗ ×1

Xm × ∆m
--><img
    src="Simplicial_h-images/image-82.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
There is a map \(\gamma _n:X_n\times \Delta ^n\to d(X)\) given by sending \(x,r \mapsto r^*(x)\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-670"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.1</span></span>. <a id="diagonalcoeq"></a> The map \(\coprod _{m\to n} X_n\times \Delta
^m\rightrightarrows \coprod _nX_n\times \Delta ^n\xrightarrow {\gamma } d(X)\) is a coequalizer diagram.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-671"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> On \(r\)-simplices, this coequalizer computes \(\colim _{\Delta ^{op}/{[r]}}(X_n)_r\), which is just \((X_{r})_r\) since there is a terminal object. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Lemma <a href="node-Bisimplicial-Sets.html#diagonalcoeq">7.1</a> gives a natural filtration on \(d(X)\) coming from the image of \(\coprod _{n\leq p}X_n\times \Delta ^n\).
</p>

<p>
Moreover, the degenerate part of \(X_{p+1}\) with respect to the horizonal simplicial structure is filtered by \(s_{[r]}X_p\) which is the union of \(s_iX_p\) for \(i\leq r\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-672"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">7.2</span></span>. <a id="diagweakeq"></a> Let \(X\to Y\) be a map of bisimplicial sets that is a weak
equivalence on the vertical simplicial sets. Then \(d(X) \to d(Y)\) is a weak equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-673"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> There are pushout diagrams
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-83"
      class="lateximagesource"
><!--
              sr+1
s[r] Xp−1             s[r] Xp

            sr+1
  Xp                 s[r+1] Xp
--><img
    src="Simplicial_h-images/image-83.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span> <span
    id="lateximage-Simplicial_h-84"
    class="lateximagesource"
><!--
(s[p] Xp × ∆p+1 ) ∪ (Xp+1 × ∂∆p+1 )    d(X)(p)


          Xp+1 × ∆p+1                 d(X)(p+1)
--><img
      src="Simplicial_h-images/image-84.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
which are homotopy pushouts since the indicated arrows are injections. Thus by induction it follows that the map \(d(X)^{(p)}\to d(Y)^{(p)}\) is an equivalence for all \(p\), and taking the union, we are done. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Let \(D\) be a category with coproducts, and \(C\) any small category. Given a functor \(f:C \to D\), there is a simplicial object \(E_Cf\) whose \(n\)-simplices are \(\coprod _{\sigma :[n] \to C}f(\sigma (0))\) called the
<b>translation object</b>.
</p>

<p>
Given a composite \(C&apos; \xrightarrow {g} C\xrightarrow {f} D\), there is a natural map \(E_{gf} \to E_f\). Moreover, given a natural transformation \(f\to g\), there is an associated map \(E_f\to E_g\).
</p>

<p>
Finally, observe that the simplicial object corresponding to the composite \(C\times C&apos; \xrightarrow {\pi } C\xrightarrow {f} D\) is \(E_f\otimes BC&apos;\) where \(\otimes \) is the usual tensoring of simplicial
objects by the simplicial set \(BC&apos;\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-679"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.3</span></span>. We define the <b>diagonal homotopy colimit</b> of \(f:C\to \SSet \) to be
\(d(E_Cf)\) viewed as a bisimplicial set (this is nonstandard). We will later show this is equivalent to the usual homotopy colimit, and can be thought of as a bar resolution of the functor \(f\).
</p>

</li>

</ul>

</div>

<p>
In this case, the \(n\)-simplices of \(E_Cf\) are the nerve of a category \(E_Cf_n\) whose objects are an object \(c \in C\) and an \(n\)-simplex in \(f(c)\). This category is called the <b>translation category</b>.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-680"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">7.3.1</span></span>. Let \(G\) be a group acting on a simplicial set \(X\). Then the homotopy
colimit in this sense agrees with the Borel construction \(EG\times _GX\). This sends the equivalence class \([e\to g_1\to g_2g_1\to \dots ,x]\) to \(x\to g_1x \to \dots \).
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-681"><span class="sectionnumber">7.1&#x2003;</span>Bisimplicial objects in an abelian category</h5>
<a id="Simplicial_h-autopage-681"></a>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-682"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.4</span></span>. <a id="canweakeqtermbisimp"></a> Let \(D\) be an abelian category, and let \(f:I \to
D\) be a functor such that \(I\) has a specified terminal object \(t\). Then there is a canonical homotopy equivalence \(Ef \cong K(A_t,0)\), given on \(n\)-simplices on each term by \(f\) applied to the unique map to \(t\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-683"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The identity of \(I\) is homotopic to the constant map \(t\), so applying this to the translation object construction, we get that \(Ef\) is simplicial homotopic to
\(K(A_t,0)\otimes BI \cong K(A_t,0)\) since \(I\) is contractible. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
By the Dold-Kan correspondence, bisimplicial objects in an abelian category are the same as chain complexes of chain complex \(C_{p,q}\) with a horizontal and vertical differential \(\partial _h\) and \(\partial _v\) that
commute. By changing \(\partial _v\) to \((-1)^{p} \partial _v\), they anti commute and form a double complex. This gives an equivalence between first quadrant double complexes and bisimplicial objects.
</p>

<p>
Filtering a double complex in the horizontal direction gives a spectral sequence whose \(E_2\)-term is \(H_p(H_q C_{**})\), converging to \(H_{p+q}(\Tot (C_{**}))\) with a finite filtration in each degree. It follows that the
homology of \(\Tot (C_{**})\) is only dependent on the weak equivalence classes of the chain complexes in the vertical direction. There is also a diagonal simplicial chain complex \(d(C)\) corresponding to the diagonal simplicial
set. It is more convenient to work with the Moore complexes, since then \(d(C)\) is just given by \(C_{nn}\) with the Moore differential \(\sum _i (-1)^i \partial ^h_i\partial ^v_i\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-684"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">7.5</span></span><span class="amsthmnoteplain"> (Eilenberg-Zilber)</span>. For a bisimplicial object,
there is a natural homotopy equivalence \(d(C) \cong \Tot (C)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-685"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It suffices to work with the Moore complexes by Proposition <a href="node-Pi-_1-Simplicial-abelian-groups.html#moorenormalizedhomotopyeq">6.5</a>. There is a map
\(f_{p,q}:C_{n,n} \to C_{p,q}\) where \(p+q=n\) given by \(\partial ^h_{p+1}\dots \partial ^h_{n}\partial ^v_0\dots \partial ^v_0\). Consider the <b>Alexander-Whitney map</b> given by \(\sum
_{p+q=n}f_{p,q}:    dC_n\to \Tot (C)_n\). This gives a chain map \(\Tot (C_{**}) \to D(C_{**})\). The <b>Eilenberg-Zilber map</b> in the other direction is given from \(C_{p,q} \to C_{n,n}\) by \(\sum _{\mu }
(-1)^\mu s^h_{\mu (n)}\dots s^h_{\mu (p+1)}s^v_{\mu (p)}\dots s^v_{\mu (1)}\) where \(\mu \) ranges over the set \(S_{p,q}\) of \((p,q)\) shuffles. One can check that the Eilenberg-Zilber map composed with the
Alexander-Whitney map is the identity. An explicit homotopy for the other composite to the identity is given by the <b>Shih operator</b> map \(C_{m,m}\to C_{m+1,m+1}\) that in degree \(0\) is \(0\) and in positive degree is
(signs and/or indices may be wrong):
</p>

<p>
\[ \sum _{q,p,\mu } (-1)^{m&apos;+1+\mu }s^h_{\mu (n)}\dots s^h_{\mu (p+2)}\partial ^h_{m-q+1}\dots \partial ^h_m s^v_{\mu (p+1)}\dots s^v_{\mu (1)}\partial ^v_{m&apos;}\dots \partial
^v_{m-q-1} \]
</p>

<p>
where \(m&apos; = m-p-q\), \(0\leq q &lt;m, 0 \leq p &lt;m-q, \mu \in S_{p+1,q}\). There are more conceptual arguments for this, but it is interesting to know there is an explicit universal formula for the chain
homotopy. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-686"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.6</span></span>. A map \(A\to B\) of bisimplicial objects in an abelian category \(D\) that is a
quasi-isomorphism on vertical simplicial objects induces a weak equivalence \(f_*:d(A) \to d(B)\) on the diagonal complexes.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-687"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> There is a bisimplicial abelian group which in vertical degree \(m\) is the translation object \(EA(*,m)\) associated to the functor \(A(*,m):(\Delta _{/[m]})^{op}\to D\).
Since \(\Delta _{[m]}^{op}\) has a terminal object, there is a canonical homotopy equivalence by Lemma <a href="node-Bisimplicial-Sets.html#canweakeqtermbisimp">7.4</a> from \(EA(*,m)\to K(A(m.m),0)\). By
letting \(m\) vary, we get a canonical weak equivalence \(\Tot EA(*,*)\to d(A)\).
</p>

<p>
In horizontal degree \(k\), the simplicial object is \(\oplus _{f:[k]\to \Delta ^{op}} \Delta ^{f(0)}\otimes A(f(k),*)\), so it follows that this is invariant under weak equivalences, so the total complex, and hence
\(d(A)\), is too. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Define the <b>horizontal normalization</b> \((N_hA)_n\) to be the simplicial chain complex whose \(n\)-simplices are \(N_hA_n:=NA(*,n)\). There is the Postnikov filtration \(F_p(N_hA)_i\), defined as the chain complex
obtained by truncating levelwise, so that it is concentrated in degrees \(0 \leq i \leq p\). This is really the same filtration as the one used to define the spectral sequence of a double complex.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-688"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.7</span></span>. <a id="postfiltlemma"></a> Let \(A\) be a bisimplicial object in an abelian category
\(D\). The natural map \(\pi _n (N_h A)_p \to N(\pi _nA_*)_p\) is an isomorphism.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-689"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We will inductively show that the natural map \(\pi _n (N^j_h A)_p \to N^j(\pi _nA_*)_p\) is an isomorphism where
</p>

<p>
\[N^j_hA_p = \cap _0^j \ker (d_i^h)\subset A_p\]
</p>

<p>
When \(j=0\), we can use the fact that there is a split short exact sequence:
</p>

<p>
\[0 \to N^0_h(A_p)\to A_p\xrightarrow {d_0^h} A_{p-1}\to 0 \]
</p>

<p>
split by \(s_0^h\). We also obtain that \(\pi _n (N^0_h A)_p\to \pi _n A_p\) is monic. Suppose this holds for \(j\). There is a pullback diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-85"
      class="lateximagesource"
><!--
Nhj+1 Ap        ker(dhj+1 )
            ⌟

Nhj (Ap )          Ap
--><img
      src="Simplicial_h-images/image-85.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
and we can form the pushout \(N_h^jA_p+ \ker (d^h_{j+1})\). The pullback square allows us to see that the map \(N^{j+1}_hA_p\to N^j_h(A_p)\) is split by the map \(1-s^h_{j+1}d^h_{j+1}\). Thus it follows that we get a
split pushout of objects in \(D\)
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-86"
      class="lateximagesource"
><!--
πn Nhj+1 Ap         πn ker(dhj+1 )

                 ⌜
πn Nhj (Ap )   πn (Nhj Ap + ker(dhj+1 ))
--><img
      src="Simplicial_h-images/image-86.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
\(\ker (d^h_{j+1})\to \pi _n(N_h^jA_p+ \ker (d^h_{j+1}))\) is split monic, and the map \(\pi _nN^j_h(A_p)\to ]\pi _n(A_p)\) by assumption is monic, so the map from the pushout is too, meaning that the sequence
below is exact, giving the result.
</p>

<p>
\[0 \to \pi _nN_h^{j+1}A_p\to \pi _nN_h^j(A_p)\oplus \pi _n\ker (d^h_{j+1})\to \pi _nA_p\]
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-696"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">7.8</span></span>. There is a spectral sequence with \(E_2\)-term \(\pi _p(\pi _qA_*)\), converging to
\(\pi _{p+q}(d(A))\) arising from the Postnikov filtration \(F_p(N_h(A))\) on \(N_h(A)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-697"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(\Gamma F_p(N_hA)\) is a filtered bisimplicial object. We can apply the diagonal \(d\) to it to obtain a filtered chain complex.
</p>

<p>
The associated spectral sequence has \(E_1\)-term \(\pi _{p+q}d(\Gamma N_h(A)[p])\) Thiere are natural isomorphism \(\pi _{p+q}d(\Gamma N_h(A)[p])\cong \pi _qd(\Gamma N_h(A))\cong \pi _q\Gamma N_h(A)\), and
the chain complex \(\pi _*\Gamma N_h(A)\) by Lemma <a href="node-Bisimplicial-Sets.html#postfiltlemma">7.7</a> can be identified with the complex \(N(\pi _q(A))\). Thus the \(E_2\)-term is as stated. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-698"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.9</span></span>. Let \(D\) be an abelian category with enough projectives. and \(f:I\to D\) is a functor
with \(I\) small. Then there is a natural isomorphism \(\pi _n(Ef,0) \cong L_n(\colim f)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-699"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The groups \(\pi _n(EA,0)\) are the homology groups of the Moore complex of \(H_nEf\). \(H_0Ef\) is the cokernel \(\oplus _{i\to j} f_i \xrightarrow {d_0-d_1}\oplus
_{i}f_i\) which is \(\colim f\) by the formula for colimits. \(\pi _n(EA,0)\) is a \(\delta \)-functor, so it suffices to check it is coeffacable. To see this, given a projective \(M\) and \(i \in I\), define \(F_i(M)_j = \oplus
_{i \to j}M\). We can produce surjections from sums these to anything, and \(EF_iM = M\otimes B(I_{/i})\) which has a terminal object, so it is contractible. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-700"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">7.10</span></span>. Let \(X:I \to \SSet \) be a functor, and \(M\) a module over a ring \(R\). There is a
strongly convergent spectral sequence
</p>

<p>
\[E_2^{p,q} = L_q(\colim _I)H_q(X,A)\to H_{p+q}(\lim X,A)\]
</p>

<p>
where \(\lim X\) is the diagonal homotopy colimit.
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-701"><span class="sectionnumber">7.2&#x2003;</span>Model structures</h5>
<a id="Simplicial_h-autopage-701"></a>


<p>
There are three closed model structures on bisimplicial sets:
</p>

<ul style="list-style-type:none">

<li>
<p>
• The <i>Bousfield-Kan structure</i>, which is another name for the projective model structure on \(\Fun (\Delta ^{op},\SSet )\).
</p>


</li>
<li>


<p>
• The <i>Reedy structure</i>, which in this case just agrees with the injective model structure on \(\Fun (\Delta ^{op},\SSet )\).
</p>


</li>
<li>


<p>
• The <i>Moerdijk structure</i>, in which a fibration or weak equivalence is a weak equivalence iff it induces an equivalence on diagonal simplicial sets.
</p>
</li>
</ul>

<p>
For an \(n\)-truncated simplicial object there is a canonical comparison map \(\varphi :      (i_n)_!Z\to (i_n)_*Z\). For each compsite \([k] \xrightarrow {\gamma } [n+1] \xrightarrow {\theta } [m]\) with \(k,m
\leq n\) we get a commutative diagram
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-87"
    class="lateximagesource"
><!--
              (θγ)∗
   Zm                     Zk
      θ∗                γ∗
               φ
(in )! Zn+1           (in )∗ Zn+1
--><img
    src="Simplicial_h-images/image-87.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-705"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.11</span></span>. Giving an \(n+1\)-truncated simplicial object is the same as giving an \(n\)-truncated
simplicial object \(Z\) along with an object \(Z_{n+1}\) and a factorization
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-88"
      class="lateximagesource"
><!--
(in )! Zn+1         Zn+1
              φ


                  (in )∗ Zn+1
--><img
   src="Simplicial_h-images/image-88.svg"
   alt="(-tikz-&nbsp;diagram)"
   style=""
   class="lateximage"
></span>
</p>
</div>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-709"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The horizontal map can be viewed as the degeneracies, and the vertical map can be viewed as the attaching maps. It is easy to check that this is equivalent to an \(n+1\)-truncated
simplicial object by using the standard presentation of the simplex category. I think this is really just a property of Reedy categories. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We define the \(n^{th}\) <b>matching object</b> \(M_nX\) of a simplicial object to be \((\cosk _{n-1}X)_n\), and dually, \(L_nX = (\sk _{n-1}X)_n\) is the \(n^{th}\) <b>latching object</b>. A way to remember it is
that the \(n^{th}\) latching object is the degenerate \(n\)-simplces. There are natural maps \(L_nX\to X_n\to M_nX\).
</p>

<p>
Let \(C\) be a model category. Say that a map \(X\to Y\) of simplicial objects is a <b>Reedy (trivial) fibration</b> iff the maps \(X_n\to Y_n\times _{M_nY}M_nX\) are (trivial) fibrations for \(n\geq 0\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-710"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.12</span></span>. <a id="reedyinjectivebisimpset"></a> The Reedy (trivial) fibrations on bisimplicial
sets are injective (trivial) fibrations.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-711"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We would like to show for example that a Reedy fibration \(X\to Y\) has the right lifting property with respect to an injective trivial cofibration \(U \to V\). We can show
inductively that there exist compatible lifts on the \(n\)-truncations. In the inductive step, we are trying to lift
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-89"
      class="lateximagesource"
><!--
skn Vn+1 ∪skn Un+1 Un+1             Xn+1


         Vn+1             Yn+1 ×coskn Yn+1 coskn Xn+1
--><img
      src="Simplicial_h-images/image-89.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
The left vertical map is a cofibration, and is a trivial cofibration by the proof of Proposition <a href="node-Bisimplicial-Sets.html#diagweakeq">7.2</a> since \(U\mapsto \sk _nU_{n+1}\) preserves weak equivalences and
the model structure is left proper, so we can use the \(2\) out of \(3\) property on \(U_{n+1} \to U_{n+1}\cup _{\sk _{n}U_{n+1}}\sk _nV_{n+1}\to V_{n+1}\). Thus the desired lift exists. A similar argument works for
trivial Reedy fibrations. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-715"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.13</span></span>. <a id="reedytrivcrit"></a> Injective (trivial) fibrations are Reedy (trivial) fibrations.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-716"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The left adjoint of \(X\mapsto X_n\) is \(K \mapsto F_n(K):= \Delta ^n\tilde {\otimes }K\). A map \(K \to \cosk _{n-1}X_n\) is the same as a map
\(i^*_{n-1}F_n(K) \to i^*_{n-1}X\), which is the same as a map \(\sk _{n-1}F_n(K) \to X\). Thus lifting the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-90"
      class="lateximagesource"
><!--
∂∆m              Xn


∆m    Yn ×coskn−1 Yn coskn−1 Xn
--><img
      src="Simplicial_h-images/image-90.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is the same as lifting
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-91"
      class="lateximagesource"
><!--
Fn (∂∆m ) ∪skn−1 Fn (∂∆m ) skn−1 Fn ∆m   X


              Fn (∆m )                   Y
--><img
      src="Simplicial_h-images/image-91.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
which we can do for an injective trivial fibration. The argument for fibrations is the same. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Next, we study the Moerdijk model structure. The fibrations and weak equivalences are those that are after applying the diagonal. The diagonal functor \(d=d^*\) from bisimplicial sets to simplicial sets has a left adjoint \(d_!\)
and a right adjoint \(d_*\)
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-723"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.14</span></span>. <a id="diaglemma"></a> The inclusion \(d_!(\Lambda ^n_k) \to d_!(\Delta ^n)\) is
a diagonal weak equivalence, and the map \(d_*\) sends fibrations to diagonal fibrations.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-724"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(d_!(\Delta ^n) = \Delta ^{n,n}\), and \(d^*d_!(\Delta ^n) = \Delta ^n\times \Delta ^n\), so it is contractible. There is a natural transformation \(d_!X\to
*\tilde {\times }X\) determined by the maps \(\Delta ^{n,n} \to *\tilde {\times }\Delta ^n\) that forget the left simplex.
</p>

<p>
This natural transformation for \(\Lambda ^n_k\) is the projection
</p>

<p>
\[\coprod _{\beta \in \Lambda ^n_k}C_\beta \to \coprod _{\beta \in \Lambda ^n_k}*\]
</p>

<p>
where \(C_{\beta }\) is the subcomplex of \(\Lambda ^n_k\) generated by faces containing \(\beta \). Each \(C_{\beta }\) is contractible since it is a cone over the \(k^{th}\) vertex. Thus by Proposition <a
href="node-Bisimplicial-Sets.html#diagweakeq">7.2</a>, the map \(d^*d_!(\Lambda ^n_k) \to d^*(*\tilde {\times }\Lambda ^n_k) = \Lambda ^n_k\) is a weak equivalence, so \(d^*d_!(\Lambda ^n_k)\) is
contractible too.
</p>

<p>
It follows that \(d_*\) sends fibrations to diagonal fibrations by Lemma <a href="node-Technical-Things.html#adjunctionlifting">2.13</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-725"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">7.15</span></span>. Diagonal fibrations and diagonal weak equivalences form a combinatorial model
structure called the Moerdijk model structure on bisimplicial sets.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-726"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We would like to apply Proposition <a href="node-Model-Categories.html#adjunctioninducedmodelstr">4.12</a> for the adjunction between \(d^*\) and \(d_!\). To do
this, we only need to check that any map with the left lifting property with respect to diagonal fibrations is a diagonal equivalence. But by Lemma <a href="node-Bisimplicial-Sets.html#diaglemma">7.14</a>, it has the left
lifting property with respect to \(d_*(f)\) where \(f\) is a Kan fibration, so \(d\) applied to it has the left lifting property with respect to all Kan fibrations, and so is a trivial cofibration. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-727"><span class="sectionnumber">7.3&#x2003;</span>Bousfield-Friedlander</h5>
<a id="Simplicial_h-autopage-727"></a>


<p>
There is a construction \(M_K(X)_p = \Hom _{\SSet }(K,X(*,p))\) generalizing \(M_n(X)_p = M_{\partial \Delta ^n}(X)_p\).
</p>

<p>
Given a bisimplicial set \(X\), we can form \(\pi _n(X)\), the simplicial set with \(m\)-simplices \(\coprod _{x \in X(m,0)}\pi _n(X_m,x)\). This is equipped with a natural map to \(X(*,0)\), and is a group object in
\(\SSet _{/X(*,0)}\) for \(m\geq 1\). A vertex \(v\) in \(M_K(X)\) is a map \(v:K \to X(*,0)\), so we can define \(M_K(\pi _mX,v)\) to be \(\Hom _{\SSet _{/X(*,0)}}(v,\pi _m(X))\), which is a group for \(m\geq 1\).
</p>

<p>
\(M_K(\pi _mX,v)\) is a contravariant functor in the pair \(K,v\), and it sends colimits to limits since it is given by \(\Hom \) out of \(v\). Note that \(M_{\Delta ^n}(\pi _mX,v) =\pi _m(X_n,v)\). Let \(dv\) be the
restriction of an \(n\)-simplex \(v\) to some (unspecified) horn \(\Lambda ^n_k\). It follows that there is an equalizer diagram
</p>

<p>
\[M_{\Lambda ^n_k}(\pi _mX,dv) \to \Pi _{i\neq k} \pi _m(X_{n-1},d_iv) \rightrightarrows \Pi _{i&lt;j;i,j\neq k}\pi _m(X_{n-1},d_id_jv)\]
</p>

<p>
A projectively fibrant bisimplicial set \(X\) is said to satisfy the <b>\(\pi _*\)-Kan condition</b> if the maps \(d:\pi _m(X_n,v) \to M_{\lambda ^n_k}(\pi _m(X),dv)\) are surjective group homomorphisms for \(m\geq
1\). This is equivalent to the maps \(\pi _m(X) \to X(*,0)\) being Kan fibrations for all \(m\geq 1\).
</p>

<p>
Let \(\pi _0(Y)\) for a bisimplicial set be the simplicial set defined by \(\pi _0(Y)_n = \pi _0(Y_n)\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-728"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.16</span></span>. <a id="pistarkanlemma1"></a>
</p>
<ul style="list-style-type:none">


<li>
<p>
1. A projectively fibrant bisimplicial set \(X\) satisfies the \(\pi _*\)-Kan condition if all of the vertical simplicial sets \(X_n\) are path connected.
</p>


</li>
<li>


<p>
2. If \(f:X\to Y\) is a vertical weak equivalence of projectively fibrant bisimplicial sets, then \(X\) satisfies the \(\pi _*\)-Kan condition iff \(Y\) does.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-729"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> To show \((1)\), we observe that we can choose a path from our base point in \(X(n,0)\) to a degenerate one coming from \(X(0,0)\). This induces a change of basepoint
isomorphism, so we only need to check the \(\pi _*\)-Kan condition at degenerate basepoints \(s(y)\). But the assignment \(n \mapsto \pi _m(X_n,s(y))\) is a simplicial group, hence a Kan complex.
</p>

<p>
To see \((2)\), observe that \(X \to Y\) is a vertical weak equivalence iff \(\pi _0X\to \pi _0Y\) is an isomorphism, and the diagrams
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-92"
      class="lateximagesource"
><!--
 πm X      πm Y


X(∗, 0)   Y (∗, 0)
--><img
      src="Simplicial_h-images/image-92.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
are pullbacks for \(m\geq 1\). Kan fibrations are stable under pullback, so if \(Y\) satisfies \(\pi _*\)-Kan, \(X\) does too.
</p>

<p>
Conversely suppose that the \(\pi _*\)-Kan condition holds for \(X\). To check it for \(Y\), we can do a change of basepoints to check it at basepoints in the image of \(X\). But then it follows from the \(\pi _*\)-Kan condition
for \(Y\) since the homotopy groups agree. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We say that an arbitrary bisimplicial set satisfies the \(\pi _*\)-Kan condition iff a projectively fibrant replacement does.
</p>

<p>
\(X\mapsto M_KX\) is right adjoint to \(Y\mapsto K\tilde {\times } Y\). Thus since \(K\tilde {\times }\Delta ^n\cup _{K\tilde {\times }\Lambda ^n_k}L\tilde {\times }\Lambda ^n_k \to L\tilde {\times
}\Delta ^n\) is a Reedy trivial cofibration for an inclusion \(K \to L\), it follows that \(M_LX\to M_LY \times _{M_KY} M_KX\) is a Kan fibration when \(X \to Y\) is a Reedy fibration.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-733"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.17</span></span>. <a id="pistarkanisolemma1"></a> Suppose \(X\) is a Reedy fibrant bisimplicial set
satisfying the \(\pi _*\)-Kan condition. Given a vertex \(x \in X(n,*)\), there are isomorphisms
</p>

<p>
\[ \pi _m(M_{\Lambda ^n_k}X,dx)\cong M_{\Lambda ^n_k}(\pi _mX,dx)\]
</p>

<p>
\[ \pi _0(M_{\Lambda ^n_k}X) \cong M_{\Lambda ^n_k}(\pi _0X)\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-734"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(\Delta ^n\langle s_0,\dots ,s_r\rangle \) be the subcomplex of \(\Delta ^n\) generated by the faces \(d_{s_0}\dots d_{s_r}\), where \(0 \leq s_0 &lt;
s_1\dots &lt; s_r\leq n\). We can use \(M^{(s_0,\dots ,s_r)}_n\) to denote \(M_{\Delta ^n\langle s_0,\dots ,s_r\rangle }\).
</p>

<p>
There is a pushout diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-93"
      class="lateximagesource"
><!--
∆n−1 ⟨s0 , . . . , sr−1 ⟩     ∆n ⟨s0 , . . . , sr−1 ⟩

                        dsr
                              ⌜
        ∆n−1                      ∆n ⟨s0 , . . . , sr ⟩
--><img
      src="Simplicial_h-images/image-93.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
inducing a pullback square
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-94"
      class="lateximagesource"
><!--
   (s ,...,sr )
Mn 0                 Xn−1
              ⌟
                          dsr

  (s ,...,sr−1 )    (s ,...,sr−1 )
Mn 0                  0
                   Mn−1
--><img
      src="Simplicial_h-images/image-94.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Choose a sequence \(s_i\) with \(s_i \neq k\). The map \(d_{s_r}\) is a fibration since \(X\) is Reedy fibrant, so this is a homotopy pullback square. We can assume by induction that the map
</p>

<p>
\[\pi _m(M_{n}^{(s_0,\dots ,s_{r-1})}X,dx) \to M_{n}^{(s_0,\dots ,s_{r-1})}(\pi _mX,dx)\]
</p>

<p>
is an isomorphism, and similarly for \(M_{n-1}^{(s_0,\dots ,s_{r-1})}\). The map \(\pi _m(X_{n-1},dx) \to M_{n-1}^{(s_0,\dots ,s_{r-1})}(\pi _mX,dx)\) is a surjection since \(X\) satisfies the \(\pi _*\)-Kan
condition, so the square is a pullback, showing that the result holds for \(s_0,\dots ,s_r\). A similar argument works for \(\pi _0\), only one has to observe that the inclusion of the fibres of the vertical maps in the pullback
square is injective on \(\pi _0\) since the maps are surjective on \(\pi _1\).
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-95"
      class="lateximagesource"
><!--
      (s ,...,sr )
π∗ (Mn 0             )      π∗ (Xn−1 )
                     ⌟
                                   dsr

     (s ,...,sr−1 )            (s ,...,sr−1 )
π∗ (Mn 0              )          0
                          π∗ (Mn−1              )
--><img
      src="Simplicial_h-images/image-95.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is a pullback square from Proposition <a href="node-Model-Categories.html#mayervietorisfibreproduct">4.32</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-744"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.18</span></span>. <a id="horizontalkanfibration"></a> Suppose that \(X\) and \(Y\) are Reedy fibrant
bisimplicial sets which satisfy the \(\pi _*\)-Kan condition and that the bisimplicial set map \(f:X\to Y\) is a Reedy fibration. Suppose further that the induced simplicial set map of vertical path components \(\pi _0X\to \pi
_0Y\) is a Kan fibration. Then the map \(f\) is a horizontal pointwise Kan fibration.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-745"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Being a horizontal pointwise Kan fibration is equivalent to the maps \(X_n \to Y_n \times _{M_{\Lambda ^n_k}Y}M_{\Lambda ^n_k}X\) being surjective simplicial set maps.
But since \(f\) is a Reedy fibration, this map is a Kan fibration, so it suffices to show it is surjective on \(\pi _0\). By Lemma <a href="node-Bisimplicial-Sets.html#pistarkanisolemma1">7.17</a>, this is equivalent to the
map
</p>

<p>
\[\pi _0X_n\to \pi _0Y_n\times _{M_{\Lambda ^n_k}\pi _0Y}M_{\Lambda ^n_k}\pi _0X\]
</p>

<p>
being surjective, which is true since \(\pi _0X\to \pi _0Y\) is a Kan fibration. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-746"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.19</span></span>. <a id="reedyhorizontaldiagfib"></a> Suppose that \(f:X\to Y\) is a Reedy fibration
and a horizontal pointwise Kan fibration. Then \(f\) is a diagonal fibration.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-747"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The cofibration \(d^*\Lambda ^n_k \to d^*\Delta ^n = \Delta ^{n,n}\) factors as a composite \(d^*\Lambda ^n_k\subset \Lambda ^n_k\tilde {\times }\Delta
^n\subset \Delta ^n\tilde {\times }\Delta ^n\). By the proof of Lemma <a href="node-Bisimplicial-Sets.html#diaglemma">7.14</a>, The first map is a vertical Reedy cofibration, and the second has the left lifting
property with respect to horizontal pointwise fibrations. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
A map of bisimplicial sets is pointwise homotopy cartesian if it is homotopy cartesian in each degree.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-748"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.20</span></span><span class="amsthmnoteplain"> (Bousfield-Friedlander)</span>. <a
id="bousfieldfriedlander"></a> Given a pointwise homotopy cartesian square of bisimplicial sets
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-96"
      class="lateximagesource"
><!--
X   Y


Z   W
--><img
      src="Simplicial_h-images/image-96.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
such that \(Y,W\) satisfy the \(\pi _*\)-Kan condition and \(\pi _0Y\to \pi _0W\) is a Kan fibration. Then the square
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-97"
      class="lateximagesource"
><!--
d(X)   d(Y )


d(Z)   d(W )
--><img
      src="Simplicial_h-images/image-97.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is homotopy cartesian.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-755"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG, we can assume that the map \(p:Y \to W\) is a Reedy fibration and \(W\) is Reedy fibrant. By Lemma <a
href="node-Bisimplicial-Sets.html#horizontalkanfibration">7.18</a> and Lemma <a href="node-Bisimplicial-Sets.html#reedyhorizontaldiagfib">7.19</a>, \(p\) is then a diagonal fibration. Thus the square
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-98"
      class="lateximagesource"
><!--
d(Z ×W Y )   d(Y )


  d(Z)       d(W )
--><img
      src="Simplicial_h-images/image-98.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is homotopy cartesian, so since the map \(X \to Z\times _W Y\) is a weak equivalence, so is the square we wanted. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-759"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">7.21</span></span>. <a id="loopsgeometricrealization"></a> Suppose that \(X\) is a pointwise fibrant
and pointwise connected bisimplicial set. Then there is a weak equivalence \(d(\Omega X) \cong \Omega d(X)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-760"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(X\) and \(PX\) satisfy the \(\pi _*\)-Kan condition by Lemma <a href="node-Bisimplicial-Sets.html#pistarkanlemma1">7.16</a>, and \(\pi _0PX \to \pi _0X\) is
clearly a Kan fibration. Thus by Theorem <a href="node-Bisimplicial-Sets.html#bousfieldfriedlander">7.20</a>, \(d(\Omega X) \to d(PX) \to d(X)\) is a fibre sequence, and \(d(PX)\) is contractible. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-761"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">7.22</span></span>. <a id="diagonalconnected"></a> Suppose that \(X\) is a bisimplicial set which is
pointwise \(k\)-connected. \(d(X)\) is then \(k\)-connected.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-762"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> First, when \(k = 0\), \(\pi _0(d(X))\) is the coequalizer of the two boundary maps \(\pi _0(X_1) \to \pi _0(X_0)\), so this follows. Now, we can induct on \(k\) and use
Corollary <a href="node-Bisimplicial-Sets.html#loopsgeometricrealization">7.21</a> to get the result. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-763"><span class="sectionnumber">7.4&#x2003;</span>Theorem B and Group Completion</h5>
<a id="Simplicial_h-autopage-763"></a>


<p>
Given a map \(f:E \to B\) of simplicial sets, there is a functor \(f^{-1}:\Delta /B \to \SSet \) where \(\Delta /B\) is the category of simplices of \(B\), taking a simplex to its fibre product under \(f\).
</p>

<p>
\(B\) is the colimit in \(\SSet \) of its simplices, and pulling back along \(f\) is a left adjoint, so we can identify \(\lim _{\Delta /B}f^{-1} = E\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-764"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.23</span></span>. <a id="fibresequivalenttodomain"></a> \(Ef^{-1}\) is naturally equivalent to the
constant bisimplicial simplicial set \(E\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-765"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(Ef^{-1}_m\) denote the category of \(m\)-simplices in \(f^{-1}\). Because \(\lim _{\Delta /B}f^{-1} = E\), the path components of this agree with \(E_m\). Given an
\(m\)-simplex \(x \in E_m\), let \(Ef^{-1}_{m,x}\) denote the path component corresponding to \(x\). \(x\) viewed as an object of this category is a terminal object. It follows that the map \(Ef_m^{-1} \to E_m\) is a weak
equivalence of simplicial sets, so that \(Ef^{-1} \to E\) is a weak equivalence, where \(E\) is a constant simplicial set. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-766"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">7.24</span></span>. <a id="hocolimsimplices"></a> \(B\) is naturally equivalent to the homotopy colimit
or diagonal homotopy colimit of the constant functor \(B_{\Delta /} \to \SSet \) taking value \(*\), which is equivalent to the nerve of \(B_{\Delta /}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-767"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By applying Lemma <a href="node-Bisimplicial-Sets.html#fibresequivalenttodomain">7.23</a> to the identity functor, we see that the constant bisimplicial object \(B\)
is equivalent to \(E1_B^{-1}\). \(1_B^{-1}\) is equivalent to the constant functor taking value \(*\). Note that the homotopy colimit and diagonal agree on the constant bisimplicial object \(B\), and so applying both of these
functors to the zig-zag of equivalences gives the desired result. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Given a map \(f:E \to B\) and a projective object \(M\) in a projectively generated abelian category, by Lemma <a href="node-Pi-_1-Simplicial-abelian-groups.html#freepresweakeq">6.14</a> \(M[Ef^{-1}] \to
M[E]\) is a weak equivalence.
</p>

<p>
There is thus a convergent spectral sequence with \(E_2\)-term \(\pi _p\pi _q(M[Ef^{-1}])\) converging to \(H_{p+q}(E;M)\). Now suppose that \(f\) is a Kan fibration. Then given a path \(\sigma \) in \(B\), the induced
map \(f_*\) on the fibres is an equivalence. Suppose \(\pi _1(B)\) acts trivially on \(H_q(F;M)\). Then for any \(\sigma \in B_n\), \(\pi _q(M[f^{-1}\sigma ])\) is naturally isomorphic to \(H_q(F;Ef^{-1})\). It follows
that the \(E_2\)-term of the spectral sequence in this case is the same as \(H_p(EB_{/\Delta };H_q(F;M))\). But by Corollary <a href="node-Bisimplicial-Sets.html#hocolimsimplices">7.24</a>, this is just
\(H_p(B;H_q(F;M))\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-768"></a>
<span class="amsthmnamedefinition">Construction</span><span class="amsthmnumberdefinition"> <span class="textup">7.24.1</span></span><span class="amsthmnotedefinition"> (Serre Spectral
Sequence)</span>. Consider a fibration \(E \to B\) with \(\Pi _1(B)\) acting trivially on \(H_q(F;M)\), where \(M\) is a projective object in an abelian category. There is a natural first quadrant spectral sequence with
\(E_2\)-term \(H_p(B;H_q(F,M))\) converging to \(H_{p+q}(E;M)\).
</p>

</li>

</ul>

</div>

<p>
Of course, this is weaker than the most general form of the Serre spectral sequence.
</p>

<p>
An important ingredient in the proof of Theorem B is the following lemma.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-769"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.25</span></span>. <a id="theoremblemma"></a> Suppose that \(X:I \to \SSet \) is a functor taking
values in weak equivalences. Then for each \(j \in I\), there is a homotopy cartesian diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-99"
      class="lateximagesource"
><!--
X(j)       Y
       ⌟

 ∗         BI
--><img
      src="Simplicial_h-images/image-99.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
where \(Y\) is the diagonal homotopy colimit of \(X\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-773"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Note that applying the diagonal homotopy colimit to the natural transformation \(X \to *\), there is a (not homotopy) pullback diagram as above. To see it is a homotopy
pullback diagram, we will find a factorization \(* \to U \to BI\) such that the first map is a trivial cofibration, the second is a fibration, and the map \(X(j) \to U\times _{BI} Y\) is a weak equivalence. Pullbacks preserve
colimits, which are stable under filtered colimits, so it suffices to check by the small object argument that \(\Lambda ^n_k\times _BI Y \to \Delta ^n\times _{BI}Y\) is an equivalence for any simplex \(\sigma \) in \(BI\).
</p>

<p>
\(\Delta ^n\times _{BI}Y\) can be identified with the diagonal homotopy colimit of the composite functor \(\Delta ^n\xrightarrow {\sigma }I \xrightarrow {X}S\). The map \(\Lambda ^n_k\times _BI Y \to \Delta
^n\times _{BI}Y\) is the diagonal of the map between bisimplicial sets
</p>

<p>
\[ \coprod _{k_0\rightarrow \dots \rightarrow k_r \in \Lambda ^n_r} X\sigma (k_0) \to \coprod _{k_0\rightarrow \dots \rightarrow k_r \in \Delta ^n} X\sigma (k_0)\]
</p>

<p>
But by the assumption on \(X\), the natural transformation from \(\Delta ^n \to \{0\} \to \Delta ^n\) to the identity induces an equivalence on the bisimplicial sets in the map above to those where \(\sigma (k_0)\) is
replaced with \(\sigma (0)\). But the induced map between the diagonals of these bisimplicial sets is the map \(\Lambda ^n_k \times X\sigma (0) \to \Delta ^n\times \sigma (0)\), which is an equivalence.
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-774"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.26</span></span><span class="amsthmnoteplain"> (Theorem B)</span>. <a id="quillenthmb"></a>
Suppose \(F:C \to D\) is a functor between small categories such that for every morphism \(\alpha :y \to y&apos;\) of \(D\), the induced simplicial set map \(\alpha ^*:NF_{y/} \to NF_{y&apos;/}\) is a weak equivalence.
Then for every object, the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-100"
      class="lateximagesource"
><!--
N Fy/   NC


N Dy/   ND
--><img
      src="Simplicial_h-images/image-100.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is homotopy cartesian.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-778"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The assignment \(y \mapsto NF_{y/}\) is a functor \(D \to \SSet \), determining a bisimplicial set with \((n,m)\) simplices \(\coprod _{y_n\to \dots \to
y_0}(NF_{y_0/})_m\). In otherwords, it is strings of arrows
</p>

<p>
\[ y_n \to \dots \to y_0 \to F(x_0) \to \dots \to F(x_m)\]
</p>

<p>
Forgetting \(F(x_0)\to \dots \to F(x_m)\) gives a diagram of bisimplicial sets
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-101"
      class="lateximagesource"
><!--
`
    yn →···→y0 (N Fy0 / )   NC

`
    yn →···→y0 (N Dy0 / )   ND
--><img
      src="Simplicial_h-images/image-101.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
In the horizontal direction the top horizontal maps above are given by
</p>

<p>
\[\coprod _{x_0\to \dots \to x_m} (D_{F(x_0)/})^{op} \to \coprod _{x_0\to \dots \to x_m} *\]
</p>

<p>
which is clearly an horizontal equivalence. The bottom horizontal map is a horizontal equivalence for the same reason.
</p>

<p>
Thus it suffices to we can replace the Cartesian diagram in the theorem statement with the left vertical map above. But \(ND_{y/} \simeq *\) and \(\coprod _{y_n\to \dots \to y_0}(ND_{y_0/}) \simeq \coprod _{y_n\to
\dots \to y_0}*\) because the categories have terminal objects. Thus we are reduced to showing that the bisimplicial set diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-102"
      class="lateximagesource"
><!--
        `
N Fy/       yn →···→y0 (N Fy0 )m


             `
 ∗               yn →···→y0 ∗
--><img
      src="Simplicial_h-images/image-102.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is Cartesian on diagonals, but this follows from Lemma <a href="node-Bisimplicial-Sets.html#theoremblemma">7.25</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
