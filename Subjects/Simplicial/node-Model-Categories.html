
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Simplicial</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Simplicial_h-autopage-260"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Simplicial</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Introduction.html#autosec-6" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Technical Things</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-36" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Generators of anodyne morphisms</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-54" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Enriched Categories</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-68" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Basics of Simplicial Sets</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-99" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Left fibration characterization of Kan fibrations</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-127" class="tocsubsection" >
<span class="sectionnumber">2.5</span>&#x2003;Cartesian Morphisms</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-156" class="tocsubsection" >
<span class="sectionnumber">2.6</span>&#x2003;Minimal Inner Fibrations</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-173" class="tocsubsection" >
<span class="sectionnumber">2.7</span>&#x2003;Trees</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-207" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Kan Fibrations</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-230" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Minimal fibrations</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-243" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Equivalence of Quillen and Serre model structures</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-262" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Model Categories</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-313" class="tocsubsection" >
<span class="sectionnumber">4.1</span>&#x2003;Homotopy category of a model category</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-411" class="tocsubsection" >
<span class="sectionnumber">4.2</span>&#x2003;Combinatorial Model Categories</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-443" class="tocsubsection" >
<span class="sectionnumber">4.3</span>&#x2003;Derived Functors</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-478" class="tocsubsection" >
<span class="sectionnumber">4.4</span>&#x2003;Enriched and Simplicial model categories</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-510" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Some Important Model Structures</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-511" class="tocsubsection" >
<span class="sectionnumber">5.1</span>&#x2003;Model structure on \(S\)-enriched categories</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-552" class="tocsubsection" >
<span class="sectionnumber">5.2</span>&#x2003;Diagram model structures and homotopy limits</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-595" class="tocsubsection" >
<span class="sectionnumber">5.3</span>&#x2003;Reedy model structures</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-613" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;\(\Pi _1\) and Simplicial abelian groups</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-614" class="tocsubsection" >
<span class="sectionnumber">6.1</span>&#x2003;Fundamental Groupoid</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-627" class="tocsubsection" >
<span class="sectionnumber">6.2</span>&#x2003;Local Systems and Covering Spaces</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-628" class="tocsubsection" >
<span class="sectionnumber">6.3</span>&#x2003;Simpicial objects in Abelian Categories</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-664" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bisimplicial Sets</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-681" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Bisimplicial objects in an abelian category</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-701" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Model structures</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-727" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Bousfield-Friedlander</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-763" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Theorem B and Group Completion</a>
</p>


<p>
<a href="node-Some-Classical-Homotopy-Theory.html#autosec-787" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Some Classical Homotopy Theory</a>
</p>


<p>
<a href="node-Some-Classical-Homotopy-Theory.html#autosec-788" class="tocsubsection" >
<span class="sectionnumber">8.1</span>&#x2003;The Hurewicz Map</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-841" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Models for Homotopy Types</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-842" class="tocsubsection" >
<span class="sectionnumber">9.1</span>&#x2003;Test Categories</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-875" class="tocsubsection" >
<span class="sectionnumber">9.2</span>&#x2003;Basics of Cubical Sets</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-898" class="tocsubsection" >
<span class="sectionnumber">9.3</span>&#x2003;Cisinski model structures</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-971" class="tocsubsection" >
<span class="sectionnumber">9.4</span>&#x2003;Colimits in Cisinski model structures</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-1010" class="tocsubsection" >
<span class="sectionnumber">9.5</span>&#x2003;Weak equivalence classes of functors</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-1043" class="tocsubsection" >
<span class="sectionnumber">9.6</span>&#x2003;Model structure on Cubical Sets</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1072" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Simplicial localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1073" class="tocsubsection" >
<span class="sectionnumber">10.1</span>&#x2003;Free Categories and Localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1087" class="tocsubsection" >
<span class="sectionnumber">10.2</span>&#x2003;Dwyer-Kan Localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1099" class="tocsubsection" >
<span class="sectionnumber">10.3</span>&#x2003;Reduction to Cubical Sets</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Simplicial</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)
</div>

<p>
<!--................................-->
<h4 id="autosec-262"><span class="sectionnumber">4&#x2003;</span>Model Categories</h4>
<a id="Simplicial_h-autopage-262"></a>
<a id="Simplicial_h-autofile-4"></a> Model categories are a \(1\)-categorical way to present a homotopy theory (\(\infty \)-category) in a computable way.
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-263"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.1</span></span>. A <b>weak factorization system</b> in a category \(C\) is pair of classes of
morphisms \((L,R)\) such that every morphism factors into \(g\circ f\) where \(g \in R,f \in L\), and \(R = L^{\oslash }\), \(L = \phantom {}^\oslash R\).
</p>

</li>

</ul>

</div>

<p>
It follows that \(L\) is saturated, and \(R\) is cosaturated. \((\rightarrow ,\cong ),(\cong ,\rightarrow )\) are always trivial weak factorization systems. There is a weakening of the axioms for weak factorization systems
that is equivalent.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-264"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.2</span></span>. <a id="weakfactorizationrecognition"></a> Two classes \(L,R\) form a weak
factorization system iff they satisfy
</p>
<ul style="list-style-type:none">


<li>
<p>
(W1) \(L,R\) are closed under retracts
</p>


</li>
<li>


<p>
(W2) \(L,R\) have the left/right lifting properties with respect to each other
</p>


</li>
<li>


<p>
(W3) Any morphism factors as \(g\circ f\) where \(g \in L\), \(f \in R\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-265"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Clearly these are implied by the definition of a weak factorization system. Conversely, it will suffice by duality to show that if a morphism \(f\) has the left lifting property with
respect to all morphisms in \(R\), it is in \(L\). But we can factor \(f = g\circ h\) with \(h \in L, g \in R\). But finding a lift in the diagram below shows \(f\) is a retract of \(h\).
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-25"
      class="lateximagesource"
><!--
        h
·           ·
    f           g

·           ·
--><img
      src="Simplicial_h-images/image-25.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-269"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.3</span></span>. A <b>homotopical</b> category is a category with a subcategory \(W\) (weak
equivalences) containing all objects and satisfying \(2\) out of \(6\).
</p>

</li>

</ul>

</div>

<p>
It follows that \(W\) contains all isomorphisms. There are two trivial homotopical structures, the minimal one, which is just isomorphisms, and the maximal one, which contains all morphisms. I think the minimal one is only useful
for receiving maps (derived functors), and the maximal one is useful because its homotopy category is essentially the homotopy type of the nerve. A <b>homotopical functor</b> between homotopical categories preserves weak
equivalences. If \(D\) has the minimal homotopical structure, homotopical functors \(C \to D\) are the same as functors \(h(C)\to D\).
</p>

<p>
The <b>homotopy (\(\infty \)-)category</b> of a homotopical category is its localization under weak equivalences. In otherwords, it is the universal \(\infty \)-category receiving a map from it that such that the weak
equivalences are sent to equivalences. The homotopy \(1\)-category is the \(1\)-coskeleton of this, given by \(1\)-categorical localization.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-270"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.4</span></span>. A homotopical category is <b>saturated</b> if \(W\) is exactly the class of morphisms
that are inverted in its homotopy \(1\)-category.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-271"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.5</span></span>. A <b>(closed) model category</b> \(C\) is a category equipped with three classes of
arrows: <b>cofibrations</b> (\(\rightarrowtail \)), <b>fibrations</b> (\(\twoheadrightarrow \)) and <b>weak equivalences</b> (\(\xrightarrow {\sim }\)) satisfying the following axioms:
</p>
<ul style="list-style-type:none">


<li>
<p>
(CM1) \(C\) has all finite colimits and colimits
</p>


</li>
<li>


<p>
(CM2) Weak equivalences satisfy \(2\) out of \(3\)
</p>


</li>
<li>


<p>
(CM3) \((\overset {\sim }{\rightarrowtail }, \twoheadrightarrow ), (\rightarrowtail ,\overset {\sim }{\twoheadrightarrow })\) form weak factorization systems.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
Note that the definition is self-dual. Observe that for a model category, any pair of classes cofibrations, fibrations, weak equivalences determines the third.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-272"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.6</span></span>. <a id="homotopicaladjunction"></a> Given an adjunction \(\adjunction
{F}{C}{D}{G}\) between homotopical categories \(C,D\) where \(F,G\) are homotopical, there is an induced adjunction \(\adjunction {F}{hC}{hD}{hG}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-273"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The data of an adjunction is the same as giving the counit and unit maps that satisfy some identities. Since \(F,G\) are homotopical, they descent to functors on \(hC\) and
\(hD\), and so do the unit and counits, and the diagrams still commute. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
A main step in producing model categories is in producing factorization systems. The following, Quillen’s small object argument, produces functorial factorizations under general conditions from a starting class of morphisms. In
particular, if a category is presentable, the conditions are satisfied.
</p>

<p>
The following definition is slightly nonstandard.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-274"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.7</span></span>. Let \(\kappa \) be a regular cardinal. \(x \in C\) is \(\kappa \)-small if the functor it
corepresents preserves \(\alpha \)-composites for any \(\alpha \geq \kappa \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-275"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.8</span></span><span class="amsthmnoteplain"> (Small object argument)</span>. <a
id="smallobjectargument"></a> Let \(J\) be a set of maps in \(C\), and suppose \(C\) is cocomplete. If the codomains of elements of \(J\) are \(\kappa \)-small, then there is a functorial factorization making \((\phantom
{}^\oslash (J^{\oslash }),J^{\oslash })\) into the smallest weak factorization system containing \(J\). Moreover, \(\phantom {}^\oslash (J^{\oslash })\) is the weak saturation of \(J\), or alternatively retracts of
morphisms coming from this construction.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-276"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(f:X \to Y\) be our map and let \(A_f\) be the set of all commutative squares \(S\) of the form
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-26"
      class="lateximagesource"
><!--
      Sx
SA         X
 Sα
      Sy
SB         Y
--><img
      src="Simplicial_h-images/image-26.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
where \(S_\alpha \in J\). Now consider the pushout diagram:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-27"
      class="lateximagesource"
><!--
                `
`                   Sx
    S∈Af SA              X
       `
           Sα
`
    S∈Af SB              X1
--><img
      src="Simplicial_h-images/image-27.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
There is a canonical projection \(f_1:X_1\to Y\) given by the \(S_y\) and \(f\), and the construction of \(X_1\) is functorial. Moreover, \(X \to X_1\) is in \(\phantom {}^\oslash (J^{\oslash })\), and for any diagram in
\(A\), there is a canonical lift on \(X_1\). Now we can inductively define \(f_\alpha , X_\alpha \) for any limit ordinal. Namely, \(X_{\alpha +1},f_{\alpha +1} = (X_{\alpha })_1,(f_{\alpha })_1\). For a limit ordinal,
define it to be the limit. of the \(X_i,f_i\) before it. Then \(X \to X_{\kappa }\) is in \(\phantom {}^\oslash (J^{\oslash })\) as it is a transfinite composite of such things, and \(f_{\kappa }:X_{\kappa } \to Y\) is in
\(J^{\oslash }\) since the codomains are \(\kappa \)-small.
</p>

<p>
This verifies factorization in a functorial way. The lifting property comes from Lemma <a href="node-Technical-Things.html#factorizationsystemsaturation">2.11</a>, so this is a weak factorization system, and it is clearly
the minimal one containing \(J\) on the left. We have only used the operations in the weak saturation of \(J\) to construct the factorization, so by Lemma <a
href="node-Model-Categories.html#weakfactorizationrecognition">4.2</a>, \(\phantom {}^\oslash (J^{\oslash })\) is the weak saturation of \(J\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-283"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.9</span></span>. A model category is <b>cofibrantly generated</b> if its factorization systems are
generated (on the left) by a set of morphisms.
</p>

</li>

</ul>

</div>

<p>
The factorization systems of a category \(C\) form a poset, where \((L,R) \leq (L&apos;,R&apos;)\) iff \(L \subset L&apos;\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-284"></a>
<span class="amsthmnamedefinition">Question</span><span class="amsthmnumberdefinition"> <span class="textup">4.10</span></span>. What are all weak factorization systems in which every arrow is in either
class?
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-285"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.11</span></span>. We can easily classify nontrivial weak factorization systems \((L,R)\) in
\(\Set \). Let \(\hookrightarrow &apos;,\twoheadrightarrow ,\phi \) denote the classes of injections from a nonempty set, surjections, and maps from the empty set respectively, where we additionally include isomorphisms.
</p>

<p>
The first observation is that for any nontrivial map from the empty set \(f\), \(\phantom {}^\oslash f =f^{\oslash } = \hookrightarrow &apos;\cup \twoheadrightarrow \). So the model structures on \(\Set \) are just
model structures on nonempty sets (temporarily called \(C\)) with \(\phi \) attached to either \(L\) or \(R\). So from now on we work in \(C\).
</p>

<p>
Suppose \(f \in L\) that isn’t injective. Then the map \(\cdot \cdot \to \cdot \) is a pushout of \(f\). The maps with the right lifting property with respect to this are the injections. The maps with the left lifting property
with respect to injections are the surjections, giving \((\twoheadrightarrow ,\hookrightarrow &apos;)\). .
</p>

<p>
If in addition there is a nonempty nontrivial injection in \(L\), then \(R\) has to be just isomorphism.
</p>

<p>
If \(L\) has instead a map which isn’t surjective, \(R\) has all surjections, and we see \(L\) has to be injection, giving \((\hookrightarrow &apos;,\twoheadrightarrow )\). Any additional maps in \(L\) would again make it
everything.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-286"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.12</span></span>. <a id="posetfactorizationsystems"></a> Consider a poset \(P\) as a
category. \(f \oslash g\) iff \(\cod f \leq \dom g\) whenever \(f \leq g\). We can obtain a large family of weak factorization systems \((\rightarrowtail ,\twoheadrightarrow )\) by choosing a family of arrows \(A\)
such that \(a \leq b, a \in A \implies b \in A\), and declaring all arrows of \(A\) along with isomorphisms to be \(\rightarrowtail \), and all other nonidentity arrows along with isomorphisms to be
\(\twoheadrightarrow \).
</p>

<p>
For example, on \(\Delta ^1\times \Delta ^1\), the only weak factorization system (up to automorphisms) not coming from this construction is
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-28"
      class="lateximagesource"
><!--
·   ·

·   ·
--><img
      src="Simplicial_h-images/image-28.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
\(\Delta ^1\times \Delta ^1\) can be used to construct an example of factorization systems \((\rightarrowtail ,\overset {\sim }{\twoheadrightarrow }) \leq (\overset {\sim }{\rightarrowtail },
\twoheadrightarrow )\) that don’t come from a model structure. In particular, consider the diagram below:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-29"
      class="lateximagesource"
><!--
·       ·




∼




        ∼
    ∼
·       ·
--><img
      src="Simplicial_h-images/image-29.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Another example comes from the poset \(\Delta ^2\), where we use the following pair of weak factorization systems:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-30"
      class="lateximagesource"
><!--
        ·




        ∼
·   ∼   ·
--><img
      src="Simplicial_h-images/image-30.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
These don’t come from model structures because the weak equivalences wouldn’t satisfy \(2\) out of \(3\).
</p>

</li>

</ul>

</div>

<p>
The last part of Example <a href="node-Model-Categories.html#posetfactorizationsystems">4.12</a> shows two obstructions to two factorization systems \((\rightarrowtail ,\overset {\sim }{\twoheadrightarrow
}) \leq (\overset {\sim }{\rightarrowtail }, \twoheadrightarrow )\) giving rise to a model structure. These are the only obstructions, as shown below.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-296"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.13</span></span>. Let \(C\) have finite limits and colimits. \((\rightarrowtail ,\overset {\sim
}{\twoheadrightarrow }) \leq (\overset {\sim }{\rightarrowtail }, \twoheadrightarrow )\) are the factorization systems of a model structure iff \(\overset {\sim }{\twoheadrightarrow }\cup \overset {\sim
}{\rightarrowtail }\) satisfies \(3\) out of \(4\) with respect to \(\twoheadrightarrow \cup \rightarrowtail \), and \(\overset {\sim }{\twoheadrightarrow }, \overset {\sim }{\rightarrowtail }\) satisfy
\(2\) out of \(3\) with respect to \({\twoheadrightarrow }, {\rightarrowtail }\) respectively.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-297"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Those conditions are necessary for weak equivalences to satisfy \(2\) out of \(3\). In the proof of sufficiency, we declare an arrow \(f\) to be a weak equivalence if it factors as \(h
\circ f\), where \(h\) is a trivial fibration and \(f\) a triival cofibration. Because of \(3\) out of \(4\) and the fact that we have a factorization system, this is equivalent to \(f\) factoring as a composite of maps that are either
trivial fibrations or trivial cofibrations.
</p>

<p>
First we observe that the trivial fibrations are the fibrations that are weak equivalences and dually for cofibrations. Indeed, a trivial fibration by assumption is a fibration, and the trivial factorization shows it is a weak equivalence.
If \(f\) is a trivial fibration and a week equivalence, then factoring it as a trivial fibration and cofibration and lifting as in the diagram below shows that it is a retract of a trivial fibration.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-31"
      class="lateximagesource"
><!--
·       ·
            f




∼
    ∼
·       ·
--><img
      src="Simplicial_h-images/image-31.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
It remains then to show weak equivalences satisfy \(2\) out of \(3\).
</p>

<p>
First we can observe that any composite of weak equivalences is a weak equivalence because it can be factored a composite of trivial fibrations and cofibrations. Now suppose \(h = g\circ f\) where \(f,h\) are weak equivalences.
We can factor \(g\) into a fibration \(g&apos;\) and trivial cofibration, which we can absorb into \(f\). Then factor \(f,h\) as \(f&apos; \circ f&apos;&apos;,h&apos;\circ h&apos;&apos;\), trivial cofibrations followed by a
trivial fibration. Because of \(2\) out of \(3\), it suffices to show that \(g \circ f&apos;\) is a trivial fibration. But this follows from the \(3\) out of \(4\) property on the square \((g \circ f&apos;) \circ f&apos;&apos; =
h&apos;\circ h&apos;&apos;\). The other part of \(2\) out or \(3\) is dual. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Note that such a model structure is necessarily unique. In practice, we are often supplied a notion of weak equivalence satisfying two out of three. This makes it a bit easier to check something is a model category. Here are two ways
in which that can be realized.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-301"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.14</span></span>. <a id="checkonemodelstructure"></a> Let \(C\) have finite limits and colimits.
Suppose we have two factorization systems \((\rightarrowtail ,\overset {\sim }{\twoheadrightarrow }) \leq (\overset {\sim }{\rightarrowtail }, \twoheadrightarrow )\) and a notion \(\xrightarrow {\sim
}\) of weak equivalence satisfying \(2\) out of \(3\) and such that \(\overset {\sim }{\twoheadrightarrow } = \xrightarrow {\sim }\cap \twoheadrightarrow \) and \(\overset {\sim }{\rightarrowtail } \subset
\xrightarrow {\sim }\). Then this data gives a model structure.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-302"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It suffices to check that \(\xrightarrow {\sim }\cap \rightarrowtail \subset \overset {\sim }{\rightarrowtail }\). But we can factor a weak equivalence as a triival
cofibration and trivial fibration, and if it is also a cofibration lift the square of this factorization to see that it is a a retract of a trivial cofibration. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-303"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.15</span></span>. <a id="adjunctioninducedmodelstr"></a> Let \(\adjunction {F}{C}{D}{U}\) be
an adjunction, suppose that \(D\) is bicomplete, \(C\) has a model structure cofibrantly generated by \(\kappa \)-small objects that are sent to \(\kappa &apos;\)-small objects in \(D\). We can try to define a model structure by
having a map in \(D\) be a fibration or weak equivalence if it is after applying \(U\). Suppose that if \(f \in D\) has the left lifting property with respect to \(g\) such that \(Ug\) is a fibration, then \(Uf\) is a weak equivalence.
Then we get a cofibrantly generated model structure generated by \(Fi\) where \(i\) are the generators for \(C\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-304"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The condition on fibrations and weak equivalences clearly determines the model structure if it exists. We can construct our factorizations via Proposition <a
href="node-Model-Categories.html#smallobjectargument">4.8</a> since the generators of the factorization systems for \(D\) are \(F\) applied to the ones for \(C\) by the adjunction, and these are sent to \(\kappa \)-small
objects. \(2\) out of \(3\) is clear so by Lemma <a href="node-Model-Categories.html#checkonemodelstructure">4.14</a> and the last assumption, we are done. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-305"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.16</span></span>. The <b>Serre model structure</b> on the category \(\CGHaus \) has the
cofibrations generated by \(|\Lambda ^n_i|\subset |\Delta ^n|\) and the trivial cofibrations are generated by \(|\partial _n \Delta ^n| \subset |\Delta ^n|\), and a weak equivalence to be a weak homotopy
equivalence. \((CM1), (CM2)\) are clearly satisfied. By Lemma <a href="node-Kan-Fibrations.html#trivfibrationhomotopygroupsSerre">3.18</a>, a fibration is a trivial fibration iff it is a weak equivalence. Moreover,
trivial cofibration of the construction in Proposition <a href="node-Model-Categories.html#smallobjectargument">4.8</a> are weak equivalences since they are the inclusion of a deformation retract. Thus any trivial
cofibration is since it is a retract of the construction. By Lemma <a href="node-Model-Categories.html#checkonemodelstructure">4.14</a> we are done.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-306"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.17</span></span>. The <b>Quillen model structure</b> on \(\SSet \) has cofibrations
generated by \(\Lambda ^n_i \subset \Delta ^n\), and trivial cofibrations generated by \(\partial \Delta ^n \subset \Delta ^n\). From the Proposition <a
href="node-Model-Categories.html#smallobjectargument">4.8</a>, these give factorization systems where the cofibrations are anodyne extensions, and the trivial cofibrations are inclusions by Lemma <a
href="node-Technical-Things.html#genincl">2.17</a>. A map \(X \to Y\) is a weak equivalence if it induces an isomorphism on \(\pi _n\) after passing to fibrant replacements. This agrees with the usual notion of weak
equivalence for fibrant things, and \((CM1), (CM2)\) are satisfied. Now given a Kan fibration, by Proposition <a href="node-Kan-Fibrations.html#trivfibrationhomotopygroups">3.7</a> it is an isomorphism on homotopy
groups iff it is trivial. By Proposition <a href="node-Kan-Fibrations.html#homotopgroupsagree">3.16</a>, \(X \to Y\) is a weak equivalence iff \(|X| \to |Y|\) is in the Serre model structure. Moreover, the realization of a
cofibration is a cofibration, so since \(|\Lambda ^n_i| \subset |\Delta ^n|\) is a weak equivalence, and the set of cofibrations such that \(|X|\to |Y|\) is an equivalence is weakly saturated, all trivial cofibrations are weak
equivalences. Thus by Lemma <a href="node-Model-Categories.html#checkonemodelstructure">4.14</a> we are done.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-307"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.18</span></span>. <a id="liftslice"></a> Suppose \(f\oslash g\) in a category \(C\). Then for any
functor \(D \to C\) \(\tilde {f}\oslash \tilde {g}\) in \(C_{/D}\) if \(\tilde {f}\) is a lift of \(f\) and \(\tilde {g}\) is a lift of \(g\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-308"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Any solution of the lifting problem in \(C\) will actually be a solution in \(C/D\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-309"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.19</span></span>. <a id="liftfactsysslice"></a> Given a factorization system \((\rightarrowtail
,\twoheadrightarrow )\) in a category \(C\) and a functor \(D \to C\), the morphisms in \(C_{/D}\) projecting to this factorization system form a factorization system.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-310"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This is a consequence of Lemma <a href="node-Model-Categories.html#liftslice">4.18</a> and the fact that any factorzation will automatically becoma a relative
factorization. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-311"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.20</span></span>. <a id="slicemodelstructure"></a> Given a model category \(C\) and a functor \(D
\to C\), the category \(C_{/D}\) has a model structure where the forgetful functor \(C_{/D} \to C\) preserves weak equivalences, cofibrations, and fibrations.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-312"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Finite limits and colimits exist in \(C_{/D}\), and weak equivalences satisfy \(2\) out of \(3\). By Lemma <a
href="node-Model-Categories.html#liftfactsysslice">4.19</a>, we can lift the factorization systems, so we are done. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-313"><span class="sectionnumber">4.1&#x2003;</span>Homotopy category of a model category</h5>
<a id="Simplicial_h-autopage-313"></a>


<p>
The model structure gives a handle on the associated homotopy category. For example it is possible to construct a mapping space from cofibrant objects to fibrant objects that agrees with the mapping space in the \(\infty
\)-category. We will start by understanding the homotopy \(1\)-category, denoted \(h(C)\). If \(A\) is an object of \(C\), define a <b>cylinder object</b> of \(A\), denoted \(\Delta ^1A\) (resembling \(\Delta ^1\times A\))
to be a factorization
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-32"
    class="lateximagesource"
><!--
A∪A
  i    ∇

       ∼
∆1 A       A
--><img
    src="Simplicial_h-images/image-32.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
Where \(\nabla \) is the fold map. The dual notion is a <b>path object</b> of \(B\), denoted \(B\Delta ^1\) (resembling \(B^{\Delta ^1}\)). Cylinder objects always exist, and furthermore we can always make the weak
equivalence also a fibration.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-317"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.21</span></span>. Given a cylinder object, a <b>left homotopy</b> from \(f\) to \(g\) is a commutative
diagram:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-33"
      class="lateximagesource"
><!--
A∪A
       f,g
  i

∆1 A         B
--><img
    src="Simplicial_h-images/image-33.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

</li>

</ul>

</div>

<p>
\(f,g\) are <b>left homotopic</b> if there is a left homotopy with respect to some cylinder. If \(f, g\) are left homotopic via some cylinder, \(hf, hg\) are too. There is also a dual notion of right homotopy.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-321"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.22</span></span>. Let \(A\) be cofibrant. Then the components of \(i\) are trivial cofibrations, and left
homotopy is an equivalence relation.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-322"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By pushing out the initial maps to the two factors \(A\), we see that each of the inclusions into \(A\cup A\) is a cofibration, so the components of \(i\) are as well. Moreover,
since the map \(\Delta ^1A \to A\) is a weak equivalence, by the \(2\) out of \(3\) property, so are the components of the inclusion.
</p>

<p>
Reflexivity of left homotopy comes from the canonical map \(\Delta ^1A \to A\). Symmetry comes from swapping the factors. Transitivity follows by observing that we can pushout two left homotopies and two cylinders along a
common map to get another homotopy and cylinder. We need \(A\) to be cofibrant so that the pushout is also a cylinder. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-323"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.23</span></span>. <a id="equivalentleftrighthomotopiesmodelcat"></a> TFAE when \(A\) is
cofibrant, \(B\) is fibrant, \(f,g\) are maps \(A \to B\):
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(f,g\) are left homotopic
</p>


</li>
<li>


<p>
2. \(f,g\) are right homotopic
</p>


</li>
<li>


<p>
3. \(f,g\) are left homotopic with respect to a fixed cylinder object.
</p>


</li>
<li>


<p>
4. \(f,g\) are right homotopic with respect to a fixed cylinder object.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-324"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It will suffice to show by duality that if we have a right homotopy, and a cylinder object \(\Delta ^1A\) for \(A\), then \(f,g\) are left homotopic with respect to \(\Delta
^1A\). Let \(p_0,p_1\) be the components of the projection \(B\Delta ^1 \to B\times B\), let \(\sigma :      B\to B\Delta ^1\) be the equivalence coming from the path structure, and let \(h\) be the right homotopy. Then
the map \(p_1\gamma \) in the diagram below is a left homotopy.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-34"
      class="lateximagesource"
><!--
       σf,h
A∪A                B∆1
       γ
  i                p0
               f
∆1 A       A        B
--><img
      src="Simplicial_h-images/image-34.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We will call a map \(\gamma :\Delta ^1A \to B\Delta ^1\) such that the diagram in Proposition <a href="node-Model-Categories.html#equivalentleftrighthomotopiesmodelcat">4.23</a> commutes a
<b>correspondence</b> between the left and right homotopies.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-328"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.24</span></span><span class="amsthmnoteplain"> (Whitehead)</span>. <a
id="whiteheadstheorem"></a> If \(f:X \to Y\) is a weak equivalence between cofibrant fibrant objects, it is a homotopy equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-329"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Since homotopy equivalences are closed under composition and we can factor a weak equivalence into a trivial fibration and cofibration, it suffices by duality to show it when \(f\)
is a trivial cofibration. If \(\cdot \) denotes the terminal object, let \(g\) denote a lift of the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-35"
      class="lateximagesource"
><!--
X       X
    g




∼
Y       ·
--><img
      src="Simplicial_h-images/image-35.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
By construction it is a left inverse so it suffices to show \(f \circ g\) is homotopic to the identity. This can be achieved by finding a lift in the diagram below.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-36"
      class="lateximagesource"
><!--
     σf
X           Y ∆1
     g        p




∼
Y   f g,1
            Y ×Y
--><img
      src="Simplicial_h-images/image-36.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Whitehead’s theorem has a converse.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-336"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">4.25</span></span>. <a id="homotopy1catofmodelcat"></a> The homotopy (1-)category of a model category
\(C\) is given by homotopy class of maps between cofibrant fibrant objects. Moreover, isomorphism in the homotopy category is the same as weak equivalence, so model categories are saturated homotopical categories.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-337"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It is ok to just think about the full essentially surjective subcategory of the homotopy category consisting of cofibrant fibrant objects. Now suppose we have a functor \(F:C \to
D\) inverting weak equivalences. Since the two inclusions into a cylinder are equal in the homotopy \(1\)-category, \(F\) factors through the category obtained by identifying homotopy classes of maps. By Lemma <a
href="node-Model-Categories.html#whiteheadstheorem">4.24</a>, weak equivalences are already isomorphism in this category, so the factorization is unique.
</p>

<p>
Now suppose that a map \(f:X \to Y\) is an isomorphism in the homotopy category. After passing to cofibrant fibrant replacements using the \(2\) out of \(3\) property, we can assume that our objects are cofibrant fibrant, so
that \(f\) has a homotopy inverse \(g\). Moreover, by factoring \(f\) into a trivial cofibration and fibration and using Lemma <a href="node-Model-Categories.html#whiteheadstheorem">4.24</a>, we can assume \(f\) is a
fibration. The strategy is to show that \(f\) has the right lifting property with respect to cofibrations. Let \(\Delta ^1X,\tilde {Y}\) be path objects for \(X,Y\), \(k\) a right homotopy from \(gf\) to the identity, and form the
diagram below given a map from a cofibration \(i\) to \(f\) given by maps \(\alpha ,\beta \):
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-37"
      class="lateximagesource"
><!--
       kα                    p1
A             X∆1                        X
i               p0 ,?                        f
    gβ,σβ               π2          p1
B           X ×Y Y ∆1        Y ∆1        Y
--><img
      src="Simplicial_h-images/image-37.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
If we could fill in the map \(?\) in a way that \((p_0,?)\) is a fibration and the diagram commuted, it would have to be a trivial fibration by the \(2\) out of \(3\) property for the composition with \(X\times _{\pi _2} Y \to
X\), so we could make the indicated lift and be done.
</p>

<p>
To make \(?\) we will choose a particularly nice right homotopy from \(gf\) to the identity by slightly modifying the dual construction of Proposition <a
href="node-Model-Categories.html#equivalentleftrighthomotopiesmodelcat">4.23</a>.
</p>

<p>
Let \(h:\Delta ^1X \to X\) be a left homotopy from \(gf\) to the identity, and \(s\) the map \(\Delta ^1X \to X\). Choose a path object \(Y\Delta ^1\) for \(Y\). We can make a path object \(X\Delta ^1\) for \(X\) with
a compatible fibration \(\hat {f}=?\) to \(Y\Delta ^1\) by factoring the map \((\Delta ,\sigma _Y f):         X \to (X\times X)\times _{Y\times Y} Y\Delta ^1\) as a trivial cofibration and fibration. Then create a lift \(Q\)
in the diagram below.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-38"
      class="lateximagesource"
><!--
                  σ
 X                            X∆1
                 Q
  i1                             π

∆1 X   ((h,s),σY f s)
                        (X × X) ×Y ×Y Y ∆1
--><img
      src="Simplicial_h-images/image-38.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
\(k=i_1Q\) is a right homotopy from \(gf\) to the identity with the extra property that \(\hat {f}k = \sigma _Yf\). This shows that the strategy works. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
To compute homotopy classes of maps, we don’t need both \(X,Y\) to be cofibrant fibrant.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-344"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.26</span></span>. <a id="modelcathomotopyclasses"></a> Let \(X\) be cofibrant and \(Y\) be fibrant
objects of a model category \(C\). Then \(\Hom _{hC}(X,Y)\) is the homotopy classes of maps between \(X\) and \(Y\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-345"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(X\) be cofibrant, and \(Y\) be fibrant. We can choose a cofibrant replacement \(Y&apos;\) with a trivial fibration to \(Y\). The induced map on homotopy classes of maps
from \(X\) is surjective since \(X\) is cofibrant. By looking at the map \(X \cup X \to \Delta ^1X\) in \(C_{X\cup X/}\), it is injective on homotopy classes. Making the dual argument we can reduce to the case when \(X,Y\)
are cofibrant and fibrant, where we can use Theorem <a href="node-Model-Categories.html#homotopy1catofmodelcat">4.25</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We now briefly examine the higher categorical structure on a model category. Let \(X\) be a semi-simplicial set. We will inductively define a semi-simplicial set of cylinders for \(A\), denoted \(\Cyl (A)\), where a map of a
\(X\)-cylinder object for \(A\) is denoted \(XA\). A <b>\(\Delta ^0\)-cylinder</b> is the data below.
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-39"
    class="lateximagesource"
><!--
 A
  i

       ∼
∆0 A       A
--><img
    src="Simplicial_h-images/image-39.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
Suppose we have defined the \(\Delta ^{n-1}\)-cylinders. Then a \(\Delta ^n\)-cylinder will be a choice of \(\partial {\Delta ^n}\)-cylinder and a diagram as below.
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-40"
    class="lateximagesource"
><!--
∂∆n A
  i
        ∼
∆n A        A
--><img
    src="Simplicial_h-images/image-40.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
Its boundary maps will be the ones coming from \(\partial \Delta ^nA\). Using \(\Cyl (A)\), we can define a semi-simplicial mapping space \(\Map _{\Cyl }(A,B)\) where the \(n\)-simplices are a choice of \(\Delta ^nA\)
and a map \(\Delta ^nA \to B\). There is a dual notion of \(\Path (B)\) and \(\Map _{\Path }(A,B)\). We can also force these to be simplicial sets by Kan extension.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-352"></a>
<span class="amsthmnamedefinition">Question</span><span class="amsthmnumberdefinition"> <span class="textup">4.27</span></span>. Is \(\Map _{\Cyl }(A,B)\) a semi-simplicial Kan complex? What about its
simplicialization? Can one canonically identify \(\Map _{\Cyl }(A,B)\) with \(\LMap (A,B)\) in the homotopy \(\infty \)-category (even with no conditions on \(A,B\))?
</p>

</li>

</ul>

</div>

<p>
In any case, \(\Cyl (A)\) has a very nice property that cells can be reordered. For example, there is an involution on the \(1\)-simplices given by swapping. This suggests it’s even better than a Kan complex. Maybe a
semi-simplicial structure is not the right thing but rather some other test category such as a globe or cube category is better. The following lemma suggests as much.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-353"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.28</span></span>. <a id="invhomotopymodelcat"></a> Given a left homotopy \(h:\Delta ^1X \to Y\)
from \(\alpha \) to \(\beta \) with structure map \(s:\Delta ^1X\to X\), the composite homotopy \(h^{-1}\circ h:\overline {\Delta ^1}X\to X\) is homotopic to the constant homotopy on \(\alpha \) via a map \(H\),
i.e there is a diagram as below:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-41"
      class="lateximagesource"
><!--
                   s,s
∆1 X ∪X∪X ∆1 X            X
                 j1 ,j2       π
h−1 ◦h,αs




                          ∼
        Y    H
                          X′
--><img
   src="Simplicial_h-images/image-41.svg"
   alt="(-tikz-&nbsp;diagram)"
   style=""
   class="lateximage"
></span>
</p>
</div>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-357"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Choose \(Y\Delta ^1\) with structure map \(\sigma \), and a correspondence \(\gamma \) between \(h\) and a right homotopy \(k\) on \(Y\Delta ^1\). \(\gamma \) glues on
\(\overline {\Delta ^1}X\cup _{X\cup X}\overline {\Delta ^1}X\) to give a map \(\overline {\gamma }\), so we can lift the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-42"
      class="lateximagesource"
><!--
                  γ,σαs
∆1 X ∪X∪X ∆1 X            Y ∆1
            K                  p0




                          ∼
   j1 ,j2

                 απ
       X′                  Y
--><img
      src="Simplicial_h-images/image-42.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
and the map \(p_1K=H\) works. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-361"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.29</span></span>. Suppose \(X,Y\) are cofibrant fibrant, and \(f:X \to Y\) is a trivial fibration. Then \(f\)
admits a section \(g\), and for any section there is a homotopy \(H:\Delta ^1X \to X\) from \(gf\) to the identity such that \(fH\) is the constant homotopy of \(f\) (i.e a fibrewise homotopy).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-362"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(f\) admits a section \(g\) by lifting the identity along \(f\), and since this is an inverse in the homotopy category, there is a left homotopy \(h:   \Delta ^1X \to X\) from the
identity to \(gf\). Let \(h^{-1}\) denote tha homotopy in the other direction obtained from swapping factors. \(gfh^{-1}\) is a homotopy from \(gf\) to itself, and let \(gfh^{-1}\circ h:\overline {\Delta ^1}X \to X\) be
the composite of the homotopies \(gfh^{-1}\) and \(h\).
</p>

<p>
By Lemma <a href="node-Model-Categories.html#invhomotopymodelcat">4.28</a> \(f(gfh^{-1}\circ h) = fh^{-1}\circ fh\) is homotopic to the identity via some homotopy \(H:X&apos; \to Y\), where \(i_L,i_R\)
are the inclusions \(\overline {\Delta ^1}X \to X&apos;\), we can create a lift \(K\) as below so that \(Ki_R\) will be the desired fibrewise homotopy.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-43"
      class="lateximagesource"
><!--
       gf h−1 ◦h
∆1 X               X
  iL   K
                       f
         H
X′                 Y
--><img
      src="Simplicial_h-images/image-43.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-366"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.30</span></span>. <a id="adjunctioninducedhypothesis"></a> Let \(\adjunction {F}{C}{D}{U}\)
be an adjunction, suppose that \(D\) is bicomplete, \(C\) has a model structure cofibrantly generated by \(\kappa \)-small objects that are sent to \(\kappa &apos;\)-small objects in \(D\). We can try to define a model structure
by having a map in \(D\) be a fibration or weak equivalence if it is after applying \(U\). If \(D\) has natural path objects \(P\) and a natural fibrant replacement \(Q\), we get a cofibrantly generated model structure generated by
\(Fi\) where \(i\) are the generators for \(C\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-367"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By Proposition <a href="node-Model-Categories.html#adjunctioninducedmodelstr">4.15</a>, it suffices to show if \(f \in D\) has the left lifting property with respect to
\(g\) such that \(Uf\) is a fibration, then \(Uf\) is a weak equivalence. Now produce a lift \(u\) of the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-44"
      class="lateximagesource"
><!--
A       QA
f   u


B       ·
--><img
      src="Simplicial_h-images/image-44.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Then construct a lift in the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-45"
      class="lateximagesource"
><!--
    i0
A         P QA      P QB
f          H


B        QB × QA   QB × QB
--><img
      src="Simplicial_h-images/image-45.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
, so that in the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-46"
      class="lateximagesource"
><!--
A       QA
f   u    Qf

B       QB
--><img
      src="Simplicial_h-images/image-46.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
The upper triangle commutes and the lower triangle does up to right homotopy. Applying \(U\) to this square, which preserves right homotopy, we see that \(UA \to UB\) is an isomorphism in the homotopy \(1\)-category of \(C\).
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-377"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnumberdefinition"> <span class="textup">4.31</span></span>. There is an alternate hypothesis that will make the proof of Proposition <a
href="node-Model-Categories.html#adjunctioninducedhypothesis">4.30</a> go through, but seems not as good. Namely, we can assume \(U\) preserves \(\kappa \)-sequential colimits instead of the assumption about the
generators being sent to small objects. Then we can use a variant of Proposition <a href="node-Model-Categories.html#smallobjectargument">4.8</a> to produce the factorization system. Namely, after countably many steps
in the small object argument, since \(U\) preserves \(\kappa \)-sequential colimits, we will be able to lift the generating cofibrations in \(C\).
</p>

</li>

</ul>

</div>

<p>
In a model category \(C\), under good conditions, triangles in \(hC\) can be lifted to \(C\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-378"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.32</span></span><span class="amsthmnoteplain"> (Lifting from the homotopy category)</span>. <a
id="hClifting"></a> Let \(C\) be a model category. Suppose we have a cofibration \(i:A \to B\), a morphism \(f:B \to C\) and a commutative triangle
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-47"
      class="lateximagesource"
><!--
    i
A              B
        [f ]
               ḡ

               C
--><img
      src="Simplicial_h-images/image-47.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
in \(hC\). Assume moreover that \(A,B\) are cofibrant and \(C\) fibrant. Then there is a morphism \(g\) such that \(g \circ i = f\) and \([g] = \bar {g}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-382"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Choose a homotopy \(A\cup A \to \Delta ^1A \to C\) between \(g&apos;f\) and \(i\) where \(g&apos;\) is any map whose homotopy class is \(\bar {g}\). We can choose
a compatible cylinder \(\Delta ^1A\coprod _{A\cup A} (B\cup B) \to \Delta ^1B \to B\) by factoring the natural map to \(B\) as a cofibration and a trivial fibration.
</p>

<p>
The homotopy naturally extends to \(\Delta ^1A \coprod _{A} B \to C\), and \(\Delta ^1A\coprod _AB \to \Delta ^1B\) is a trivial cofibration, so since \(X\) is fibrant, it extends to \(\Delta ^1B\), giving a homotopy
between \(g&apos;\) and a \(g\) solving the problem. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Weak equivalences are not generally preserved under pushouts. Here is a condition under which they are:
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-383"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.33</span></span>. <a id="pushoutstableweakeq"></a> Let \(C\) be a model category with a pushout
diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-48"
      class="lateximagesource"
><!--
     i
A           B
 j           j′
     i′
        ⌜
A′          B′
--><img
      src="Simplicial_h-images/image-48.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Suppose that \(A,A&apos;\) are cofibrant, \(i\) is a cofibration, and \(j\) is a weak equivalence. Then \(j&apos;\) is a weak equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-387"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We will show that \(j&apos;\) is an equivalence in the homotopy category. Let \(X\) be an object, and consider the map \(\Hom _{hC}(B&apos;,X) \to \Hom _{hC}(B,X)\). To
see it is surjective, observe that given a map \(f:B \to X\), we can homotope its restriction to \(A\) to something restricted from \(A&apos;\). By Proposition <a href="node-Model-Categories.html#hClifting">4.32</a>, the
original map can be homotoped to exhibit \(f\) as in the image.
</p>

<p>
To see injectivity, if \(s, s&apos;\) are two identified maps, then there is a commutative square
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-49"
      class="lateximagesource"
><!--
        h
B             X∆1
 j′
      s×s′′
B′            X ×X
--><img
      src="Simplicial_h-images/image-49.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
By the surjectivity statement in the category \(C_{/X\times X}\), there is a lift in this square, giving injectivity.
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-391"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.34</span></span>. A model category is <b>left proper</b> if weak equivalneces are closed under pushouts
by a cofibration.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-392"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.35</span></span>. A model category \(C\) where all objects are cofibrant is left proper.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-393"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This follows immediately from Lemma <a href="node-Model-Categories.html#pushoutstableweakeq">4.33</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We will now examine the notaion of a homotopy pushout square. It is a special case of homotopy colimits, but deserves special attention.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-394"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.36</span></span>. <a id="homotopypushoutdef"></a> A <b>homotopy pushout square</b> is a
commutative square that receives a level-wise equivalence from one of the form
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-50"
      class="lateximagesource"
><!--
A       B

    ⌜
C       D
--><img
      src="Simplicial_h-images/image-50.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
where \(A\) is cofibrant. Such a diagram is a <b>cofibrant pushout square</b>
</p>

</li>

</ul>

</div>

<p>
The pushout of a homotopy pushout square is given by taking the pushout of an equivalent cofibrant pushout square.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-398"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.37</span></span>. In a model category \(C\), the pushout of a homotopy pushout square is well defined up
to weak equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-399"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Suppose that there are two cofibrant pushout diagrams with a weak equivalence to a homotopy pushout square. We can find an equivalent cofibrant pushout diagram mapping to
each of them in a compatible way as follows: Take something mapping compatibly into both of the top left objects of the pushout squares, replace it with an equivalence from a cofibrant object \(X\). The same method in
\(C_{/X}\) yields an entire cofibrant pushout square mapping to each.
</p>

<p>
Thus it suffices to show that for any two cofibrant pushout squares, the pushout is an equivalence. Using Lemma <a href="node-Model-Categories.html#pushoutstableweakeq">4.33</a>, we can reduce to the case that we are
only changing the object in the upper left corner: if we change only one of the other objects by an equivalence, that Lemma along with gluing for pushout squares implies the result.
</p>

<p>
Furthermore, we can factor the induced map on the upper left vertex into a trivial cofibration and trivial fibration. In the case of a trivial fibration, there is a section since the objects are cofibrant, so picking a section, we there is
another pushout square between the diagonals of the pushout squares, and we are done using Lemma <a href="node-Model-Categories.html#pushoutstableweakeq">4.33</a> again. Thus we can assume that the map in the
upper left hand corner is a trivial cofibration, in which case it has a retraction. This induces a retraction on the pushout, showing that the pullback map is surjective on homotopy classes of maps to any space. By again mapping to
\(X\Delta ^1\) relative to \(X\times X\), we see it is injective as well on homotopy classes, so the map on pushouts is an equivalence. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We can often detect homotopy pushout squares in non-cofibrant diagrams
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-400"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.38</span></span>. A coCartesian square in a model category \(C\)
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-51"
      class="lateximagesource"
><!--
A       B

    ⌜
E       D
--><img
      src="Simplicial_h-images/image-51.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is a homotopy pushout square if either of the following conditions are satisfied:
</p>

<ul style="list-style-type:none">


<li>
<p>
• \(A,B\) are cofibrant.
</p>


</li>
<li>


<p>
• \(C\) is left proper.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-404"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Take a cofibrant replacement of the pushout square, and observe that it induces an equivalence on the pushout by either using Lemma <a
href="node-Model-Categories.html#pushoutstableweakeq">4.33</a> under the first hypothesis, or the fact that \(C\) is left proper. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-405"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnumberdefinition"> <span class="textup">4.39</span></span>. In fact left proper model categories are characterized as those where pushouts
along cofibrations are homotopy pushouts.
</p>

</li>

</ul>

</div>

<p>
As an example, we can prove the Mayer-Vietoris sequence on homotopy for a homotopy pullback square.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-406"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.40</span></span>. <a id="mayervietorisfibreproduct"></a> Given a homotopy pullback square of
simplicial sets
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-52"
      class="lateximagesource"
><!--
E′       E
     ⌟

B′       B
--><img
      src="Simplicial_h-images/image-52.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Given choices of basepoints, there is a natural Mayer-Vietoris long exact sequence of homotopy groups
</p>

<p>
\[ \pi _n(E&apos;) \to \pi _n(E) \oplus \pi _n(B&apos;) \to \pi _n(B) \to \pi _{n-1}(E&apos;) \to \pi _{n-1}(E) \oplus \pi _{n-1}(B&apos;) \]
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-410"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG, we can assume that the diagram is a pullback square of fibrant objects and the maps \(E&apos;\to B\), \(E\to B\) are fibrations. Then by Proposition <a
href="node-Kan-Fibrations.html#homotopylongexactsequence">3.4</a>, there are long exact sequences associated to both fibrations, and the fibres can be identified. We can view the map between the long exact sequences as
a double complex with two nontrivial rows. Since the rows are exact, the total complex is exact. But the total complex is the Mayer-Vietoris long exact sequence with an extra copy of \(\pi _n\) of the fibres that can be removed
since the fibres are just identified. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-411"><span class="sectionnumber">4.2&#x2003;</span>Combinatorial Model Categories</h5>
<a id="Simplicial_h-autopage-411"></a>


<p>
Combinatorial model categories are a large class of model categories that are well behaved. Morally, they are the same as presentable \(\infty \)-categories. Pretty much every reasonable model category should be Quillen
equivalent to a combinatorial one. For example, the category \(\Top \) of topological spaces isn’t presentable, but \(\SSet \) is.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-412"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.41</span></span>. A <b>combinatorial model category</b> \(C\) is a model category that is
presentable and cofibrantly generated.
</p>

</li>

</ul>

</div>

<p>
Our goal will be to show that it is easy to produce these.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-413"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.42</span></span>. <a id="comblemma1"></a> Let \(\tau &gt; \kappa \) be regular cardinals and let \(C
\xrightarrow {p} D \xleftarrow {p&apos;} C&apos;\) be functors that are \(\kappa \)-cofinal, that preserve \(\tau \)-small \(\kappa \)-filtered colimits, and suppose that \(C,C&apos;,D\) are \(\kappa \)-filtered, \(\tau
\)-small, and admit \(\tau \)-small \(\kappa \)-filtered colimits. Then there exist objects \(X \in C, X&apos; \in C&apos;\) such that \(p(X) \cong p&apos;(X&apos;)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-414"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Say an ordinal is even if it is a limit ordinal plus an even number, and odd otherwise. Let \((\kappa )\) be the poset of ordinals of size \(&lt;\kappa \) and let \((\kappa )_0\)
and \((\kappa )_1\) denote the even and odd ones respectively.
</p>

<p>
Suppose we can construct a commutative diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-53"
      class="lateximagesource"
><!--
(κ)0       (κ)        (κ)1

       p         p′
 C         D          C′
--><img
      src="Simplicial_h-images/image-53.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Then since \(\kappa _0\) and \(\kappa _1\) are cofinal in \((\kappa )\), their colimits in \(D\) are isomorphic, but this agrees with the image of their colimits in \(C,C&apos;\).
</p>

<p>
We can construct such a diagram inductively. On limit ordinals, we can extend by taking the colimit in either \(C\) or \(C&apos;\). On sucessor ordinals, we can extend because we assumed that \(p,p&apos;\) are \(\kappa
\)-cofinal. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-418"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.43</span></span>. <a id="comblemma2"></a> Let \(\tau \gg \kappa \) be regular cardinals with \(\tau
&gt; \kappa \), \(D\) a presentable category, and \(C_a,D_b, a \in A,b \in B\) \(\tau \)-filtered partially diagrams in \(D\) such that their colimits agree. Then for every pair of \(\tau \)-small subcategories \(A_0 \subset
A, B_0 \subset B\), there exist \(\tau \)-small \(\kappa \)-filtered subsets \(A&apos; \supset A_0\), \(B&apos; \supset B_0\) such that the colimits of \(A&apos;\) and \(B&apos;\) agree.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-419"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(P_A,P_B\) be tha poset of \(\tau \)-small \(\kappa \)-filtered subsets of \(A\) (resp \(B\)) which contain \(A_0\) (or \(B_0\)).Let \(X\) be the common colimits and
consider the maps \(P_A,P_B \to D_{/X}\) given by taking colimits. Then applying Lemma <a href="node-Model-Categories.html#comblemma1">4.42</a> to this situation, we are done. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-420"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.44</span></span>. <a id="accessiblesubcat"></a> Let \(\kappa \) be a regular cardinal \(C_0\subset
C\) a subcategory of a presentable category closed under \(\kappa \)-filtered colimits. \(C_0\) is \(\kappa \)-accessible iff the following condition is satisfied for all sufficiently large \(\tau \gg \kappa \):
</p>

<p>
Let \(X_{\alpha },\alpha \in A\) be a \(\tau \)-filtered diagram of \(\tau \)-compact objects in \(C\). For every \(\kappa \)-filtered subcategory \(B \subset A\), let \(X_B\) denote the colimit over \(B\). Then if
\(X_{A}\) belongs to \(C_0\), then for every \(\tau \)-small subcategory of \(B\), there is a \(C \supset B\) that is \(\tau \)-small, \(\kappa \)-filtered, and \(X_C\) is in \(C_0\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-421"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Choose \(\tau \) large enough so that \(C\) is \(\tau \)-presentable, let \(C^{\tau }\) be the \(\tau \)-compact objects. We’ll see that \(C^{\tau }\cap C_0\) generates
\(C_0\) under \(\kappa \)-filtered colimits. Given an object in \(C_0\), present it as a colimit of a filtered diagram \(A\). Let \(S\) be the collection of \(\tau \)-small \(\kappa \)-filtered subdiagrams of \(A\) such that the
colimit is in \(C_0\). We can then take the colimit over \(S\) of the colimits of subdiagrams of \(A\) to obtain the same object.
</p>

<p>
Conversely, suppose that \(C\) is generated under \(\kappa \)-filtered colimits by a small subcategory \(D \subset C_0\). Choose \(\tau \gg \kappa , \tau &gt; \kappa \) such that every object of \(D\) is \(\tau
\)-compact. To see that the condition is satisfied, suppose that we have a diagram \(X_{\alpha }, \alpha \in A\), with \(X_A \in C_0\) and \(A\) \(\tau \)-filtered. \(X_A\) is also the colimit over \(Y_{\beta }, \beta \in
B\) with \(B\) a \(\tau \)-small \(\kappa \)-filtered diagram in \(D\). By replacing \(B\) with the family of \(\tau \)-small \(\kappa \)-filtered subdiagrams of \(B\), and using the family \(Y_{B&apos;}\) for all such subsets,
we can assume that \(B\) is \(\tau \)-filtered. Now we can apply Lemma <a href="node-Model-Categories.html#comblemma2">4.43</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-422"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.45</span></span>. <a id="accessiblepreimage"></a> Given a morphism of presentable categories
preserving \(\kappa \)-filtered colimits, the preimage of a \(\kappa \)-accessible subcategory is \(\kappa \)-accessible.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-423"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.46</span></span>. <a id="accessiblecombmodelcat"></a> Let \(A\) be a combinatorial model category,
and \(W,F,\subset A^{[1]}\) the categories of weak equivalences, fibrations. Then \(F,F\cap W,W\) are accessible subcategories of \(A^{[1]}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-424"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The subcategory of \(\Set ^{[1]}\) consisting of surjections is accessible (everything is a \(\kappa \)-filtered colimit of finite surjections). For any morphism \(i:a\to b\), the
functor \(A^{[1]} \to \Set ^{[1]}\) sending \(f:x \to y\) to \(\Hom (b,x) \mapsto \Hom (b,y)\times _{\Hom (a,y)}\Hom (a,x)\) preserves filtered colimits if \(A,B\) are \(\kappa \)-compact.
</p>

<p>
\(F\) and \(W\cap F\) are obtained as the preimage of surjections on products of such maps (since they are defined via lifting properties with respect to a set of maps). Thus by Corollary <a
href="node-Model-Categories.html#accessiblepreimage">4.45</a> they are accessible.
</p>

<p>
By Proposition <a href="node-Model-Categories.html#smallobjectargument">4.8</a>, there is a functorial factorization into a trivial cofibration and fibration. \(W\) is exactly the preimage of those that factor as a trivial
cofibration and trivial fibration, so is accessible too. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-425"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.47</span></span>. <a id="combmodelcatlemma1"></a> Suppose that \(C,W\) are collections of morphism in
a presentable category \(A\) with the following properties:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(C\) is weakly saturated and is generated by a small set of morphisms \(C_0\).
</p>


</li>
<li>


<p>
2. \(C\cap W\) is weakly saturated.
</p>


</li>
<li>


<p>
3. \(W\) is an accessible subcategory of \(A^{[1]}\)
</p>


</li>
<li>


<p>
4. \(W\) satisfies \(2\) out of \(3\).
</p>
</li>
</ul>

<p>
Then \(C\cap W\) is generated as a weakly saturated class by a small subset.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-426"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Choose \(\kappa \) so that \(W\) is \(\kappa \)-accessible, choose \(\tau \gg \kappa , \tau &gt; \kappa \) such that Lemma <a
href="node-Model-Categories.html#accessiblesubcat">4.44</a> holds, \(C\) is \(\tau \)-accessible, and everything in \(C_0\) is \(\tau \)-compact. By Lemma <a
href="node-Technical-Things.html#accessiblecompacts">2.3</a>, we can replace \(C_0\) with \(C \cap A^{\tau }\).
</p>

<p>
Let \(S = C_0 \cap W\). We will show that \(S\) generates \(C \cap W\) as a weakly saturated class of morphisms. Let \(\overline {S}\) be the weak saturation of \(S\). Suppose that \(f:         X \to Y\) is a morphism in \(C
\cap W\). By Corollary <a href="node-Technical-Things.html#treecorollary">2.77</a>, there is a \(\tau \)-good \(C_0\)-tree \(\{Y_{\alpha }\}_{\alpha \in A}\) with root \(X\) such that \(Y\) is isomorphic to
\(Y_A\) as objects in \(C_{X/}\). Say that a subset \(B\) of \(A\) is <i>good</i> if it is downward-closed and the canonical map \(X \to Y_B\) is in \(W\). We would like to prove that \(A\) is good.
</p>

<p>
The set of good \(A\) is closed under transfinite union.
</p>

<p>
Suppose that \(B,B&apos; \subset A\) are such that \(B,B&apos;, B\cap B&apos;\) are good. Then \(B\cup B&apos;\) is good. To see this, we consider the pushout
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-54"
      class="lateximagesource"
><!--
YB∩B ′    YB


 YB ′    YB∪B ′
--><img
      src="Simplicial_h-images/image-54.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
The morphisms are all in \(C\), and the upper horizontal map is in \(W\) by \(2\) out of \(3\). Since \(C\cap W\) is closed under pushouts, the lower horizontal map is in \(W\) too, so by \(2\) out of \(3\) again, the map \(X \to
Y_{B&apos;} \to Y_{B&apos; \cup B}\) is in \(W\).
</p>

<p>
Next, observe that if \(B_0\subset A\) is \(\tau \)-small, then there is a \(\tau \)-small \(B\supset B_0\) such that \(Y_{B_0}\) is in \(C_0\), and so that \(B\) is good.
</p>

<p>
Next we will prove:
</p>

<ul style="list-style-type:none">


<li>
<p>
• Let \(A&apos;\) be a good subset of \(A\) and let \(B_0\subset A\) be \(\tau \)-small. Then there exists a \(\tau \)-small subset \(B_0 \subset B\subset A\) with \(B,B\cap A&apos;\) good.
</p>
</li>
</ul>

<p>
Start by setting \(B&apos;_0 = A \cap B_0\). We will inductively construct increasing sequences of \(\tau \)-small subsets \(B_i,B&apos;_i\) as follows: Choose \(B_{i+1}\) to be a \(\tau \)-small good subset of \(A\)
containing \(B_i \cup B&apos;_i\) and \(B&apos;_{i+1}\) to be a \(\tau \)-small good subset of \(A\) containing \(B_{i+1} \cap A&apos;\). Taking the union over \(i\), we will have proven the desired result.
</p>

<p>
Now there is no obstruction to making a good set larger, so \(A\) is good by Zorn’s Lemma. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Here is the desired converse:
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-430"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.48</span></span>. <a id="combmodelcatconstruct"></a> Let \(A\) be a presentable category and let
\(W\) and \(C\) be classes of morphisms in \(A\) with the following properties:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(C\) is weakly saturated and generated by a small set.
</p>


</li>
<li>


<p>
2. \(C\cap W\) is weakly saturated.
</p>


</li>
<li>


<p>
3. \(W\) is accessible.
</p>


</li>
<li>


<p>
4. \(W\) has the \(2\) out of \(3\) property.
</p>


</li>
<li>


<p>
5. \(W\subset C^{\oslash }\).
</p>
</li>
</ul>

<p>
Then \(C,W, (C\cap W)^{\oslash }\) give rise to a combinatorial model structure on \(A\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-431"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> A presentable category has finite limits and colimits. To see we get a model structure, we need to check that \((C,(C\cap W)^{\oslash })\) and \((C\cap W,C^{\oslash })\)
are weak factorization systems, which follows from Proposition <a href="node-Model-Categories.html#smallobjectargument">4.8</a>. To see it is combinatorial, we just observe that by Lemma <a
href="node-Model-Categories.html#combmodelcatlemma1">4.47</a>, \(C\cap W\) is generated by a small set in addition to \(C\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Our goal now is to get a more useable version of Corollary <a href="node-Model-Categories.html#combmodelcatconstruct">4.48</a>.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-432"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.49</span></span>. Let \(A\) be a presentable category. A class \(W\) of morphisms is <b>perfect</b> if it
satisfies the following conditions:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Every isomorphism belongs to \(W\), and \(W\) satisfies \(2\) out of \(3\).
</p>


</li>
<li>


<p>
2. \(W\) is stable under filtered colimits.
</p>


</li>
<li>


<p>
3. There exists a small set \(W_0 \subset W\) such that every morphism in \(W\) is a filtered colimit of morphisms in \(W_0\).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
The following is a corollary of Corollary <a href="node-Model-Categories.html#accessiblepreimage">4.45</a>.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-433"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.50</span></span>. For a functor between presentable categories that preserves filtered colimits, the pullback of
a perfect class of morphisms is perfect.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-434"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.51</span></span>. <a id="combmodelcatconstruct2"></a> Let \(A\) be a presentable category. Suppose
that \(W\) is a perfect class of morphisms and \(C_0\) is a small set of morphisms such that
</p>
<ul style="list-style-type:none">


<li>
<p>
1. For any pair of coCartesian squares:
</p>
<div class="center">
<p>
<span
      id="lateximage-Simplicial_h-55"
      class="lateximagesource"
><!--
       f
X              Y

           ⌜
X′             Y′
  g
           ⌜
X ′′           Y ′′
--><img
      src="Simplicial_h-images/image-55.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>
<p>
where \(f \in C_0\) and \(g \in W\), then \(g&apos; \in W\).
</p>


</li>
<li>


<p>
2. \(W \supset C_0^{\oslash }\).
</p>
</li>
</ul>

<p>
Then \(W\) and the saturation of \(C_0\) determine a combinatorial left proper model structure.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-438"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> First we will show left properness. First observe that \((2)\) actually holds for \(f\) in a weakly saturated set (this uses that \(W\) is stable under filtered colimits), so it holds for
\(C\), the weak saturation of \(C_0\).
</p>

<p>
To check the conditions of Corollary <a href="node-Model-Categories.html#combmodelcatconstruct">4.48</a>, we only need to check that \(C\cap W\) is weakly saturated. It is stable under retracts since \(W\) is stable
under filtered colimits. To see that \(C\cap W\) is stable under pushouts, we can factor any pushout as a pushout by a trivial fibration and a cofibration as below.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-56"
      class="lateximagesource"
><!--
          ∼
X   X′         X ′′
     f′          f ′′




∼
          h′
Y   Y′         Y ′′
--><img
      src="Simplicial_h-images/image-56.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
We then know by left properness that \(f&apos; \in C\cap W\) and hence again by left properness \(h&apos; \in W\). By the two out of \(3\) property \(f&apos;&apos; \in W\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-442"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnumberdefinition"> <span class="textup">4.52</span></span>. Combinatorial left proper model categories arising from Proposition <a
href="node-Model-Categories.html#combmodelcatconstruct2">4.51</a> are exactly those with \(W\) closed under filtered colimits.
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-443"><span class="sectionnumber">4.3&#x2003;</span>Derived Functors</h5>
<a id="Simplicial_h-autopage-443"></a>


<p>
A <b>left Quillen functor</b> between model categories is one that preserves (finite) colimits, cofibrations and trivial cofibrations. Dually there is a notion of right Quillen functor.
</p>

<p>
Quillen functors are useful because one can compute their derived functors.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-444"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.53</span></span>. If \(F:C \to D\) is a functor of homotopical categories, the <b>total left derived
functor</b>, denoted \(\LL F\) is the <em>right</em> Kan extension of the diagram:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-57"
      class="lateximagesource"
><!--
       F
 C           D

       LF
h(C)        h(D)
--><img
    src="Simplicial_h-images/image-57.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

</li>

</ul>

</div>

<p>
To help compute derived functors, we can use a deformation.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-448"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.54</span></span>. A <b>left deformation</b> on a homotopical category \(C\) is an endofunctor \(Q\)
with a natural weak equivalence \(q\) from \(Q\) to the identity.
</p>

</li>

</ul>

</div>

<p>
Let \(C_Q\) denote the full subcategory of objects in the image of \(Q\), also called a <b>left deformation retract</b>. A left deformation induces an equivalence between \(h(C)\) and \(h(C_Q)\). If we have a functorial map
from a cofibrant fibrant factorization in a model category, that is a left defomation.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-449"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.55</span></span>. a <b>left deformation</b> on a functor \(F:C \to D\) is a left deformation \(Q\) on
\(C\) such that \(F\) is homotopical on \(C_Q\).
</p>

</li>

</ul>

</div>

<p>
\(F\) is <b>left deformable</b> if it admits a left deformation. Any left deformable functor has a maximal subcategory on which it is homotopical (not proven here but uses 2 out of 6).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-450"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.56</span></span>. If \(F:C\to D\) between homotopical categories has a left deformation \(Q,q\), then
\(FQ\) induces a left derived functor of \(F\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-451"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(h_C\) denote the localization functor of \(C\). Since \(F\) is homotopical on \(C_Q\), \(h_DFQ\) does descend to a functor from \(h(C)\). \(h_DFq\) gives the natural
transformation we want. Instead of proving the universal property in \(h(D)^C\), it suffices to prove it in the equivalent full subcategory of \(h(D)^C\) consisting of homotopical functors. Now suppose that \(G\in h(D)^C\) is
homotopical and we have a natural transfromation \(\eta :G\to h_DF\). \(Gq:GQ\to G\) is a natural transformation that is a natural isomorphism since \(G\) is homotopical. Thus by naturality of \(\eta \), \(\eta \) factors as
\(h_DF q \circ \eta Q \circ (Gq)^{-1}\). Uniqueness follows from the fact that \(h_DFq\) is a natural isomorphism since \(q\) is a weak equivalence. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Morally here is how one can think about a deformation. When you invert weak equivalences, you really get an \(\infty \)-category, and we can expect left Kan extensions to be the \(1\)-categorical shadow of computing
(homotopy) colimits in the \(\infty \)-category, as is the formula for Kan extensions when enough colimits exist. The deformation allows you to \(1\)-categorically change your object to one that is homotopically good, so that the
\(\infty \)-categorical colimit agrees with the usual one.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-452"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnumberdefinition"> <span class="textup">4.57</span></span>. Maybe it’s worth mentioning that \(FQ\) is really an absolute Kan extension,
i.e it is preserved by post composition with all functors (including the representable ones, making it a pointwise Kan extension).
</p>

</li>

</ul>

</div>

<p>
There is really a pseudo \(2\)-functor taking a homotopical category \(C\) to \(h(C)\), a left deformable functor to its total left derived functor, and a natural transformation of such functors to the derived natural transformation.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-453"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.58</span></span><span class="amsthmnoteplain"> (Ken Brown’s Lemma)</span>. <a
id="kenbrown"></a> Let \(F:C\to D\) be a functor between model categories that sends trivial cofibrations between cofibrant objects to weak equivalences. Then \(F\) is homotopical on the category of cofibrant objects.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-454"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(f:X \to Y\) be a weak equivalence of cofibrant objects. Factor \(X \coprod Y \xrightarrow {f,1} Y\) as a cofibration and trivial cofibration, and consider the diagram
below.
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-58"
      class="lateximagesource"
><!--
ϕ               X
        `
    X       Y   j
                    f
        i
Y               Z




                    ∼
                        Y
--><img
      src="Simplicial_h-images/image-58.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
By \(2\) out of \(3\), \(i,j\) are weak equivalences, so they get sent to weak equivalences. But then since the map \(Z \to Y\) is a retraction of \(i\), it is also sent to a weak equivalence by \(2\) out of \(3\). Then \(f\) is too
by \(2\) out of \(3\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-458"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.59</span></span>. <a id="derivedfunctorsexistmodelcat"></a> If \(C\) has a functorial cofibrant
replacement, then a left Quillen functor is left deformable. In any case, the total left derived functor exists, and can be computed by taking a cofibrant replacement.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-459"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The first fact follows from <a href="node-Model-Categories.html#kenbrown">4.58</a> and second just requires the additional observation that the inclusion of the full
subcategory of cofibrant objects induces an equivalence on the homotopy category. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
An adjunction is called a <b>Quillen adjunction</b> if the left adjoint is left Quillen and similarly for the right adjoint.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-460"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.60</span></span>. <a id="quiladj"></a>TFAE for an adjunction \(F\dashv G\)
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(F\) is left Quillen
</p>


</li>
<li>


<p>
2. \(G\) is right Quillen
</p>


</li>
<li>


<p>
3. \(F\) preserves cofibrations and \(G\) preserves fibrations
</p>


</li>
<li>


<p>
4. \(F\) preserves trivial cofibrations and \(G\) preserves trivial fibrations.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-461"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The preserving limits and colimits is satisfied because of the adjunction. The equivalences then follow because of Lemma <a
href="node-Technical-Things.html#adjunctionlifting">2.13</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
A Quillen adjunction induces an adjunction on the homotopy \(1\)-categories. The same can be said of an adjoint pair of deformable functors between homotopical categories.
</p>

<p>
A Quillen adjunction is a <b>Quillen equivalence</b> if its derived functors are an equivalence.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-462"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.61</span></span>. A Quillen adjunction \(\adjunction {F}{C}{D}{G}\) is a Quillen equivalence iff when
\(c \in C\) is cofibrant and \(d \in D\) is fibrant, then \(Fc \to d\) is a weak equivalence iff the adjoint map \(c \to Gd\) is.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-463"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Suppose \(F\dashv G\) is a Quillen equivalence. Then for \(c\) cofibrant and \(d\) fibrant, \(F,G\) agree with the derived functors, so combined with the fact that weak
equivalences are the isomorphism in the homotopy category, the condition follows. Conversely if the condition holds, then the unit map \(c \to GFc\) is an isomorphism in \(h(C)\) since \(G\) is given by taking a fibrant
replacement and applying \(G\), so by the condition it is equivalent to \(Fc\) being isomorphic or weakly equivalent to the fibrant replacement. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
For example \(S\) and \(|\cdot |\) give a Quillen equivalence between the Serre and Quillen model structures.
</p>

<p>
Simplicial model categories are ones that have a compatible simplicial enrichment and tensoring/cotensoring. Many natural examples of model categories are simplicial model categories.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-464"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.62</span></span>. A <b>left Quillen bifunctor</b> \(\otimes :                   C \times D \to E\) is a map of
model categories preserving colimits in both variables, and such that the Construction <a href="node-Technical-Things.html#leibnizconstruction">2.26</a> \(\hat {\otimes }\) sends pairs of cofibrations to cofibrations
that are trivial iff either arrow is.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-465"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.63</span></span>. <a id="homotopicalcofibrant"></a> Left Quillen bifunctors preserve cofibrant objects
and are homotopical on the subcategories of cofibrant objects.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-466"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> These claims follow from the condition on \(\hat {\otimes }\) and Lemma <a href="node-Model-Categories.html#kenbrown">4.58</a>. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-467"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.64</span></span>. If \(\otimes ,\{,\},\hom \) form a two variable adjunction between model categories,
then one is a Quillen bifunctor iff the rest are.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-468"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This follows from Lemma <a href="node-Technical-Things.html#twovaradjunctionlifting">2.27</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-469"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.65</span></span>. Given a natural transformation \(\tau :F\to F&apos;\) between two functors
\(F,F&apos;\), the total derived natural transformation is the natural transformation \(L\tau \) given by cofibrant replacing and then doing the natural transformation.
</p>

</li>

</ul>

</div>

<p>
The derived natural transformation is functorial.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-470"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.66</span></span>. <a id="derivedcompatibility"></a> Suppose that some diagram of left Quillen functors
commutes. Then the corresponding diagram of derived functors can be made to commute.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-471"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We can replace all the model categories with the subcategory of cofibrant objects. The left Quillen functors are still defined since they take cofibrations to cofibrations and the
initial object to the initial object. Now there is no deriving necessary. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-472"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.67</span></span>. <a id="rightproperfibrantobjects"></a> Suppose that in a model category \(C\), weak
equivalences to fibrant objects are stable along pullbacks by a fibration. Then \(C\) is right proper.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-473"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Produce a diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-59"
      class="lateximagesource"
><!--
            ∼
        X       RX

    ∼       ∼
Z       Y       RY
--><img
      src="Simplicial_h-images/image-59.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
by choosing a fibrant replacement for \(Y\) and factoring \(X \to Y \to RY\). The map \(Y\times _{RY}RX \to RX\) is an equivalence by hypothesis, so \(X \to Y\times _{RY}RX \) is an equivalence by \(2\) out of \(3\).
Pulling back along \(Z \to Y\) is a right Quillen functor, so it preserves weak equivalences between fibrant objects. Applying this to \(X \to Y\times _{RY}RX \), we get the desired result. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-477"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.68</span></span>. The Quillen model structure on simplicial sets is left and right proper, (or just
proper). Left proper is clear. If \(X \to Y\) is an equivalence, and we pull it back via a fibration, it is an equivalence by using the \(5\)-lemma and comparing the long exact sequence on homotopy groups.
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-478"><span class="sectionnumber">4.4&#x2003;</span>Enriched and Simplicial model categories</h5>
<a id="Simplicial_h-autopage-478"></a>


<p>
Our goal in this section is to study model categories that are enriched over others.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-479"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.69</span></span>. A <b>monoidal model category</b> is a closed monoidal category \(S\) with a model
structure satisfying:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. The tensor product \(\otimes :       S\times S \to S\) is a left Quillen bifunctor.
</p>


</li>
<li>


<p>
2. The unit \(1 \in S\) is cofibrant.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-480"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.70</span></span>. By Lemma <a
href="node-Technical-Things.html#mapsfibration">2.30</a> and Lemma <a href="node-Technical-Things.html#mapstrivfibration">2.31</a>, the Quillen model structure on \(\SSet \) is a monoidal model category
with respect to the cartesian product.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-481"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.71</span></span>. <a id="setenriched"></a> Consider the monoidal category \(\FinSet \)
with the Cartesian product, isomorphisms and maps from the empty set as cofibration, and isomorphisms weak equivalences. Every cocomplete model category is enriched over this in a canonical way, since iterated coproducts of an
object with itself give the tensoring/cotensoring.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-482"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.72</span></span>. Let \(S\) be a monoidal model category. An \(S\)-enriched model category is an
\(S\)-enriched model category \(A\) equipped with a model structure so that:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(A\) is tensored and cotensored over \(S\).
</p>


</li>
<li>


<p>
2. \(A \otimes S \to S\) is a left Quillen bifunctor.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
When \(S\) is \(\SSet \) with the Quillen model structure, this is the definition of a <b>simplicial model category</b>.
</p>

<p>
It follows from Example <a href="node-Model-Categories.html#setenriched">4.71</a> that anything proven about model categories over a monoidal model category is a strict generalization about things that are true for
model categories.
</p>

<p>
In some cases we can detect simplicial model structures with less effort than expected.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-483"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.73</span></span>. Let \(C\) be a model category enriched over \(\SSet \) with every object cofibrant.
Suppose that weak equivalences are closed under filtered colimits. Then the following are equivalent to the simplicial model category conditions:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(A\) is tensored and cotensored over \(\SSet \).
</p>


</li>
<li>


<p>
2. For any cofibration in \(K \to L\) in \(\SSet \) and a cofibration \(c \to d\) in \(C\), the map \(c\otimes L \cup _{c\otimes K} d\otimes K \to d \otimes L\) is a cofibration.
</p>


</li>
<li>


<p>
3. For every \(n \geq 0\) and every object \(c \in C\), the natural map \(c\otimes \Delta ^n\to c\otimes \Delta ^0\) is an equivalence.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-484"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span>
</p>

<p>
Suppose that \(C\) is a simplicial model category. Clearly \((1)\) and \((2)\) are satisfied, as well as \(3\), since the map \(\Delta ^n \to \Delta ^0\) admits a section which is a trivial fibration.
</p>

<p>
Now suppose the conditions are satisfied. Since every object is cofibrant, \(C\) is left proper, and moreover the functor \(\otimes X:C \to C\) is homotopical.
</p>

<p>
We will first see that the tensoring bifunctor \(C\times \SSet \to C\) preserves weak equivalences in each variable. Fix \(c \in C\) and suppose that \(K \to K&apos;\) is a weak equivalence in \(\SSet \). Factor it as a trivial
fibration and trivial cofibration. The trivial fibration has a section, which is a trivial cofibration, (since it is injective) so we can reduce to the case of \(K \to K&apos;\) being a trivial cofibration. The collection of all such \(K \to
K&apos;\) such that \(c\otimes K \to c\otimes K&apos;\) is a trivial cofibration is weakly saturated, so we reduce to showing it for the horn inclusions \(\Lambda ^n_i \to \Delta ^n\). The inclusion of a vertex \(\{v\} \to
\Lambda ^n_i\) is a pushout of horn inclusions of dimension \(&lt;n\), so by induction and the \(2\) out of \(3\) property it suffices to show it for \(\{v\} \to \Delta ^n\) which was assumed.
</p>

<p>
Next fix \(K\), and we will see that \(c \to c\otimes K\) preserves weak equivalences. Let \(f:c \to c&apos;\) be a weak equivalence. Since weak equivalences are closed under filtered colimits, it suffices to show this for \(K\)
finite. We will then prove it by induction on the subcomplex of \(K\). Choose a subcomplex \(L\) of \(K\) for which the result is satisfied, and a nondegenerate cell \(\sigma \) we would like to adjoin. \(f\otimes \partial
\sigma , f\otimes L\) are equivalences by the inductive hypothesis, and \(f\otimes \sigma \) is an equivalence by assumption.
</p>

<p>
Because our model structure is left proper, using assumption \((2)\) we get that \(D\otimes (-)\) applied to the diagram adjoining \(\sigma \) to \(L\) is a homotopy pushout for any \(D\). Thus since each of the components is
a weak equivalence, the pushout is a weak equivalence.
</p>

<p>
Suppose now that \(i:c \to c&apos;\) and \(j:S \to S&apos;\) are cofibrations in \(C\) and \(\SSet \) respectively. We would like to prove that the induced map \(i \wedge j:                     (c\otimes S&apos;) \cup _{(c\otimes
S}(c&apos;\otimes S&apos;)\) is an equivalence if either \(i,j\) are equivalences. But this follows from applying \(2\) out of \(3\) and left properness to the diagram
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-60"
      class="lateximagesource"
><!--
c⊗S               c′ ⊗ S


c ⊗ S′   (c ⊗ S ′ ) ∪c⊗S (c′ ⊗ S ′ )   c′ ⊗ S ′
--><img
      src="Simplicial_h-images/image-60.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
With a simplicial model category, we have nice cylinders. For example, \(\Delta ^1\) is a cylinder object for \(\Delta ^0\) in \(\SSet \), and tensoring with \(A\) gives a cylinder object for \(A\) when \(A\) is cofibrant. Thus if
\(A\) is cofibrant and \(B\) fibrant, then homotopy of maps \(A \to B\) agrees with equivalence in \(\ul \Hom (A,B)\).
</p>

<p>
Suppose that we have a Quillen adjunction \(F \dashv G\) between two \(S\)-enriched model categories \(C,D\), and \(G\) is an \(S\)-enriched functor. Then for every \(X \in C, Y \in D, s \in S\), there is a canonical map
\(\Hom (s\otimes X,GY) \to \Hom (s\otimes FX,Y)\), which applied to the unit of the adjunction gives a family of maps \(\beta _{X,s}:s\otimes FX \to F(s\otimes X)\). In Lemma <a
href="node-Technical-Things.html#enrichadjunction">2.28</a>, it was determined that \(\beta _{X,s}\) is an isomorphism iff the adjunction is enriched.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-488"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnumberdefinition"> <span class="textup">4.74</span></span>. Suppose that \(S\) is \(\SSet \) with the Quillen model structure. Then
\(\beta _{X,s}\) is an equivalence. To see this, we know it for \(s = \Delta ^0\), and observe that the set of simplicial sets for which it is true is closed under weak equivalences, coproducts, and homotopy pushouts.
</p>

</li>

</ul>

</div>

<p>
We will now consider the situation when \(\beta _{X,s}\) is a weak equivalence.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-489"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.75</span></span>. Let \(C,D\) be \(S\)-enriched model structures, and \(F\dashv G\) a Quillen
adjunction between the underlying model categories with \(G\) enriched. Assume that every object of \(C\) is cofibrant and that the map \(\beta _{X,s}\) is a weak equivalence fore every \(s,X\) cofibrant. Then TFAE:
</p>

<ul style="list-style-type:none">


<li>
<p>
1. \(F\dashv G\) is a Quillen equivalence.
</p>


</li>
<li>


<p>
2. The restriction of \(G\) determines a weak equivalence of \(S\) [REQUIRES SOMETHING AHEAD:((((]
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-490"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.76</span></span>. \((W2)\) for the factorization systems is implied by the rest of the axioms for a simplicial
model category. Moreover, if the object in the upper left corner is cofibrant, the lift is unique up to relative homotopy.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-491"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> A lift in a diagram of the form
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-61"
      class="lateximagesource"
><!--
A   X


B   Y
--><img
      src="Simplicial_h-images/image-61.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
is the same as a lift of a \(0\)-simplex in the map \(\Hom (B,X) \to \Hom (A,X) \times _{\Hom (B,Y)}\Hom (X,Y)\). But this is a trivial fibration if either of the vertical maps is trivial by the fact that the two-variable
adjunction with \(\otimes \) is Quillen, so there is a unique lift up homotopy. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We can reduce the amount of work needed to check something is a simiplicial model category by observing that we can check the condition of \(\otimes ,\{,\}\) or \(\hom \) being a Quillen bifunctor on generating cofibrations
or generating fibrations.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-495"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.77</span></span>. If \(A,B\) are cofibrant, \(f:A \to B\) is an equivalence in a simplicial model category iff
\(\ul \Hom (B,C) \to \ul \Hom (A,C)\) is a weak equivalence for every fibrant object \(C\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-496"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It is clear that if \(f\) is an equivalence, then the other map is an equivalence. Conversely, if the other map is an equivalence, since \(\ul \Hom (B,C) \to \ul \Hom (A,C)\) is a
fibration, it is a trivial fibration, and in particular bijective on \(\pi _0\). Thus \(f\) is an isomorphism in the homotopy category. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Many categories of simplicial objects (eg: models of Lawvere theories) have natural simplicial model structures. These often come from inducing model structures through an adjunction
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-497"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.78</span></span>. <a id="liftingimpliessimpmodelcat"></a> Let \(\adjunction {F}{C}{D}{U}\) be
an enriched adjunction of categories tensored and cotensored over \(\SSet \), suppose that \(D\) is bicomplete, and \(C\) has a simplicial model structure cofibrantly generated by \(\kappa \)-small objects that are sent to
\(\kappa &apos;\)-small objects in \(D\). We can try to define a model structure by having a map in \(D\) be a fibration or weak equivalence if it is after applying \(U\). Suppose that if \(f \in D\) has the left lifting property
with respect to \(g\) such that \(Uf\) is a fibration, then \(Uf\) is a weak equivalence.
</p>

<p>
Then \(D\) has a cofibrantly generated simplicial model structure where the fibrations and weak equivalences are determined by applying \(U\), the cofibrations are generated by \(U\) applied to generators for \(D\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-498"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By Proposition <a href="node-Model-Categories.html#adjunctioninducedmodelstr">4.15</a> a model structure, and we only need to show that it is simplicial.
</p>

<p>
To do this, we can identify the map
</p>

<p>
\[U\hom _{D}(L,X) \to U(\hom _{\simp C}(K,X)\times _{\hom _{D(K,Y)}} \hom _{D} (L,Y) )\]
</p>

<p>
with
</p>

<p>
\[\hom _{C}(L,UX) \to \hom _{C}(K,UX)\times _{\hom _{C(K,UY)}} \hom _{C} (L,UY)\]
</p>

<p>
since the adjunction is enriched and \(U\) preserves pullbacks. If \(K \to L\) is a cofibration and \(X \to Y\) is a fibration, one of which is trivial then this map is a fibration, since \(C\) is a simplicial model category. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-499"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.79</span></span>. <a id="liftingsimplicialdeformationcondition"></a> If \(D\) has a functorial
fibrant replacement \(Q\), then the last condition of Proposition <a href="node-Model-Categories.html#liftingimpliessimpmodelcat">4.78</a> is satisfied.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-500"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We have a functorial path object given by \(\hom (\Delta ^1,-)\), and \(Q\) is a functorial fibrant replacement, so by Proposition <a
href="node-Model-Categories.html#adjunctioninducedhypothesis">4.30</a> we are done. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The following corollary is probably bad because the last assumption is unnecessary. Or maybe not because the other version requires the objects to be “small".
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-501"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.80</span></span>. <a id="liftingsimplicialobjectmodelstr"></a> Let \(\adjunction {F}{\Set
}{C}{U}\) be an adjunction of categories, suppose that \(C\) is bicomplete, \(F\) sends \(1\) to a \(\kappa \)-small object in \(C\). We can try to define a model structure on \(\simp C\) by having a map in \(\simp C\) be a
fibration or weak equivalence if it is after applying \(U\). Suppose that if \(f \in \simp C\) has the left lifting property with respect to \(g\) such that \(Uf\) is a fibration, then \(Uf\) is a weak equivalence.
</p>

<p>
Then \(\simp C\) has a cofibrantly generated simplicial model structure where the fibrations and weak equivalences are determined by applying \(U\), the cofibrations are generated by \(U\) applied to generators for \(D\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-502"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(\simp {C}\) is tensored and cotensored by Lemma <a href="node-Technical-Things.html#simplicialobjectssimplicialcat">2.29</a>. The adjunction \(\adjunction
{F}{\simp C}{\SSet }{U}\) enriches over \(\SSet \) by Lemma <a href="node-Technical-Things.html#enrichadjunction">2.28</a> since \(F(X \times K) \cong F(X)\otimes K\). \(F\) sends the generators of
cofibrations/trivial cofibrations to \(\kappa \)-small objects after possibly enlarging \(\kappa \) since \(\Delta ^{op}\) is a small category, so by Proposition <a
href="node-Model-Categories.html#liftingimpliessimpmodelcat">4.78</a> we are done. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-503"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.81</span></span>. <a id="algsimpmodelcat"></a> Any category for which the forgetful
functor factors through groups satisfies Lemma <a href="node-Model-Categories.html#liftingsimplicialdeformationcondition">4.79</a> with \(Q\) the identity by Proposition <a
href="node-Kan-Fibrations.html#simplicialgroupsfibrant">3.1</a>. This includes simplicial groups, rings, Lie algebras, modules.
</p>

</li>

</ul>

</div>

<p>
I think you can replace small in the theorem below by \(\kappa \)-small if you use a large ordinal power of \(\Ex \) rather than \(\Ex ^\infty \).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-504"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">4.82</span></span>. <a id="representablesimpmodelstr"></a> Let \(C\) be complete and cocomplete, and
let \(Z_i\) be a set of small objects of \(C\), and regard them as constant simplicial objects. Then there is a cofibrantly generated simplicial model structure on \(\simp C\) such that a map \(A \to B\) is a weak equivalence or
fibration iff the maps \(\ul \Hom _{\simp C}(Z_i,A) \to \ul \Hom _{\simp C}(Z_i,B)\) is one.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-505"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Use \(\Ex \) to produce a natural fibrant replacement...[INCOMPLETE] <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-506"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.83</span></span>. Simplicial objects of models of any Lawvere theory will have the forgetful
functor corepresented by a small object, making Theorem <a href="node-Model-Categories.html#representablesimpmodelstr">4.82</a> apply.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-507"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">4.84</span></span>. Let \(\FF \) be a field. A coalgebra over \(\FF \) is locally finite
dimensional, so the finite dimensional coalgebras are a set of small generators. Thus we can apply Theorem <a href="node-Model-Categories.html#representablesimpmodelstr">4.82</a> on the set of finite dimensional
coalgebras.
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
