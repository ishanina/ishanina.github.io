
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Simplicial</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Simplicial_h-autopage-1070"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s website">Back to Ishan Levy’s website</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Simplicial</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Introduction.html#autosec-6" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Technical Things</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-36" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Generators of anodyne morphisms</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-54" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Enriched Categories</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-68" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Basics of Simplicial Sets</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-99" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Left fibration characterization of Kan fibrations</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-127" class="tocsubsection" >
<span class="sectionnumber">2.5</span>&#x2003;Cartesian Morphisms</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-156" class="tocsubsection" >
<span class="sectionnumber">2.6</span>&#x2003;Minimal Inner Fibrations</a>
</p>


<p>
<a href="node-Technical-Things.html#autosec-173" class="tocsubsection" >
<span class="sectionnumber">2.7</span>&#x2003;Trees</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-207" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Kan Fibrations</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-230" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Minimal fibrations</a>
</p>


<p>
<a href="node-Kan-Fibrations.html#autosec-243" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Equivalence of Quillen and Serre model structures</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-262" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Model Categories</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-313" class="tocsubsection" >
<span class="sectionnumber">4.1</span>&#x2003;Homotopy category of a model category</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-411" class="tocsubsection" >
<span class="sectionnumber">4.2</span>&#x2003;Combinatorial Model Categories</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-443" class="tocsubsection" >
<span class="sectionnumber">4.3</span>&#x2003;Derived Functors</a>
</p>


<p>
<a href="node-Model-Categories.html#autosec-478" class="tocsubsection" >
<span class="sectionnumber">4.4</span>&#x2003;Enriched and Simplicial model categories</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-510" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Some Important Model Structures</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-511" class="tocsubsection" >
<span class="sectionnumber">5.1</span>&#x2003;Model structure on \(S\)-enriched categories</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-552" class="tocsubsection" >
<span class="sectionnumber">5.2</span>&#x2003;Diagram model structures and homotopy limits</a>
</p>


<p>
<a href="node-Some-Important-Model-Structures.html#autosec-595" class="tocsubsection" >
<span class="sectionnumber">5.3</span>&#x2003;Reedy model structures</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-613" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;\(\Pi _1\) and Simplicial abelian groups</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-614" class="tocsubsection" >
<span class="sectionnumber">6.1</span>&#x2003;Fundamental Groupoid</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-627" class="tocsubsection" >
<span class="sectionnumber">6.2</span>&#x2003;Local Systems and Covering Spaces</a>
</p>


<p>
<a href="node-Pi-_1-Simplicial-abelian-groups.html#autosec-628" class="tocsubsection" >
<span class="sectionnumber">6.3</span>&#x2003;Simpicial objects in Abelian Categories</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-664" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Bisimplicial Sets</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-681" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Bisimplicial objects in an abelian category</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-701" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Model structures</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-727" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Bousfield-Friedlander</a>
</p>


<p>
<a href="node-Bisimplicial-Sets.html#autosec-763" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Theorem B and Group Completion</a>
</p>


<p>
<a href="node-Some-Classical-Homotopy-Theory.html#autosec-787" class="tocsection" >
<span class="sectionnumber">8</span>&#x2003;Some Classical Homotopy Theory</a>
</p>


<p>
<a href="node-Some-Classical-Homotopy-Theory.html#autosec-788" class="tocsubsection" >
<span class="sectionnumber">8.1</span>&#x2003;The Hurewicz Map</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-841" class="tocsection" >
<span class="sectionnumber">9</span>&#x2003;Models for Homotopy Types</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-842" class="tocsubsection" >
<span class="sectionnumber">9.1</span>&#x2003;Test Categories</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-875" class="tocsubsection" >
<span class="sectionnumber">9.2</span>&#x2003;Basics of Cubical Sets</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-898" class="tocsubsection" >
<span class="sectionnumber">9.3</span>&#x2003;Cisinski model structures</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-971" class="tocsubsection" >
<span class="sectionnumber">9.4</span>&#x2003;Colimits in Cisinski model structures</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-1010" class="tocsubsection" >
<span class="sectionnumber">9.5</span>&#x2003;Weak equivalence classes of functors</a>
</p>


<p>
<a href="node-Models-Homotopy-Types.html#autosec-1043" class="tocsubsection" >
<span class="sectionnumber">9.6</span>&#x2003;Model structure on Cubical Sets</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1072" class="tocsection" >
<span class="sectionnumber">10</span>&#x2003;Simplicial localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1073" class="tocsubsection" >
<span class="sectionnumber">10.1</span>&#x2003;Free Categories and Localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1087" class="tocsubsection" >
<span class="sectionnumber">10.2</span>&#x2003;Dwyer-Kan Localization</a>
</p>


<p>
<a href="node-Simplicial-localization.html#autosec-1099" class="tocsubsection" >
<span class="sectionnumber">10.3</span>&#x2003;Reduction to Cubical Sets</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Simplicial</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\Mloc }{\mathcal {M}_{\text {loc}}}\)

\(\newcommand {\Mnilpnil }{\mathcal {M}_{\text {nil}}^{\text {pnil}}}\)

\(\newcommand {\Uloc }{\mathcal {U}_{\text {loc}}}\)

\(\newcommand {\Mnil }{\mathcal {M}_{\text {nil}}}\)

\(\newcommand {\Unil }{\mathcal {U}_{\text {nil}}}\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)
</div>

<p>
<!--................................-->
<h4 id="autosec-1072"><span class="sectionnumber">10&#x2003;</span>Simplicial localization</h4>
<a id="Simplicial_h-autopage-1072"></a>
<a id="Simplicial_h-autofile-10"></a> The goal of this section is to show that the invertibility hypothesis is redundant in the definition of an excellent model category. This actually involves proving it in the case of simplicial
categories.
<!--................................-->
<h5 id="autosec-1073"><span class="sectionnumber">10.1&#x2003;</span>Free Categories and Localization</h5>
<a id="Simplicial_h-autopage-1073"></a>


<p>
Let \(O\Cat \) be the category of categories with a fixed set of objects \(O\) and morphisms maps that fix the set objects. A simplicial category with objects \(O\) is a simplicial object in \(O\Cat \), and we denote this category
\(sO\Cat \). There is a simplicial nerve functor \(N\) taking a simplicial category to the diagonal of the bisimplicial set obtained by taking the nerve levelwise. By homotopy invariance of the diagonal, it follows that an equivalence
of simplcial categories induces an equivalence on nerves.
</p>

<p>
A category \(C\) in \(O\Cat \) is <b>free</b> if there exists a set of morphisms \(S\) such that every nonidentity map in \(C\) is a unique composite of maps in \(C\). There is a forgetful map from \(U:\Cat \to \DiGrph \), the
category of directed graphs, and the free categories are the essential image of the left adjoint. When we fix the set of objects, every free category is a coproduct of free categories on a single map. The free forgetful adjunction induces
the free monad \(F\) on \(O\Cat \), taking a category to the free category on its nonidentity morphisms. This monad gives a simplicial resolution \(F_*C\) of an object in \(O\Cat \), which is equipped with a map \(F_*C \to
C\). Similarly, given a simplicial category, one can take levelwise free resolutions and take the diagonal simplicial category.
</p>

<p>
Finally, observe that \(sO\Cat \) and \(O\Cat \) inherit a model structure from \(\Cat _{\Delta }, \Cat \), since they are subcategories of the slice category under the discrete category with objects \(O\) that are closed under
all the operations needed to inherit the model structure.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1074"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.1</span></span>. <a id="freeresolutionsimpcat"></a> The map \(F_*C \to C\) is an equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1075"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By homotopy invariance of the diagonal, it suffices to consider \(C\) an ordinary category. For any objects \(X, Y\), the map taking \(x \in F_{n}C\) to \([x] \in F_{n+1}C\)
is a contracting homotopy of \(F_*C\) onto \(C\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1076"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.2</span></span>. <a id="homotopycoproductcat"></a> If \(\star \) denotes the free product in \(sO\Cat
\), then \(\star \) is homotopical, and computes the homotopy coproduct.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1077"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It suffices to show that \(A \star B \to A&apos; \star B\) is an equivalence if \(A \to A&apos;\) is. The argument in Lemma <a
href="node-Simplicial-localization.html#freeresolutionsimpcat">10.1</a> shows that \(A\star F_*B \to A \star B\) is an equivalence, so we can assume \(B\) is free in each degree. In the degreewise free case, by
observing that \(A\star F_*B\) is the diagonal of the bisimplicial category given by \(A\star F_nB\), we can reduce to the case \(B\) is discrete and free. In this case, the map \(O\to B\) is a cofibration, so since \(\star \) is
the pushout relative to \(O\), it is a homotopy pushout by left properness. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1078"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.3</span></span>. <a id="freecatskeleton"></a> If \(C\) is a free category, the inclusion \(\sk _kNC\to
NC\) is an equivalence for \(k \geq 1\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1079"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> It’s easy to see that the \(k+1\)-skeleton deformation retracts onto the \(k\)-skeleton, because \(C\) is free. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Let \(C \in O\Cat \) and \(W\) a subcategory of \(C\). \(C[W^{-1}]\) is the localization in the classical sense: its objects are the same, and morphisms are zig-zags
</p>

<p>
\[X \to X_1\leftarrow X_2 \rightarrow X_3 \dots Y\]
</p>

<p>
where the left arrows are in \(W\), modulo the obvious equivalence relation. The map \(C \to C[W^{-1}]\) universally sends \(W\) to isomorphisms. Note that this is also the pushout of categories:
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-141"
    class="lateximagesource"
><!--
   W               C

            ⌜
W [W −1 ]       C[W −1 ]
--><img
    src="Simplicial_h-images/image-141.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
Where \(W[W^{-1}] = GW\) is the groupoid generated by \(W\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1083"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.4</span></span>. <a id="pushoutnervecat"></a> Let \(C = D\star E\). Then the inclusion \(ND \cup
_O NE \to ND\star E\) is an equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1084"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> For a free categories \(D,E\), this follows from Lemma <a href="node-Simplicial-localization.html#freecatskeleton">10.3</a>. In general, we take a free resolution and
use Lemma <a href="node-Simplicial-localization.html#freeresolutionsimpcat">10.1</a>, Lemma <a href="node-Simplicial-localization.html#homotopycoproductcat">10.2</a>, and the fact that the diagonal of
a bisimplicial set is homotopical. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1085"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.5</span></span>. <a id="invertnervelemma"></a> If \(C = D\star W \in O\Cat \), where \(W\) is free,
then the map \(N(D\star W) = NC \to NC[W^{-1}]\) is an equivalence.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1086"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> By transfinite composition and Lemma <a href="node-Simplicial-localization.html#pushoutnervecat">10.4</a>, it suffices to show it for \(C=W\) free on one generator.
This is easy to see beacause both nerves are contractible. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-1087"><span class="sectionnumber">10.2&#x2003;</span>Dwyer-Kan Localization</h5>
<a id="Simplicial_h-autopage-1087"></a>


<p>
Let \(C \in O\Cat \) with a subcategory \(W\). The <b>standard simplicial localization</b> is defined by \(L(C,W) = F_*C[F_*W^{-1}]\). The notation will often be shortened to \(LC\). The goal will be to show that this is
a well behaved left derived functor of the localization.
</p>

<p>
The first thing to observe is that \(hLC = C[W^{-1}]\), since the homotopy category is a left adjoint, so preserves colimits.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1088"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.6</span></span>. <a id="nervelocalization"></a> The simplicial localization preserves the homotopy type
of the nerve.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1089"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Using Lemma <a href="node-Simplicial-localization.html#invertnervelemma">10.5</a> and Lemma <a
href="node-Simplicial-localization.html#freeresolutionsimpcat">10.1</a> we see that \(NC \leftarrow NF_*C\rightarrow NLC\) gives a zig-zag of equivalences between the two. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The following lemma is quite easy from definition:
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1090"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.7</span></span>. A map \(u:X \to Y \in C\) is in \(W\) iff it induces an isomorphism on covariant and
contravariant mapping spaces.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1091"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">10.8</span></span>. <a id="mappingspacegroupcompletion"></a> Suppose \(W = C\), and \(NC\) is
connected. Then \(LC\) is a simplicial groupoid, all the mapping spaces are equivalent, and the endomorphism spaces \(LC(X,X)\) are simplicial groups. Moreover, the homotopy type of \(LC(X,X)\) is that of the loop space of
\(NC\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1092"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The fact that the endomorphisms are simplicial groups is trivial. To prove the last statement, first replace \(NC\) with \(NLC\) by Lemma <a
href="node-Simplicial-localization.html#nervelocalization">10.6</a>. Now for every \(k\), \(F_kC[F_kC^{-1}]\) is a connected groupoid, so let \(UF_kC[F_kC^{-1}]\) be its universal cover, which is contractible, and
has fibre \(LC(X,X)_k\). Then applying Theorem <a href="node-Bisimplicial-Sets.html#bousfieldfriedlander">7.23</a>, we obtain the result. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Now we generalize to simplicial localizations of a simplicial category. Given a simplicial category \(B \in sO\Cat \) and \(V\subset B\) a subcategory, the standard simplicial localization is the diagonal of \(F_*B[F_*V^{-1}]\),
which we denote \(L(B,V)\) or \(LB\) when it isn’t confusing.
</p>

<p>
Again, upon taking homotopy categories, it agrees with the localization of the homotopy category. The groupoid completion of a simplicial category \(V\) is \(L(V,V)\).
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1093"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.9</span></span>. <a id="nervesimplocalization"></a> The map \(V \to L(V,V)\) induces an
equivalence on nerves.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1094"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> This follows because the diagonal is homotopy invariant and Lemma <a href="node-Simplicial-localization.html#nervelocalization">10.6</a>. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1095"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">10.10</span></span>. <a id="groupcompletionhomotopytype"></a> A map \(U \to V\) induces a weak
equivalence on groupoid completions iff it induces a weak homotopy equivalence on nerves.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1096"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> WLOG we can assume \(U,V\) are connected, in which case this follows from Lemma <a href="node-Simplicial-localization.html#nervesimplocalization">10.9</a> and
the fact that by the argument in Proposition <a href="node-Simplicial-localization.html#mappingspacegroupcompletion">10.8</a> shows that \(LU(X,Y)\) has the homotopy type of the loopspace of \(NU\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
It follows that the \(L(U,U)\) is the left derived functor of the naive level-wise localization localization functor, computed by the deformation given by diagonalizing the standard free resolution.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1097"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">10.11</span></span>. Let \(V \in sO\Cat \). Then the natural map \(V \to L(V,V)\) is an equivalence
iff \(hV\) is a groupoid.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1098"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The only if part is trivial since \(hL(V,V)\) is a groupoid. For the if, <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--................................-->
<h5 id="autosec-1099"><span class="sectionnumber">10.3&#x2003;</span>Reduction to Cubical Sets</h5>
<a id="Simplicial_h-autopage-1099"></a>


<p>
The strategy will be to reduce the invertibility hypothesis to the case of cubical sets via its universal property below, and then use the work of Dwyer and Kan on simplicial localization. We use the standard model structure on
\(S\)-enriched categories.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1100"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">10.12</span></span>. <a id="leftquillencubicalsets"></a> Suppose \(C\) is a monoidal model
category, \(F:\square ^{\leq 1} \to C\) is a functor, and \(\tilde {F}\) is its cocontinuous monoidal extension to \(\Set _{\square }\). Then \(\tilde {F}\) is a left Quillen functor iff \(F\) expresses \(F(\square
^1)\) as a cylinder object for the unit of \(F\), meaning the inclusions \(F(\square ^0)\) are trivial cofibrations. In particular, such a monoidal left Quillen functor exists.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1101"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> \(F\) applied to the inclusions \(j_0,j_1:\square ^0 \to \square ^1\) must be a trivial cofibration. The map \(j_0 \cup j_1= i:\square ^0\cup \square ^0 \to \square
^1\) must also be sent to a cofibration. Note that \(\tilde {F}\) applied to the inclusion \(\phi \to \square ^0\) is a cofibration, which amounts to the unit being cofibrant, which is part of the monoidal model category axioms.
</p>

<p>
Conversely, if \(F\) satisfies those conditions, the generating (trivial) cofibrations are sent to (trivial) cofibrations because \(\otimes \) is a left Quillen bifunctor, and the generating (trivial) cofibrations are built from \(i,j_\ee
\) using the pushout-product construction. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Let \(\Cat _{\square }\) denote the category of categories enriched in cubical sets. Define \(P,H,E\) via the pushout squares below.
</p>
<div class="center">

<p>
<span
    id="lateximage-Simplicial_h-142"
    class="lateximagesource"
><!--
[1]ϕ            [1]□0
   v

        u   ⌜
[1]□0            P
--><img
    src="Simplicial_h-images/image-142.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span> <span
    id="lateximage-Simplicial_h-143"
    class="lateximagesource"
><!--
[1]∂□1       P

         ⌜
[1]□1        H
--><img
    src="Simplicial_h-images/image-143.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span> <span
    id="lateximage-Simplicial_h-144"
    class="lateximagesource"
><!--
[1]□0       H

        ⌜
 H          E
--><img
    src="Simplicial_h-images/image-144.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
\(P\) is defined so maps out of it are exactly a pair of morphisms in opposite direction, and \(H\) is in addition a homotopy from \(v\circ u\) to the identity, and \(E\) is a choice of left and right homotopy inverse.
</p>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1109"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">10.13</span></span>. Suppose \(C \in \Cat _{\square }\) is fibrant and \(f:[1]_{\square } \to C\) is a
map which becomes an isomorphism in the homotopy category. Then \(f\) extends to a map from \(E\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1110"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> The mapping spaces of \(C\) are all fibrant since \(C\) is fibrant. It follows that we can make the homotopies desired in the mapping spaces, extending the map to \(E\) by its
universal property. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1111"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">10.14</span></span>. <a id="Einvertibility"></a> Let \(E[f^{-1}]\) denote the localization of \(E\)
at the map \(f\) (the one with the choice of homotopy inverses). Then the map \(E \to E[f^{-1}] \to [1]^{\sim }_{\square }\) are equivalences.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1112"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> There is a monoidal left Quillen equivalence (Theorem <a href="node-Models-Homotopy-Types.html#geometricrealizationofcubicalset">9.80</a>) between \(\Set
_{\square }\) and \(\SSet \) preserving the localization, giving a left Quillen equivalence between categories of enriched categories. Thus it suffices to show the corresponding statement for simplicial categories.
</p>

<p>
But then \(f\) is a morphism that is already invertible, so by [DWYERKAN], it follows that \(E \to E[f^{-1}]\) is an equivalence. We still need to show that \(E[f^{-1}] \to [1]^{\sim }_{\square }\) is an equivalence. To
do this, since the two objects in \(E[f^{-1}]\) are equivalent, it suffices to show that either of them has contractible endomorphisms. However, this mapping space from the construction of pushouts is the free monoid on the based
space \(\Delta ^1\vee \Delta ^1\), which is contractible since \(\Delta ^1\vee \Delta ^1\) is. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1113"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">10.15</span></span>. The map \([1]_{\square ^0} \to E\) is a cofibrant replacement for \([1]_{\square
^0}\to [1]^{\sim }_{\square }\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1114"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">10.16</span></span>. Suppose that \(S\) is a monoidal model category satisfying \((A1)-(A4)\) of Definition
<a href="node-Some-Important-Model-Structures.html#excellentdef">5.10</a>. Then \(S\) satisfies the invertibility hypothesis.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Simplicial_h-autopage-1115"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> Suppose that \(f:[1]_S \to C\) is a cofibration that is an equivalence in the homotopy category. By Remark <a
href="node-Some-Important-Model-Structures.html#invremark1">5.7</a>, we can assume that \(C\) is fibrant. By Proposition <a href="node-Simplicial-localization.html#leftquillencubicalsets">10.12</a>, there
is a left Quillen functor \(L: \Set _\square \to S\), with right adjoint \(R\). This induces a Quillen adjunction \(\adjunction {L}{\Cat _{\square }}{\Cat _S}{R}\)
</p>

<p>
Because \(L\) sends the unit to the unit, \(R\) preserves homotopy categories. Thus the image of \(f\) in the homotopy category after applying \(R\) extends to a map \(E \to RC\), which is adjoint to a map \(L(E) \to C\). We
can assume WLOG that this map is a cofibration by modifying \(C\).
</p>

<p>
Then we can consider the diagram of pushouts:
</p>
<div class="center">

<p>
<span
      id="lateximage-Simplicial_h-145"
      class="lateximagesource"
><!--
[1]S     L(E)              C

       ⌜             ⌜
[1]∼
   S   L(E[f −1 ])       C[f −1 ]
--><img
      src="Simplicial_h-images/image-145.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
The middle vertical map is an equivalence by Proposition <a href="node-Simplicial-localization.html#Einvertibility">10.14</a>. Thus the right vertical map is an equivalence by left properness. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>
<a id="Simplicial_h-autopage-1119"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">10.17</span></span>. <a id="excellentinvhypredundant"></a> A symmetric monoidal model category
satisfying \((A1)-(A4)\) is excellent.
</p>

</li>

</ul>

</div>

<a id="Simplicial_h-autofile-last"></a>
</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
