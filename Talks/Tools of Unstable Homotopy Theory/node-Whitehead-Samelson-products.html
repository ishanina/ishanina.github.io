
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Tools of Unstable Homotopy Theory</title>
<link rel="stylesheet" type="text/css" href="fancycss.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="Tools_of_Unstable_Homotopy_Theory_h-autopage-4"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<a href="http://ishanina.github.io" title="Ishan Levy’s Writings">Back to Ishan Levy’s Writings</a>
</p>

</header>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Tools of Unstable Homotopy Theory</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-Whitehead-Samelson-products.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Whitehead and Samelson products</a>
</p>


<p>
<a href="node-Hilton-Milnor-James-Splitting.html#autosec-9" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Hilton–Milnor and James Splitting</a>
</p>


<p>
<a href="node-The-EHP-Sequence.html#autosec-20" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;The EHP Sequence</a>
</p>


<p>
<a href="node-James-torsion-bound.html#autosec-26" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;James’ torsion bound</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Tools of Unstable Homotopy Theory</h1>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\require {mathtools}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vcentcolon }{\mathrel {\unicode {x2236}}}\)

\(\def \LWRtensorindicesthreesub #1#2{{_{#2}}\LWRtensorindicesthree }\)

\(\def \LWRtensorindicesthreesup #1#2{{^{#2}}\LWRtensorindicesthree }\)

\(\newcommand {\LWRtensorindicesthreenotsup }{}\)

\(\newcommand {\LWRtensorindicesthreenotsub }{ \ifnextchar ^ \LWRtensorindicesthreesup \LWRtensorindicesthreenotsup }\)

\(\newcommand {\LWRtensorindicesthree }{ \ifnextchar _ \LWRtensorindicesthreesub \LWRtensorindicesthreenotsub }\)

\(\newcommand {\LWRtensorindicestwo }{ \ifstar \LWRtensorindicesthree \LWRtensorindicesthree }\)

\(\newcommand {\indices }[1]{\LWRtensorindicestwo #1}\)

\(\newcommand {\LWRtensortwo }[3][]{{}\indices {#1}{#2}\indices {#3}}\)

\(\newcommand {\tensor }{\ifstar \LWRtensortwo \LWRtensortwo }\)

\(\newcommand {\LWRnuclidetwo }[2][]{{\vphantom {\mathrm {#2}}{}^{\LWRtensornucleonnumber }_{#1}\mathrm {#2}}}\)

\(\newcommand {\nuclide }[1][]{\def \LWRtensornucleonnumber {#1}\LWRnuclidetwo }\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\newcommand {\cO }{\mathcal {O}}\)

\(\newcommand {\cC }{\mathcal {C}}\)

\(\newcommand {\cP }{\mathcal {P}}\)

\(\newcommand {\cF }{\mathcal {F}}\)

\(\newcommand {\cS }{\mathcal {S}}\)

\(\newcommand {\cK }{\mathcal {K}}\)

\(\newcommand {\cM }{\mathcal {M}}\)

\(\newcommand {\GG }{\mathbb {G}}\)

\(\newcommand {\ZZ }{\mathbb {Z}}\)

\(\newcommand {\NN }{\mathbb {N}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\QQ }{\mathbb {Q}}\)

\(\newcommand {\RR }{\mathbb {R}}\)

\(\newcommand {\LL }{\mathbb {L}}\)

\(\newcommand {\HH }{\mathbb {H}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\SP }{\mathbb {S}}\)

\(\newcommand {\CC }{\mathbb {C}}\)

\(\newcommand {\FF }{\mathbb {F}}\)

\(\renewcommand {\AA }{\mathbb {A}}\)

\(\newcommand {\sF }{\mathscr {F}}\)

\(\newcommand {\sC }{\mathscr {C}}\)

\(\newcommand {\ts }{\textsuperscript }\)

\(\newcommand {\mf }{\mathfrak }\)

\(\newcommand {\cc }{\mf {c}}\)

\(\newcommand {\mg }{\mf {g}}\)

\(\newcommand {\ma }{\mf {a}}\)

\(\newcommand {\mh }{\mf {h}}\)

\(\newcommand {\mn }{\mf {n}}\)

\(\newcommand {\mc }{\mf {c}}\)

\(\newcommand {\ul }{\underline }\)

\(\newcommand {\mz }{\mf {z}}\)

\(\newcommand {\me }{\mf {e}}\)

\(\newcommand {\mff }{\mf {f}}\)

\(\newcommand {\mm }{\mf {m}}\)

\(\newcommand {\mt }{\mf {t}}\)

\(\newcommand {\pp }{\mf {p}}\)

\(\newcommand {\qq }{\mf {q}}\)

\(\newcommand {\gl }{\mf {gl}}\)

\(\newcommand {\msl }{\mf {sl}}\)

\(\newcommand {\so }{\mf {so}}\)

\(\newcommand {\mfu }{\mf {u}}\)

\(\newcommand {\su }{\mf {su}}\)

\(\newcommand {\msp }{\mf {sp}}\)

\(\renewcommand {\aa }{\mf {a}}\)

\(\newcommand {\bb }{\mf {b}}\)

\(\newcommand {\sR }{\mathscr {R}}\)

\(\newcommand {\lb }{\langle }\)

\(\newcommand {\rb }{\rangle }\)

\(\newcommand {\ff }{\mf {f}}\)

\(\newcommand {\ee }{\epsilon }\)

\(\newcommand {\heart }{\heartsuit }\)

\(\newcommand {\floor }[1]{\lfloor #1 \rfloor }\)

\(\newcommand {\ceil }[1]{\lceil #1 \rceil }\)

\(\newcommand {\pushout }{\arrow [ul, phantom, &quot;\ulcorner &quot;, very near start]}\)

\(\newcommand {\pullback }{\arrow [dr, phantom, &quot;\lrcorner &quot;, very near start]}\)

\(\newcommand {\simp }[1]{#1^{\Delta ^{op}}}\)

\(\newcommand {\arrowtcupp }[2]{\arrow [bend left=50, &quot;&quot;{name=U, below,inner sep=1}]{#1}\arrow [Rightarrow,from=U,to=MU,&quot;#2&quot;]}\)

\(\newcommand {\arrowtclow }[2]{\arrow [bend right=50, &quot;&quot;{name=L,inner sep=1}]{#1}\arrow [Rightarrow,from=LM,to=L]{}[]{#2}}\)

\(\newcommand {\arrowtcmid }[2]{\arrow [&quot;&quot;{name=MU,inner sep=1},&quot;&quot;{name=LM,below,inner sep=1}]{#1}[pos=.1]{#2}}\)

\(\newcommand {\dummy }{\textcolor {white}{\bullet }}\)

\(\newcommand {\adjunction }[4]{ #1\hspace {2pt}\colon #2 \leftrightharpoons #3 \hspace {2pt}\colon #4 }\)

\(\newcommand {\aug }{\mathop {\rm aug}\nolimits }\)

\(\newcommand {\MC }{\mathop {\rm MC}\nolimits }\)

\(\newcommand {\art }{\mathop {\rm art}\nolimits }\)

\(\newcommand {\DiGrph }{\mathop {\rm DiGrph}\nolimits }\)

\(\newcommand {\FMP }{\mathop {\rm FMP}\nolimits }\)

\(\newcommand {\CAlg }{\mathop {\rm CAlg}\nolimits }\)

\(\newcommand {\perf }{\mathop {\rm perf}\nolimits }\)

\(\newcommand {\cof }{\mathop {\rm cof}\nolimits }\)

\(\newcommand {\fib }{\mathop {\rm fib}\nolimits }\)

\(\newcommand {\Thick }{\mathop {\rm Thick}\nolimits }\)

\(\newcommand {\Orb }{\mathop {\rm Orb}\nolimits }\)

\(\newcommand {\ko }{\mathop {\rm ko}\nolimits }\)

\(\newcommand {\Spf }{\mathop {\rm Spf}\nolimits }\)

\(\newcommand {\Spc }{\mathop {\rm Spc}\nolimits }\)

\(\newcommand {\sk }{\mathop {\rm sk}\nolimits }\)

\(\newcommand {\cosk }{\mathop {\rm cosk}\nolimits }\)

\(\newcommand {\holim }{\mathop {\rm holim}\nolimits }\)

\(\newcommand {\hocolim }{\mathop {\rm hocolim}\nolimits }\)

\(\newcommand {\Pre }{\mathop {\rm Pre}\nolimits }\)

\(\newcommand {\THR }{\mathop {\rm THR}\nolimits }\)

\(\newcommand {\THH }{\mathop {\rm THH}\nolimits }\)

\(\newcommand {\Fun }{\mathop {\rm Fun}\nolimits }\)

\(\newcommand {\Loc }{\mathop {\rm Loc}\nolimits }\)

\(\newcommand {\Bord }{\mathop {\rm Bord}\nolimits }\)

\(\newcommand {\Cob }{\mathop {\rm Cob}\nolimits }\)

\(\newcommand {\Set }{\mathop {\rm Set}\nolimits }\)

\(\newcommand {\Ind }{\mathop {\rm Ind}\nolimits }\)

\(\newcommand {\Sind }{\mathop {\rm Sind}\nolimits }\)

\(\newcommand {\Ext }{\mathop {\rm Ext}\nolimits }\)

\(\newcommand {\sd }{\mathop {\rm sd}\nolimits }\)

\(\newcommand {\Ex }{\mathop {\rm Ex}\nolimits }\)

\(\newcommand {\Out }{\mathop {\rm Out}\nolimits }\)

\(\newcommand {\Cyl }{\mathop {\rm Cyl}\nolimits }\)

\(\newcommand {\Path }{\mathop {\rm Path}\nolimits }\)

\(\newcommand {\Ch }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\SSet }{\mathop {\rm \Set ^{\Delta ^{op}}}\nolimits }\)

\(\newcommand {\Sq }{\mathop {\rm Sq}\nolimits }\)

\(\newcommand {\Free }{\mathop {\rm Free}\nolimits }\)

\(\newcommand {\Map }{\mathop {\rm Map}\nolimits }\)

\(\newcommand {\Chain }{\mathop {\rm Ch}\nolimits }\)

\(\newcommand {\LMap }{\mathop {\rm LMap}\nolimits }\)

\(\newcommand {\RMap }{\mathop {\rm RMap}\nolimits }\)

\(\newcommand {\Tot }{\mathop {\rm Tot}\nolimits }\)

\(\newcommand {\MU }{\mathop {\rm MU}\nolimits }\)

\(\newcommand {\MSU }{\mathop {\rm MSU}\nolimits }\)

\(\newcommand {\MSp }{\mathop {\rm MSp}\nolimits }\)

\(\newcommand {\MSO }{\mathop {\rm MSO}\nolimits }\)

\(\newcommand {\MO }{\mathop {\rm MO}\nolimits }\)

\(\newcommand {\BU }{\mathop {\rm BU}\nolimits }\)

\(\newcommand {\KU }{\mathop {\rm KU}\nolimits }\)

\(\newcommand {\BSU }{\mathop {\rm BSU}\nolimits }\)

\(\newcommand {\BSp }{\mathop {\rm BSp}\nolimits }\)

\(\newcommand {\BGL }{\mathop {\rm BGL}\nolimits }\)

\(\newcommand {\BSO }{\mathop {\rm BSO}\nolimits }\)

\(\newcommand {\BO }{\mathop {\rm BO}\nolimits }\)

\(\newcommand {\KO }{\mathop {\rm KO}\nolimits }\)

\(\newcommand {\Tor }{\mathop {\rm Tor}\nolimits }\)

\(\newcommand {\Cotor }{\mathop {\rm Cotor}\nolimits }\)

\(\newcommand {\imag }{\mathop {\rm Im}\nolimits }\)

\(\newcommand {\real }{\mathop {\rm Re}\nolimits }\)

\(\newcommand {\Cat }{\mathop {\rm Cat}\nolimits }\)

\(\newcommand {\Fld }{\mathop {\rm Fld}\nolimits }\)

\(\newcommand {\Frac }{\mathop {\rm Frac}\nolimits }\)

\(\newcommand {\Dom }{\mathop {\rm Dom}\nolimits }\)

\(\newcommand {\Hotc }{\mathop {\rm Hotc}\nolimits }\)

\(\newcommand {\Top }{\mathop {\rm Top}\nolimits }\)

\(\newcommand {\Ring }{\mathop {\rm Ring}\nolimits }\)

\(\newcommand {\CRing }{\mathop {\rm CRing}\nolimits }\)

\(\newcommand {\CGHaus }{\mathop {\rm CGHaus}\nolimits }\)

\(\newcommand {\Alg }{\mathop {\rm Alg}\nolimits }\)

\(\newcommand {\Bool }{\mathop {\rm Bool}\nolimits }\)

\(\newcommand {\hTop }{\mathop {\rm hTop}\nolimits }\)

\(\newcommand {\Nat }{\mathop {\rm Nat}\nolimits }\)

\(\newcommand {\Rel }{\mathop {\rm Rel}\nolimits }\)

\(\newcommand {\Mod }{\mathop {\rm Mod}\nolimits }\)

\(\newcommand {\Space }{\mathop {\rm Space}\nolimits }\)

\(\newcommand {\Vect }{\mathop {\rm Vect}\nolimits }\)

\(\newcommand {\FinVect }{\mathop {\rm FinVect}\nolimits }\)

\(\newcommand {\Matr }{\mathop {\rm Matr}\nolimits }\)

\(\newcommand {\Ab }{\mathop {\rm Ab}\nolimits }\)

\(\newcommand {\Gr }{\mathop {\rm Gr}\nolimits }\)

\(\newcommand {\Grp }{\mathop {\rm Grp}\nolimits }\)

\(\newcommand {\Hol }{\mathop {\rm Hol}\nolimits }\)

\(\newcommand {\Gpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Grpd }{\mathop {\rm Gpd}\nolimits }\)

\(\newcommand {\Mon }{\mathop {\rm Mon}\nolimits }\)

\(\newcommand {\FinSet }{\mathop {\rm FinSet}\nolimits }\)

\(\newcommand {\Sch }{\mathop {\rm Sch}\nolimits }\)

\(\newcommand {\AffSch }{\mathop {\rm AffSch}\nolimits }\)

\(\newcommand {\Idem }{\mathop {\rm Idem}\nolimits }\)

\(\newcommand {\SIdem }{\mathop {\rm SIdem}\nolimits }\)

\(\newcommand {\Aut }{\mathop {\rm Aut}\nolimits }\)

\(\newcommand {\Ord }{\mathop {\rm Ord}\nolimits }\)

\(\newcommand {\coker }{\mathop {\rm coker}\nolimits }\)

\(\newcommand {\ch }{\mathop {\rm char}\nolimits }\)

\(\newcommand {\Sym }{\mathop {\rm Sym}\nolimits }\)

\(\newcommand {\adj }{\mathop {\rm adj}\nolimits }\)

\(\newcommand {\dil }{\mathop {\rm dil}\nolimits }\)

\(\newcommand {\Cl }{\mathop {\rm Cl}\nolimits }\)

\(\newcommand {\Diff }{\mathop {\rm Diff}\nolimits }\)

\(\newcommand {\End }{\mathop {\rm End}\nolimits }\)

\(\newcommand {\Hom }{\mathop {\rm Hom}\nolimits }\)

\(\newcommand {\Gal }{\mathop {\rm Gal}\nolimits }\)

\(\newcommand {\Pos }{\mathop {\rm Pos}\nolimits }\)

\(\newcommand {\Ad }{\mathop {\rm Ad}\nolimits }\)

\(\newcommand {\GL }{\mathop {\rm GL}\nolimits }\)

\(\newcommand {\SL }{\mathop {\rm SL}\nolimits }\)

\(\newcommand {\vol }{\mathop {\rm vol}\nolimits }\)

\(\newcommand {\reg }{\mathop {\rm reg}\nolimits }\)

\(\newcommand {\Or }{\textnormal {O}}\)

\(\newcommand {\U }{\mathop {\rm U}\nolimits }\)

\(\newcommand {\SOr }{\mathop {\rm SO}\nolimits }\)

\(\newcommand {\SU }{\mathop {\rm SU}\nolimits }\)

\(\newcommand {\Spin }{\mathop {\rm Spin}\nolimits }\)

\(\newcommand {\Sp }{\mathop {\rm Sp}\nolimits }\)

\(\newcommand {\Int }{\mathop {\rm Int}\nolimits }\)

\(\newcommand {\im }{\mathop {\rm im}\nolimits }\)

\(\newcommand {\dom }{\mathop {\rm dom}\nolimits }\)

\(\newcommand {\di }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\cod }{\mathop {\rm cod}\nolimits }\)

\(\newcommand {\colim }{\mathop {\rm colim}\nolimits }\)

\(\newcommand {\ad }{\mathop {\rm ad}\nolimits }\)

\(\newcommand {\PSL }{\mathop {\rm PSL}\nolimits }\)

\(\newcommand {\PGL }{\mathop {\rm PGL}\nolimits }\)

\(\newcommand {\sep }{\mathop {\rm sep}\nolimits }\)

\(\newcommand {\MCG }{\mathop {\rm MCG}\nolimits }\)

\(\newcommand {\oMCG }{\mathop {\rm MCG^+}\nolimits }\)

\(\newcommand {\Spec }{\mathop {\rm Spec}\nolimits }\)

\(\newcommand {\rank }{\mathop {\rm rank}\nolimits }\)

\(\newcommand {\diverg }{\mathop {\rm div}\nolimits }\)

\(\newcommand {\disc }{\mathop {\rm disc}\nolimits }\)

\(\newcommand {\sign }{\mathop {\rm sign}\nolimits }\)

\(\newcommand {\Arf }{\mathop {\rm Arf}\nolimits }\)

\(\newcommand {\Pic }{\mathop {\rm Pic}\nolimits }\)

\(\newcommand {\Tr }{\mathop {\rm Tr}\nolimits }\)

\(\newcommand {\res }{\mathop {\rm res}\nolimits }\)

\(\newcommand {\Proj }{\mathop {\rm Proj}\nolimits }\)

\(\newcommand {\mult }{\mathop {\rm mult}\nolimits }\)

\(\newcommand {\N }{\mathop {\rm N}\nolimits }\)

\(\newcommand {\lk }{\mathop {\rm lk}\nolimits }\)

\(\newcommand {\Pf }{\mathop {\rm Pf}\nolimits }\)

\(\newcommand {\sgn }{\mathop {\rm sgn}\nolimits }\)

\(\newcommand {\grad }{\mathop {\rm grad}\nolimits }\)

\(\newcommand {\lcm }{\mathop {\rm lcm}\nolimits }\)

\(\newcommand {\Ric }{\mathop {\rm Ric}\nolimits }\)

\(\newcommand {\Hess }{\mathop {\rm Hess}\nolimits }\)

\(\newcommand {\sn }{\mathop {\rm sn}\nolimits }\)

\(\newcommand {\cut }{\mathop {\rm cut}\nolimits }\)

\(\newcommand {\tr }{\mathop {\rm tr}\nolimits }\)

\(\newcommand {\codim }{\mathop {\rm codim}\nolimits }\)

\(\newcommand {\ind }{\mathop {\rm index}\nolimits }\)

\(\newcommand {\rad }{\mathop {\rm rad}\nolimits }\)

\(\newcommand {\Rep }{\mathop {\rm Rep}\nolimits }\)

\(\newcommand {\Lie }{\mathop {\rm Lie}\nolimits }\)

\(\newcommand {\Der }{\mathop {\rm Der}\nolimits }\)

\(\newcommand {\hgt }{\mathop {\rm ht}\nolimits }\)

\(\newcommand {\Ider }{\mathop {\rm Ider}\nolimits }\)

\(\newcommand {\id }{\mathop {\rm id}\nolimits }\)

</div>

<p>
<!--................................-->
<h4 id="autosec-5"><span class="sectionnumber">1&#x2003;</span>Whitehead and Samelson products</h4>
<a id="Tools_of_Unstable_Homotopy_Theory_h-autopage-5"></a>
<a id="Tools_of_Unstable_Homotopy_Theory_h-autofile-1"></a>

<p>
A basic incarnation of this is the fact the associated graded of the lower central series of the homotopy groups of \(\Omega X\) forms a Lie algebra<sup>1</sup>. The origin of this Lie algebra structure is exactly the same as for
discrete groups: it comes from the commutator map.
</p>

<p>
Given a pointed space \(V\), we can take homotopy groups with coefficients in \(V\), i.e \(\pi _i^V(X) = \pi _i(X^V) = [\Sigma ^iV,X]\). In what follows, one may assume \(W,V = S^0\) to obtain statements about ordinary
homotopy groups. Given \(x \in \pi _k^V(\Omega X), y \in \pi _n^W(\Omega X)\), the commutator map \(c(x,y) =xyx^{-1}y^{-1}\) gives a map<sup>2</sup>,
</p>

<p>
\[\Sigma ^{k}\Sigma ^n(V\wedge W) \xrightarrow {\sim }\Sigma ^kV\wedge \Sigma ^n W \to \Omega X\wedge \Omega X \xrightarrow {c} \Omega X\]
</p>

<p>
which we denote \(\langle x ,y\rangle \), and is called the <b>Samelson product</b>. The universal case of the Samelson product is when \(X = \Sigma (\Sigma ^kV\vee \Sigma ^n W)\), where it amounts to a map
\(\Sigma ^{k}\Sigma ^n(V\wedge W) \to \Omega \Sigma (\Sigma ^kV \vee \Sigma ^nW)\).
</p>

<p>
This is adjoint to a map \(\Sigma \Sigma ^k\Sigma ^n(V\wedge W) \to \Sigma (\Sigma ^kV \vee \Sigma ^nW)\), and one sees that the composite
</p>

<p>
\[\Sigma \Sigma ^k\Sigma ^n(V\wedge W) \to \Sigma (\Sigma ^kV \vee \Sigma ^nW) \to \Sigma ^{k+1}{V}\times \Sigma ^{n+1}W\]
</p>

<p>
is canonically null, since the adjoint map is null since \(\Sigma ^kV\) and \(\Sigma ^nW\) canonically commute in \(\Omega \Sigma (\Sigma ^kV)\times \Omega \Sigma (\Sigma ^nW)\).
</p>

<p>
This nulhomotopy in fact gives rise to a cofibre sequence. To check this, it suffices to observe that we can assume \(n,k=0\), and \(V,W\) are finite sets, since the sequence commutes with sifted colimits. Then this amounts to the
fact that the product \((\vee _1^lS^1)\times (\vee _1^mS^1)\) is obtained from \((\vee _1^lS^1)\vee (\vee _1^mS^1)\) by attaching 2-cells killing all commutators between the two parts.
</p>

<p>
The Whitehead product is up to a sign, adjoint to the Samelson product. Given maps \(x \in \pi _{k+1}^V(X),y \in \pi _{n+1}^W(X)\), the Whitehead product is the operation denoted \([x,y]\in \pi _{k+n+1}^{V\wedge
W}(X)\) corepresented by the map
</p>

<p>
\[\Sigma ^{k}\Sigma \Sigma ^n(V\wedge W)\xrightarrow {\sim }\Sigma \Sigma ^k\Sigma ^n(V\wedge W) \to \Sigma (\Sigma ^kV \vee \Sigma ^nW)\]
</p>

<p>
where the second map is adjoint to the Samelson product.
</p>

<p>
On the level of homotopy classes, we have that \([x,y]\) is adjoint to \((-1)^{x+1}\langle x&apos;,y&apos;\rangle \). We claim that the Whitehead product satisfies Lie algebra identities:
</p>
<div role="note" class="footnotes">

<a id="Tools_of_Unstable_Homotopy_Theory_h-autopage-6"></a>

<p>
<sup>1</sup>&nbsp;if \(\pi _1\) acts trivially on \(\pi _n\), the lower central series is trivial, and so the Lie algebra structure is just on \(\pi _*\Omega X\).
</p>

<p>
<sup>2</sup>&nbsp;It is written as \(\Sigma ^k\Sigma ^n\) rather than \(\Sigma ^{k+n}\) to indicate the sign.
</p>


</div>



<div class="amsthmbodyplain">

<ul style="list-style-type:none">


<li>
<p>


<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">1.1</span></span>. <a id="whiteheadprodprop"></a> The Whitehead product satisfies for \(x\in \pi
_i^U(X),y \in \pi _j^V(X), z \in \pi _k^W(X)\) for \(i,j,k \geq 2\):
</p>
<ul style="list-style-type:none">


<li>
<p>
1. It is bilinear.
</p>


</li>
<li>


<p>
2. \([x,y] = (-1)^{|xy|}[y,x]\)
</p>


</li>
<li>


<p>
3. \([[x,y],z](-1)^{|xz|} + [[y,z],x](-1)^{|yx|} + [[z,x],y](-1)^{|zy|} = 0\)
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Tools_of_Unstable_Homotopy_Theory_h-autopage-7"></a>

<ul style="list-style-type:none">


<li>
<p>
<span class="amsthmproofname">Proof.</span> We will check the most interesting relation, \((3)\). On the level of Samelson products, it corresponds to the identity:
</p>

<ul style="list-style-type:none">


<li>
<p>
• \(\langle x,\langle y,z\rangle \rangle + \langle y,\langle z,x\rangle \rangle (-1)^{|x(y+z)|} + \langle z,\langle x ,y\rangle \rangle (-1)^{|z(x+y)|} = 0\)
</p>
</li>
</ul>

<p>
This follows from the fact that in any group, \([x,[y,z]][y,[z,x]][z,[x,y]] = 1\) modulo commutators of length \(4\). Iterated Samelson products of length \(4\) in \(3\) variables are null, since they are factor through a
map smashed with a diagonal map of the form \(S^k \xrightarrow {\Delta } S^n\wedge S^n\), which is null since since \(n\geq 1\). Thus the desired relation holds. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
When \(i,j,k\) are allowed to be \(1\), the relations are still satisfied, but only in the associated graded of the lower central series.
</p>

<p>
Note from the proof of Lemma <a href="node-Whitehead-Samelson-products.html#whiteheadprodprop">1.1</a> that there does not seem to be a canonical homotopy for the Jacobi identity.
</p>

</section>

</main>

</div>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
